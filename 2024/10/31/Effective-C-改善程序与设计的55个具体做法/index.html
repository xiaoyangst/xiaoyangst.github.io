<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf8" />
    <meta name="viewport" content="initial-scale=1.0, width=device-width" />
    <title>
      
        Effective C++ 改善程序与设计的55个具体做法 | 
      
    </title>
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    
      <link rel="apple-touch-icon"
            sizes="180x180"
            href="/images/logo.png" />
    
    
      <link rel="icon"
            type="image/png"
            sizes="32x32"
            href="/images/logo.png" />
    
    
      <link rel="icon"
            type="image/png"
            sizes="16x16"
            href="/images/logo.png" />
    
    
      <link rel="mask-icon"
            href="/images/logo.png"
            color="" />
    
    
    
      
  <style>
    @font-face {
        font-family:sourceHanSerif;
        src: url(/font/MapleMono-CN-Bold.ttf);
        font-weight: MapleMono-CN-Bold;
    }
  </style>


    
    <link rel="stylesheet"
          type="text/css"
          href='/css/layout.css' />
    
      <script>
        var _hmt = _hmt || [];
        (function () {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?a2cae4eb8b82546e147114262bd550f1";
          var s = document.getElementsByTagName("script")[0];
          s
            .parentNode
            .insertBefore(hm, s);
        })();
      </script>
    
    
  <link rel="stylesheet" type="text/css" href="/css/post.css"/>
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"/>

  <meta name="generator" content="Hexo 7.3.0"></head>
  <body>
    
      <div id="search-mask" style="display:none">
  <div class="search-main" id="search-main">
    <div class="search__head">
      <div class="search-form">
        <svg t="1706347533072"
             class="icon"
             viewBox="0 0 1024 1024"
             version="1.1"
             xmlns="http://www.w3.org/2000/svg"
             p-id="7828"
             width="20"
             height="20">
          <path d="M685.6 660.336l155.152 155.168a16 16 0 0 1 0 22.624l-11.312 11.328a16 16 0 0 1-22.624 0l-158.528-158.544a289.792 289.792 0 0 1-165.152 51.36C322.336 742.256 192 611.904 192 451.12 192 290.336 322.336 160 483.136 160c160.784 0 291.12 130.336 291.12 291.136 0 82.112-33.984 156.272-88.672 209.2z m-202.464 33.92c134.272 0 243.12-108.848 243.12-243.12C726.256 316.848 617.408 208 483.136 208 348.848 208 240 316.848 240 451.136c0 134.272 108.848 243.12 243.136 243.12z" fill="#000000" p-id="7829">
          </path>
        </svg>
        <input id="search-input" placeholder="搜索文章">
        <svg t="1706361500528"
             id="search-clear"
             class="icon"
             viewBox="0 0 1024 1024"
             version="1.1"
             xmlns="http://www.w3.org/2000/svg"
             p-id="4351"
             width="20"
             height="20">
          <path d="M512 562.688l-264.2944 264.2944-50.688-50.688L461.312 512 197.0176 247.7056l50.688-50.688L512 461.312l264.2944-264.2944 50.688 50.688L562.688 512l264.2944 264.2944-50.688 50.688L512 562.688z" fill="#00" p-id="4352">
          </path>
        </svg>
      </div>
    </div>
    <div class="search__body" id="search-result"></div>
    <div class="search__foot"></div>
  </div>
</div>

    
    
    <div class=head>
      <div class="nav">
        <a href='/' class="nav-logo">
          <img alt="logo" height="60px" width="60px" src="/images/logo.png" />
        </a>
        <input id="navBtn" type="checkbox" />
        <div class="nav-right">
          
            <div class="search-outer">
  <div class="search" id="search-btn">
    <svg t="1706347533072"
         class="icon"
         viewBox="0 0 1024 1024"
         version="1.1"
         xmlns="http://www.w3.org/2000/svg"
         p-id="7828"
         width="20"
         height="20">
      <path d="M685.6 660.336l155.152 155.168a16 16 0 0 1 0 22.624l-11.312 11.328a16 16 0 0 1-22.624 0l-158.528-158.544a289.792 289.792 0 0 1-165.152 51.36C322.336 742.256 192 611.904 192 451.12 192 290.336 322.336 160 483.136 160c160.784 0 291.12 130.336 291.12 291.136 0 82.112-33.984 156.272-88.672 209.2z m-202.464 33.92c134.272 0 243.12-108.848 243.12-243.12C726.256 316.848 617.408 208 483.136 208 348.848 208 240 316.848 240 451.136c0 134.272 108.848 243.12 243.136 243.12z" fill="#000000" p-id="7829">
      </path>
    </svg>
    <span>搜索</span>
    <span class="search-shortcut-key">Ctrl K</span>
  </div>
</div>

          
          <div class="nav-menu">
            
              
                <a class="nav-menu-item" href="/technology">计算机技术</a>
              
                <a class="nav-menu-item" href="/knowledge">学科知识库</a>
              
                <a class="nav-menu-item" href="/life">生活</a>
              
                <a class="nav-menu-item" href="/leetcode">力扣</a>
              
                <a class="nav-menu-item" href="/books">豆瓣读书</a>
              
            
            
          </div>
        </div>
        <label class="nav-btn" for="navBtn"></label>
      </div>
    </div>
    <div class="body">
      
  <article class="post-content">
    <div class="post-inner">
      <div class="post-content__head">
        <div class="post-title">Effective C++ 改善程序与设计的55个具体做法</div>
        <div class="post-info">
          
  <a href="/tags/CPP/" class="post-tag">#CPP</a>


          <span class="post-date">2024-10-31</span>
        </div>
      </div>
      
      <div class="post-content__body">
        
          <div class="post-gallery">
            
          </div>
        
        <!-- toc -->
<ul>
<li><a href="#尽量用const-enum和inline取代define">尽量用const,
enum和inline取代#define</a></li>
<li><a href="#尽可能使用const">尽可能使用const</a></li>
<li><a href="#确定对象被使用前已先被初始化">确定对象被使用前已先被初始化</a></li>
<li><a href="#了解c默默编写并调用哪些函数">了解C++默默编写并调用哪些函数</a></li>
<li><a href="#若不想使用编译器自动生成的函数就该明确拒绝">若不想使用编译器自动生成的函数，就该明确拒绝</a></li>
<li><a href="#为多态基类声明-virtual-析构函数">为多态基类声明 virtual
析构函数</a></li>
<li><a href="#别让异常逃离析构函数">别让异常逃离析构函数</a></li>
<li><a href="#绝不在构造和析构过程中调用virtual函数">绝不在构造和析构过程中调用virtual函数</a></li>
<li><a href="#让赋值运算符返回一个-reference-to-this引向-this-的引用">让赋值运算符返回一个
reference to *this（引向 *this 的引用）</a></li>
<li><a href="#复制对象时勿忘其每一个成分">复制对象时勿忘其每一个成分</a></li>
<li><a href="#使用对象管理资源">使用对象管理资源</a></li>
<li><a href="#谨慎考虑资源管理类的拷贝行为">谨慎考虑资源管理类的拷贝行为</a></li>
<li><a href="#成对使用new和delete时要采用相同形式">成对使用new和delete时要采用相同形式</a></li>
<li><a href="#在一个独立的语句中将-new-出来的对象存入智能指针">在一个独立的语句中将
new 出来的对象存入智能指针</a></li>
<li><a href="#用传引用取代值传递">用传引用取代值传递</a></li>
<li><a href="#当你必须返回一个对象时不要试图返回一个引用">当你必须返回一个对象时不要试图返回一个引用</a></li>
<li><a href="#只要有可能就推迟变量定义">只要有可能就推迟变量定义</a></li>
<li><a href="#将成员变量声明为private">将成员变量声明为private</a></li>
<li><a href="#将强制类型减到最少">将强制类型减到最少</a></li>
<li><a href="#避免返回对象内部的句柄">避免返回对象内部的句柄</a></li>
<li><a href="#争取异常安全的代码">争取异常安全的代码</a></li>
<li><a href="#理解-inline-化的介入和排除">理解 inline
化的介入和排除</a></li>
<li><a href="#最小化文件之间的编译依赖">最小化文件之间的编译依赖</a></li>
<li><a href="#确定你的public继承塑模出is-a关系">确定你的public继承塑模出is-a关系</a></li>
<li><a href="#避免遮挡继承而来的名称">避免遮挡继承而来的名称</a></li>
<li><a href="#区分接口继承和实现继承">区分接口继承和实现继承</a></li>
<li><a href="#绝不要重定义一个通过继承得到的非虚函数易错">绝不要重定义一个通过继承得到的非虚函数（易错）</a></li>
<li><a href="#绝不重新定义继承而来的缺省参数值">绝不重新定义继承而来的缺省参数值</a></li>
<li><a href="#通过复合塑模出has-a">通过复合塑模出has-a</a></li>
<li><a href="#明智而审慎地使用private继承">明智而审慎地使用private继承</a></li>
<li><a href="#谨慎使用多继承">谨慎使用多继承</a></li>
<li><a href="#了解隐式接口和编译期多态">了解隐式接口和编译期多态</a></li>
<li><a href="#将与参数无关的代码抽离templates">将与参数无关的代码抽离templates</a></li>
<li><a href="#写了placement-new也要写placement-delete">写了placement
new也要写placement delete</a></li>
</ul>
<!-- tocstop -->
<h2><span id="尽量用constenum和inline取代define">尽量用const,
enum和inline取代#define</span></h2>
<p>#define
定义的常量和函数都是单纯的文本替换，没有任何检查，这存在安全隐患。</p>
<p>定义常量选择 const，定义宏函数选择 inline，定义枚举选用 enum。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ASPECT_RATIO 1.653 <span class="hljs-comment">// 不推荐</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> AspectRatio = <span class="hljs-number">1.653</span>; <span class="hljs-comment">// 推荐</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b)) <span class="hljs-comment">// 不推荐</span></span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">callWithMax</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; a, <span class="hljs-type">const</span> T&amp; b)</span> <span class="hljs-comment">// 推荐</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">f</span>(a &gt; b ? a : b);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EMERG 0	<span class="hljs-comment">// 不推荐</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FATAL 1	<span class="hljs-comment">// 不推荐</span></span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">LOGLEVEL</span> &#123; EMERG, FATAL, ALERT, CRIT, ERROR, WARN, NOTICE, INFO, DEBUG &#125;;	<span class="hljs-comment">//推荐</span><br></code></pre></td></tr></table></figure>
<h2><span id="尽可能使用const">尽可能使用const</span></h2>
<p>常量指针：指向的对象的值可以修改，但不可以更改所值对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p<br>    或者;<br><span class="hljs-type">int</span> <span class="hljs-type">const</span> *p（不推荐）<br></code></pre></td></tr></table></figure>
<p>指向常量的指针：指向的对象的值不能修改，但可以更改所值对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* p;<br></code></pre></td></tr></table></figure>
<p>双重const限定的指针：既不能修改所指对象，也不能修改所指对象的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> p4<br></code></pre></td></tr></table></figure>
<p>总结：根据要施加与对象的特性，选择合适的方式，可对代码起到保护作用。</p>
<h2><span id="确定对象被使用前已先被初始化">确定对象被使用前已先被初始化</span></h2>
<p>成员函数要进行初始化操作，避免后续使用出现未定义行为。</p>
<ul>
<li>初始化顺序按照成员变量定义的顺序初始化</li>
<li>尽可能选择构造函数初始化列表初始化，而不是在构造函数函数体中初始化</li>
<li>为免除”跨编译单元之初始化次序”问题，请以 local stati 对象替换
non-local static 对象。</li>
</ul>
<p>如何理解最后一句话？</p>
<p>在多个源文件中，静态对象的初始化顺序是不确定的。也就是说，如果一个源文件中的静态对象依赖于另一个源文件中的静态对象的初始化结果，就可能会出现未定义的行为，因为不同编译单元中的静态对象初始化顺序是无法预测的。</p>
<p>为了解决这个问题，可以使用局部静态对象（local static
object）。局部静态对象是在函数内部定义的静态对象，它的初始化只会在第一次调用该函数时发生。由于局部静态对象的初始化是有序的（保证先调用函数后才初始化），因此可以避免跨编译单元间的初始化顺序问题。</p>
<h2><span id="了解c默默编写并调用哪些函数">了解C++默默编写并调用哪些函数</span></h2>
<p>如果你定义一个空类，啥也不做，也是有相关实现的。</p>
<p>如果你自己不声明一个 copy constructor（拷贝构造函数），一个 copy
assignment operator（拷贝赋值运算符）和一个
destructor（析构函数），编译器就会为这些东西声明一个它自己的版本。此外，如果你自己根本没有声明
constructor（构造函数），编译器就会为你声明一个 default
constructor（缺省构造函数）。所有这些函数都被声明为 public 和
inline。</p>
<h2><span id="若不想使用编译器自动生成的函数就该明确拒绝">若不想使用编译器自动生成的函数，就该明确拒绝</span></h2>
<p>选择 delete 将其拒绝，作者说用 private，那是之前的技巧。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&lt;T&gt;&amp;) = <span class="hljs-keyword">delete</span>;<br>  Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&lt;T&gt;&amp; st) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2><span id="为多态基类声明-virtual析构函数">为多态基类声明 virtual
析构函数</span></h2>
<p>见此文：<a href="https://xiaoyangst.github.io/2024/08/05/%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E5%9C%BA%E6%99%AF/">虚析构函数的场景</a></p>
<p>将基类的析构函数声明为
virtual，是为了能够回收派生类的资源，即调用派生类的析构函数。</p>
<h2><span id="别让异常逃离析构函数">别让异常逃离析构函数</span></h2>
<p>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。</p>
<p>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么 class
应该提供一个普通函数（而非在析构函数中）执行该操作。</p>
<h2><span id="绝不在构造和析构过程中调用virtual函数">绝不在构造和析构过程中调用virtual函数</span></h2>
<ul>
<li>不确定的类型：在构造函数期间，当前对象的动态类型并不是派生类，而是正在构造的基类。调用虚函数时，实际调用的将是基类中定义的版本，而不是派生类的重写版本。这可能导致程序的行为与预期不符。</li>
<li>不完整的对象：在构造过程中，对象的成员变量尚未完全初始化，可能会导致调用虚函数时访问未初始化的成员，从而引发未定义行为。</li>
<li>资源管理和内存问题：在析构过程中调用虚函数可能导致使用已经释放或部分释放的资源，进而引发程序崩溃或内存泄漏。</li>
</ul>
<h2><span id="让赋值运算符返回一个reference-to-this引向-this-的引用">让赋值运算符返回一个
reference to *this（引向 *this 的引用）</span></h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>	Widget&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> Widget&amp; rhs) <span class="hljs-comment">// 返回类型是个reference,指向当前对象</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>	&#125;<br> <br>	Widget&amp; <span class="hljs-keyword">operator</span>+= (<span class="hljs-type">const</span> Widget&amp; rhs) <span class="hljs-comment">// 这个协议适用于+=、-=、*=等等</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>	&#125;<br> <br>	Widget&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">int</span> rhs) <span class="hljs-comment">// 此函数也适用，即使此一操作符的参数类型不符协定</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2><span id="复制对象时勿忘其每一个成分">复制对象时勿忘其每一个成分</span></h2>
<p>当你声明了你自己的拷贝函数，你就是在告诉编译器你不喜欢缺省实现中的某些东西。</p>
<p>因此，你每次给类添加新成员变量的时候，你就得做到更新拷贝函数。</p>
<h2><span id="使用对象管理资源">使用对象管理资源</span></h2>
<p>即选择智能指针管理对象，书中提到的 auto_ptr 已过时，抛弃即可。</p>
<h2><span id="谨慎考虑资源管理类的拷贝行为">谨慎考虑资源管理类的拷贝行为</span></h2>
<p>拷贝构造函数和拷贝赋值运算符函数可能被编译器自动创建出来，因此除非编译器所生版本做了你想要做的事，否则你得自己编写它们。</p>
<h2><span id="成对使用new和delete时要采用相同形式">成对使用new和delete时要采用相同形式</span></h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">new</span>               <span class="hljs-keyword">delete</span>		<span class="hljs-comment">// 单个对象</span><br>    <br><span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>]()      <span class="hljs-keyword">delete</span>[]	      <span class="hljs-comment">// 多个对象</span><br></code></pre></td></tr></table></figure>
<h2><span id="在一个独立的语句中将new-出来的对象存入智能指针">在一个独立的语句中将
new 出来的对象存入智能指针</span></h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">priority</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processWidget</span><span class="hljs-params">(std::shared_ptr&lt;Widget&gt; pw, <span class="hljs-type">int</span> priority)</span> </span>&#123;&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test_item_17</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// 不推荐，可能资源泄露</span><br>	<span class="hljs-built_in">processWidget</span>(std::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget), <span class="hljs-built_in">priority</span>()); <br>	<br>       <span class="hljs-comment">// 推荐</span><br>	<span class="hljs-function">std::shared_ptr&lt;Widget&gt; <span class="hljs-title">pw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget)</span></span>; <span class="hljs-comment">// 在单独语句内以智能指针存储newed所得对象</span><br>	<span class="hljs-built_in">processWidget</span>(pw, <span class="hljs-built_in">priority</span>()); <span class="hljs-comment">// 这个调用动作绝不至于造成泄露</span><br> <br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>processWidget(std::shared_ptr&lt;Widget17&gt;(new Widget17), priority())</code></p>
<p>上面这种调用包含三种行为：</p>
<ul>
<li>调用 priority</li>
<li>执行 new Widge</li>
<li>调用 std::shared_ptr 的构造函数</li>
</ul>
<p>new Widget 表达式一定在 shared_ptr
的构造函数能被调用之前执行，因为这个表达式的结果要作为一个参数传递给
shared_ptr 的构造函数，但是 priority
的调用可以被第一个，第二个或第三个执行。如果编译器选择第二个执行它（大概这样能使它们生成更有效率的代码），我们最终得到这样一个操作顺序：</p>
<ol type="1">
<li>执行 new Widge</li>
<li>调用 priority</li>
<li>调用 std::shared_ptr 的构造函数</li>
</ol>
<p>如果对 priority 的调用引发一个异常将发生什么。在这种情况下，从 new
Widget 返回的指针被丢失，因为它没有被存入我们期望能阻止资源泄漏的
std::shared_ptr。由于一个异常可能插入资源创建的时间和将资源交给一个资源管理对象的时间之间，所以调用
processWidget 可能会发生一次泄漏。</p>
<p>因此，<strong>在构建智能指针对象的时候，应该单独一条语句，等构建成功才作为参数传递</strong>。</p>
<h2><span id="用传引用取代值传递">用传引用取代值传递</span></h2>
<p>要我说，尽可能用引用取代指针传递和值传递。</p>
<p>如果你是值传递，会触发拷贝构造函数，实属浪费资源。</p>
<p>如果你是指针传递，可是指针太容易误操作，而且极其难用。</p>
<h2><span id="当你必须返回一个对象时不要试图返回一个引用">当你必须返回一个对象时不要试图返回一个引用</span></h2>
<p>不是说不能返回，而是不建议这样做，即你得确保你的这个引用指向的对象不是局部（栈上的对象）。</p>
<p>返回引用的目的： 避免复制，节省开销。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">return</span> a;   <span class="hljs-comment">//在函数内部，当执行return语句时，会发生复制 </span><br>&#125;   <br><br><span class="hljs-function"><span class="hljs-type">int</span> &amp; <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>&#123;<br>     <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">return</span> b;   <span class="hljs-comment">//在函数内部，当执行return语句时，不会发生复制</span><br>&#125;  <br></code></pre></td></tr></table></figure>
<p>函数返回引用的要求：当以引用作为函数的返回值时，<span style="color:red;background:yellow"><strong>返回的变量其生命周期一定是要大于函数的生命周期</strong></span>的，即当函数执行完毕时，返回的变量还存在。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 错误写法，number 是栈内存</span><br><span class="hljs-function"><span class="hljs-type">int</span> &amp; <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> number = <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">return</span> number;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2><span id="只要有可能就推迟变量定义">只要有可能就推迟变量定义</span></h2>
<p>推迟变量定义是一种优化代码执行效率的做法，尤其在使用带有构造函数和析构函数的类时更为重要。因为在这种情况下，变量定义时会触发构造函数，而当变量离开作用域时则会触发析构函数。如果一个变量在定义后没有被使用，那么创建和销毁它就是无谓的性能开销。通过推迟变量定义，确保仅在需要使用变量时才创建它，可以有效地避免不必要的构造和析构成本，从而提升代码的运行效率。</p>
<p>见如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span> condition)</span> </span>&#123;<br>    MyClass obj;  <span class="hljs-comment">// 提前定义了变量</span><br>    <span class="hljs-keyword">if</span> (condition) &#123;<br>        obj.<span class="hljs-built_in">doSomething</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这种情况下，即便 condition 不满足，MyClass
的构造和析构函数依然会被调用，这造成了不必要的开销。优化后代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span> condition)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (condition) &#123;<br>        MyClass obj;  <span class="hljs-comment">// 仅在需要时定义</span><br>        obj.<span class="hljs-built_in">doSomething</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>简单来说就一句话，需要的时候再去定义对象，因为定义对象是由开销的，即内存的申请和销毁。</p>
<h2><span id="将成员变量声明为private">将成员变量声明为private</span></h2>
<p>如作者所言如果你使用函数去得到和设置它的值，你就能实现禁止访问，只读访问和读写访问。嘿嘿，如果你需要，你甚至可以实现只写访问。</p>
<h2><span id="将强制类型减到最少">将强制类型减到最少</span></h2>
<p>旧风格的强制转型依然合法，但是新的形式更可取。首先，在代码中它们更容易识别（无论是人还是像
grep
这样的工具都是如此），这样就简化了在代码中寻找类型系统被破坏的地方的过程。第二，更精确地指定每一个强制转型的目的，使得编译器诊断使用错误成为可能。例如，如果你试图使用一个
const_cast 以外的新风格强制转型来消除常量性，你的代码将无法编译。</p>
<p>尽管如此，如果通过设计能够让强制类型转换不存在，那是再好不过。</p>
<p>（一）const_cast</p>
<p>const_cast 一般用于强制消除对象的常量性。它是唯一能做到这一点的 C++
风格的强制转型。</p>
<p>但我们一般建议不用，既然已经给对象一个 const
属性，就应该保留，否则你一开始就不设置对象有 const 属性。</p>
<p>（二）dynamic_cast</p>
<p>dynamic_cast
主要用于执行“安全的向下转型”，也就是说，要确定一个对象是否是一个继承体系中的一个特定类型。它是唯一不能用旧风格语法执行的强制转型。也是唯一可能有重大运行时代价的强制转型。</p>
<p>这种情况就说明多态存在，dynamic_cast
频繁使用，只会让性能受到影响。追求性能，还是考虑设计尽可能避免
dynamic_cast 的使用。</p>
<p>（三）reinterpret_cast</p>
<p>reinterpret_cast
是特意用于底层的强制转型，导致实现依赖（就是说，不可移植）的结果，例如，将一个指针转型为一个整数。这样的强制转型在底层代码以外应该极为罕见。在本书中我只用了一次，而且还仅仅是在讨论你应该如何为裸内存（raw
memory）写一个调谐分配者（debugging allocator）的时候。</p>
<p>很少会被用到，特殊场景会有用，之前学《对象模型》有用到过。</p>
<p>（四）static_cast</p>
<p>static_cast 可以被用于强制隐型转换（例如，non-const 对象转型为 const
对象，int 转型为
double，等等）。它还可以用于很多这样的转换的反向转换（例如，void*
指针转型为有类型指针，基类指针转型为派生类指针），但是它不能将一个 const
对象转型为 non-const 对象。（只有 const_cast 能做到。）</p>
<h2><span id="避免返回对象内部的句柄">避免返回对象内部的句柄</span></h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Point&amp; <span class="hljs-title">upperLeft</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pData-&gt;ulhc; &#125;<br>    <span class="hljs-function">Point&amp; <span class="hljs-title">lowerRight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pData-&gt;lrhc; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>封装性破坏</strong>：upperLeft 和 lowerRight 返回了
pData-&gt;ulhc 和 pData-&gt;lrhc 的非 const 引用，允许外部客户直接修改
Rectangle 的内部数据 ulhc 和 lrhc，破坏了 Rectangle 的封装性。</li>
<li><strong>const 语义冲突</strong>：尽管 upperLeft 和 lowerRight
被声明为 const 成员函数，但由于返回的引用是非
const，客户依然可以通过这些函数修改 Rectangle 的数据，这与 const
语义不符，导致 const 限定形同虚设。</li>
<li><strong>悬空句柄风险</strong>：当这些函数用于临时对象时，返回的引用可能指向被销毁的临时对象的成员数据，导致悬空句柄问题。</li>
</ul>
<p>前面刚讲返回引用要慎重，着重强调避免返回临时对象。没想到还有其他需要注意点，比方说设置为私有的成员，也没有提供接口来设置值，含义就是不允许修改。但现在好了，返回非
const
引用，导致可以被外界修改，这就是不恰当的。因此，我们还要保证私有成员返回
const 引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">const</span> Point&amp; <span class="hljs-title">upperLeft</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pData-&gt;ulhc; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> Point&amp; <span class="hljs-title">lowerRight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pData-&gt;lrhc; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2><span id="争取异常安全的代码">争取异常安全的代码</span></h2>
<p>异常安全函数提供下述三种保证之一：</p>
<ol type="1">
<li>函数提供基本保证，允诺如果一个异常被抛出，程序中剩下的每一件东西都处于合法状态。没有对象或数据结构被破坏，而且所有的对象都处于内部调和状态（所有的类不变量都被满足）。然而，程序的精确状态可能是不可预期的。</li>
<li>函数提供强力保证，允诺如果一个异常被抛出，程序的状态不会发生变化。调用这样的函数在感觉上是极其微弱的，如果它们成功了，它们就完全成功，如果它们失败了，程序的状态就像它们从没有被调用过一样。</li>
<li>函数提供不抛出保证，允诺决不抛出异常，因为它们只做它们答应要做的。所有对内建类型（例如，ints，指针，等等）的操作都是不抛出（nothrow）的（也就是说，提供不抛出保证）。这是异常安全代码中必不可少的基础构件。</li>
</ol>
<p>异常安全函数必须提供上述三种保证中的一种。如果它没有提供，它就不是异常安全的。于是，选择就在于决定你写的每一个函数究竟要提供哪种保证。</p>
<p>有个一般化的设计策略很典型地会导致强烈保证，这个策略被称为copy and
swap。原则很简单：为你打算修改的对象（原件）做出一份副本，然后在那副本身上做一切必要修改。若有任何修改动作抛出异常，原对象仍保持未改变状态。待所有改变都成功后，再将修改过的那个副本和原对象在一个不抛出异常的操作中置换(swap)。但一般而言它并不保证整个函数有强烈的异常安全性。</p>
<h2><span id="理解-inline-化的介入和排除">理解 inline 化的介入和排除</span></h2>
<p>如果一个 inline
函数本体很短，为函数本体生成的代码可能比为一个函数调用生成的代码还要小。如果是这种情况，inline
化这个函数可以实际上导致更小的目标代码和更高的指令缓存命中率！</p>
<p>记住，inline
是向编译器发出的一个请求，而不是一个命令，即最终的决定权在编译器手里。</p>
<p>inline 函数一般必须在头文件内，因为大多数构建环境在编译期间进行
inline
化。为了用被调用函数的函数本体替换一个函数调用，编译器必须知道函数看起来像什么样子。即
<strong>inline
函数的头文件定义和源文件实现都在头文件中，就像模板函数一样</strong>。</p>
<h2><span id="最小化文件之间的编译依赖">最小化文件之间的编译依赖</span></h2>
<p>即网上常常提及的pimpl用法，推荐文章：<a target="_blank" rel="noopener" href="https://github.com/balloonwj/CppGuide/blob/master/articles/C++%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/C++%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84pimpl%E6%83%AF%E7%94%A8%E6%B3%95.md">C++必须掌握的pimpl惯用法</a></p>
<p>没有使用 pimpl 之前：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Person.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Date</span>(<span class="hljs-type">const</span> std::string&amp; date) : <span class="hljs-built_in">dateStr</span>(date) &#123;&#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">toString</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> dateStr; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::string dateStr;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Address</span>(<span class="hljs-type">const</span> std::string&amp; addr) : <span class="hljs-built_in">addressStr</span>(addr) &#123;&#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">toString</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> addressStr; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::string addressStr;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthday, <span class="hljs-type">const</span> Address&amp; addr)<br>        : <span class="hljs-built_in">name_</span>(name), <span class="hljs-built_in">birthDate_</span>(birthday), <span class="hljs-built_in">address_</span>(addr) &#123;&#125;<br><br>    <span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> name_; &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> birthDate_.<span class="hljs-built_in">toString</span>(); &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> address_.<span class="hljs-built_in">toString</span>(); &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::string name_;<br>    Date birthDate_;<br>    Address address_;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>我们的头文件会提供给外界，但我们肯定不希望核心的实现被别人窥探，那么我们有什么办法解决这个问题？</p>
<p>使用 pimpl 之后：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Person.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthday, <span class="hljs-type">const</span> Address&amp; addr);<br>    ~<span class="hljs-built_in">Person</span>();<br><br>    <span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">std::string <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonImpl</span>;<br>    std::unique_ptr&lt;PersonImpl&gt; pImpl;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>你会发现，头文件中已经不包含 Date 和 Address 的实现，而是被我们放到
Person.cpp
文件中，到时候我们提供的是库文件和头文件，是没有源文件的，起到保护作用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Person.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Person.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Date</span>(<span class="hljs-type">const</span> std::string&amp; date) : <span class="hljs-built_in">dateStr</span>(date) &#123;&#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">toString</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> dateStr; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::string dateStr;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Address</span>(<span class="hljs-type">const</span> std::string&amp; addr) : <span class="hljs-built_in">addressStr</span>(addr) &#123;&#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">toString</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> addressStr; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::string addressStr;<br>&#125;;<br><br><span class="hljs-comment">// 实现类 PersonImpl</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>::PersonImpl &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">PersonImpl</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthday, <span class="hljs-type">const</span> Address&amp; addr)<br>        : <span class="hljs-built_in">theName</span>(name), <span class="hljs-built_in">theBirthDate</span>(birthday), <span class="hljs-built_in">theAddress</span>(addr) &#123;&#125;<br><br>    <span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> theName; &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> theBirthDate.<span class="hljs-built_in">toString</span>(); &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> theAddress.<span class="hljs-built_in">toString</span>(); &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::string theName;<br>    Date theBirthDate;<br>    Address theAddress;<br>&#125;;<br><br>Person::<span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthday, <span class="hljs-type">const</span> Address&amp; addr)<br>    : <span class="hljs-built_in">pImpl</span>(std::<span class="hljs-built_in">make_unique</span>&lt;PersonImpl&gt;(name, birthday, addr)) &#123;&#125;<br><br>Person::~<span class="hljs-built_in">Person</span>() = <span class="hljs-keyword">default</span>;<br><br><span class="hljs-function">std::string <span class="hljs-title">Person::name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pImpl-&gt;<span class="hljs-built_in">name</span>(); &#125;<br><span class="hljs-function">std::string <span class="hljs-title">Person::birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pImpl-&gt;<span class="hljs-built_in">birthDate</span>(); &#125;<br><span class="hljs-function">std::string <span class="hljs-title">Person::address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pImpl-&gt;<span class="hljs-built_in">address</span>(); &#125;<br></code></pre></td></tr></table></figure>
<p>当然，这种技法的好处可不止这一个，还能提高编译速度。</p>
<ul>
<li><p>核心数据成员被隐藏；</p>
<p>核心数据成员被隐藏，不必暴露在头文件中，对使用者透明，提高了安全性。</p></li>
<li><p>降低编译依赖，提高编译速度；</p>
<p>由于原来的头文件的一些私有成员变量可能是非指针非引用类型的自定义类型，需要在当前类的头文件中包含这些类型的头文件，使用了
<strong>pimpl</strong> 惯用法以后，这些私有成员变量被移动到当前类的 cpp
文件中，因此头文件不再需要包含这些成员变量的类型头文件，当前头文件变“干净”，这样其他文件在引用这个头文件时，依赖的类型变少，加快了编译速度。</p></li>
<li><p>接口与实现分离。</p>
<p>使用了 <strong>pimpl</strong> 惯用法之后，即使
<strong>Address</strong>、<strong>Date</strong> 或者
<strong>PersonImpl</strong>
类的实现细节发生了变化，对使用者都是透明的，对外的类（Address、Date、PersonImpl）声明仍然可以保持不变。例如我们可以增删改
PersonImpl 的成员变量和成员方法而保持 <strong>Person.h</strong>
文件内容不变；如果不使用 <strong>pimpl</strong> 惯用法，我们做不到不改变
<strong>Person.h</strong> 文件而增删改 <strong>PersonImpl </strong>
类的成员。</p></li>
</ul>
<h2><span id="确定你的public继承塑模出is-a关系">确定你的public继承塑模出is-a关系</span></h2>
<p>推荐文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wangshubo1989/article/details/48982465">浅析
is-a 关系</a></p>
<p>如果 class D 以 public 形式继承 class
B，你的意图就是告诉编译器：<strong>每一个类型为 D
的对象同时也是一个类型为 B 的对象，反之不成立。</strong></p>
<p>明确这个信息，就要求我们在进行类的设计和公开继承的时候弄清楚类和类之间的关系，不要牛头不对马嘴。</p>
<h2><span id="避免遮挡继承而来的名称">避免遮挡继承而来的名称</span></h2>
<p>在派生类中定义的名字会覆盖基类中的所有同名成员，不论参数或函数类型。</p>
<p>若要恢复基类中被隐藏的名字，可使用 <code>using</code>
声明或转调函数。</p>
<h2><span id="区分接口继承和实现继承">区分接口继承和实现继承</span></h2>
<p>作为一个 class 的设计者，有的时候你想要 派生类 只继承一个 成员函数 的
interface (声明)。有的时候你想要 派生类 既继承 interface（接口）也继承
implementation（实现），但你要允许它们替换他们继承到的
implementation。还有的时候你想要 派生类 继承一个函数的
interface（接口）和
implementation（实现），而不允许它们替换任何东西。</p>
<ul>
<li><strong>纯虚函数</strong>：只提供接口，派生类必须实现。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 纯虚函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// Circle 的具体实现</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Drawing Circle&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>非纯虚函数</strong>：提供接口和缺省实现，派生类可以选择实现或使用缺省。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Drawing a generic shape&quot;</span> &lt;&lt; std::endl; <span class="hljs-comment">// 缺省实现</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Drawing Circle&quot;</span> &lt;&lt; std::endl; <span class="hljs-comment">// 覆盖实现</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> : <span class="hljs-keyword">public</span> Shape &#123;<br>    <span class="hljs-comment">// 使用基类的缺省实现</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>非虚函数</strong>：提供接口和强制实现，派生类无法更改实现。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Drawing a shape&quot;</span> &lt;&lt; std::endl; <span class="hljs-comment">// 强制实现</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br>    <span class="hljs-comment">// 无法覆盖 draw 函数</span><br>    <span class="hljs-comment">// void draw() override; // 编译错误</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h2><span id="绝不要重定义一个通过继承得到的非虚函数易错">绝不要重定义一个通过继承得到的非虚函数（易错）</span></h2>
<p>结合前面介绍的条款，本条款其实很容易理解。</p>
<p>如果基类的函数是非虚函数，那我们绝不可以重定义（行为上我们规定不可以，但是语法上支持），这在设计上是不合理的。如果你要达到这个目的，你的设计应该是，如果我们的派生类要重写继承得到的函数，就应该让基类的该函数为非纯虚函数。</p>
<p>如果基类的函数是非虚函数，我们的派生类重定义就会造成一种错误，见如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;B::mf&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 重定义 B::mf</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;D::mf&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    D d;          <span class="hljs-comment">// 创建 D 的对象</span><br>    B* pB = &amp;d;  <span class="hljs-comment">// 将 D 的对象赋值给 B 的指针</span><br>    d.<span class="hljs-built_in">mf</span>();      <span class="hljs-comment">// 输出 &quot;D::mf&quot;</span><br>    pB-&gt;<span class="hljs-built_in">mf</span>();    <span class="hljs-comment">// 输出 &quot;B::mf&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>同一个对象 d 通过不同的类型调用相同的函数结果却不同，造成混乱。</p>
<p>如果在某些情况下，D 的对象通过 D 的指针调用 mf，而通过 B 的指针调用
mf
时，行为却不同。这可能导致代码的混淆和潜在的错误，因为同一个对象的行为依赖于指针的类型，而非对象的类型。</p>
<h2><span id="绝不重新定义继承而来的缺省参数值">绝不重新定义继承而来的缺省参数值</span></h2>
<p>在 C++
中，永远不要重定义继承来的默认参数值。这个建议的核心原因在于虚函数的动态绑定和默认参数值的静态绑定之间的矛盾。虚函数是动态绑定的，也就是说，<strong>在运行时</strong>根据对象的实际类型（动态类型）来决定具体调用哪个函数。然而，默认参数值是静态绑定的，<strong>在编译时</strong>根据对象的声明类型（静态类型）来决定参数的默认值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Red)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 默认颜色是红色</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Green)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 试图更改默认颜色为绿色</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，如果我们声明了一个 <code>Shape*</code>
类型的指针，并让它指向一个 <code>Rectangle</code> 对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">cpp复制代码Shape* pr = <span class="hljs-keyword">new</span> Rectangle;<br>pr-&gt;<span class="hljs-built_in">draw</span>(); <span class="hljs-comment">// 调用Rectangle::draw(Shape::Red)</span><br></code></pre></td></tr></table></figure>
<p>即使 <code>Rectangle::draw</code> 中的默认参数值是
<code>Green</code>，最终调用时默认参数仍是 <code>Shape</code> 中的
<code>Red</code>。这是因为默认参数值是静态绑定的，因此
<code>draw()</code> 的默认参数值是编译时确定的
<code>Shape::Red</code>。这可能导致难以预料的结果和代码混乱。</p>
<h2><span id="通过复合塑模出has-a">通过复合塑模出has-a</span></h2>
<p>之前我们讲 is-a，那是继承关系下，现在讲的 has-a
指的是包含关系，即一个类包含另外的类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PhoneNumber</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">private</span>:<br>	std::string name;        <span class="hljs-comment">// 合成成分物(composed object)</span><br>	Address address;         <span class="hljs-comment">// 同上</span><br>	PhoneNumber voiceNumber; <span class="hljs-comment">// 同上</span><br>	PhoneNumber faxNumber;   <span class="hljs-comment">// 同上</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h2><span id="明智而审慎地使用private继承">明智而审慎地使用private继承</span></h2>
<p>实际场景中，我还没有用过 private 继承方式，用的更多是 public
继承。</p>
<p>下面看看 private 继承方式有什么优点：</p>
<ul>
<li><strong>防止派生类被进一步继承</strong>：当使用 <code>private</code>
继承时，基类的所有成员在派生类中都变成私有的，派生类本身也无法进一步继承基类的接口。这种限制能确保继承关系不被公开延续，可以严格控制类的接口层次结构。</li>
<li><strong>「is-implemented-in-terms-of」关系</strong>：<code>private</code>
继承表示一种“以某种方式实现”的关系，而不是「is-a」的关系（即“某物是某种类型”）。通常我们会选择组合来实现这种关系（上一条款），但当基类含有受保护的接口，并且派生类希望访问这些接口时，<code>private</code>
继承提供了一种更加直接的方式，而不需要冗余的友元或接口方法。</li>
<li><strong>实现功能复用但不想暴露接口</strong>：当一个类希望复用另一个类的实现，但不想让外界知道这个类是从该基类继承来的。例如，在某些类设计中，希望使用基类的某些功能方法，但不希望客户端能够直接访问基类的接口。这时使用
<code>private</code>
继承，可以将基类的公共和受保护成员都作为派生类的私有成员，不会被派生类的用户直接访问。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Engine started.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Engine stopped.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> : <span class="hljs-keyword">private</span> Engine &#123;  <span class="hljs-comment">// 使用 private 继承</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">startCar</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">start</span>();  <span class="hljs-comment">// 使用 Engine 的方法，但不公开接口</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stopCar</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">stop</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2><span id="谨慎使用多继承">谨慎使用多继承</span></h2>
<ul>
<li>多继承比单继承更复杂。它能导致新的歧义问题和对虚拟继承的需要。</li>
<li>虚拟继承增加了大小和速度成本，以及初始化和赋值的复杂度。当<strong>虚拟基类没有数据时它是最适用的</strong>。</li>
<li>多继承有合理的用途。一种方案涉及组合从一个接口类的公有继承和从一个有助于实现的类的私有继承。</li>
</ul>
<h2><span id="了解隐式接口和编译期多态">了解隐式接口和编译期多态</span></h2>
<p>类和模板都支持接口和多态。</p>
<p>类的接口是显示的，多态则是通过 virtual
发生于<strong>运行期</strong>。</p>
<p>模板的接口是隐示的，多态则是模板的具现化和函数重载解析发生于<strong>编译期</strong>。</p>
<h2><span id="将与参数无关的代码抽离templates">将与参数无关的代码抽离templates</span></h2>
<p>模板（templates）在 C++
编程中具有巨大的优势，它们可以避免代码重复并让代码更简洁。但如果不注意，模板也可能导致代码膨胀，即产生重复的代码或数据，使得目标代码变得臃肿。</p>
<p>为避免这种膨胀问题，建议对代码进行“通用性与可变性分析”。这种分析类似于在非模板代码中避免重复的方式，即<strong>将通用的代码提取出来并共享，而将特定的代码单独保留</strong>。例如，当多个实例化的模板函数几乎相同（比如仅大小不同的矩阵操作），可以将大小参数化，并在基类中创建一个通用的函数供子类调用。</p>
<p>在设计上，<strong>有时也可以通过传递函数参数或使用类数据成员来替代非类型模板参数，从而减少膨胀的可能性</strong>。<strong>对于类型参数引起的膨胀，可让具有相同二进制表示的不同类型实例共享实现</strong>，从而减少重复代码的生成。</p>
<p>需要注意的是，这些优化需要权衡。使用 size-specific
优化代码可能导致更小的可执行文件，而代码复用可能带来缓存和工作集的优化效果。不同平台和数据集可能带来不同的性能影响，因此应根据实际情况测试并决定。</p>
<h2><span id="写了placementnew也要写placement-delete">写了placement
new也要写placement delete</span></h2>
<p>在 C++ 中<strong>编写自定义的 operator new 时，如果包含 placement
版本（带有自定义参数的版本），必须同时提供相应的 operator delete
placement
版本</strong>。否则，可能导致内存泄漏，因为在对象构造失败时，系统会调用
operator delete 来释放已分配的内存，但如果未定义与之匹配的 placement
operator
delete，则可能无法正确释放内存，进而导致“断续”内存泄漏的问题。</p>
<p>同时，在编写这些版本时，需小心避免覆盖掉普通版本的 operator new 和
operator delete。特别是当 placement
版本函数的签名（包括参数类型和数量）和普通版本相似时，容易产生意外覆盖。因此，<strong>定义
placement new 和 delete
时，确保参数列表和类型与常规版本不同，以防止不小心重载掉标准的内存分配和释放逻辑</strong>。</p>

      </div>
    </div>
    
      <script src='https://unpkg.com/mermaid@latest/dist/mermaid.min.js'></script>
      <script>
        if (window.mermaid) {
          mermaid.initialize({"startOnload":true});
        }
      </script>
    
  </article>
  <div class="post__foot">
    
      <div class="like-author">
  <input type="checkbox" id="likeCode" />
  <div class="author-face">
    <img height="100px"
         width="100px"
         id="front-face"
         alt="author face"
         src="/images/logo.png" />
    <img height="100px"
         width="100px"
         id="back-face"
         alt="like code"
         src="/images/pay.jpg" />
  </div>
  <div class="like-text">“给作者倒杯卡布奇诺”</div>
  <label for="likeCode" class="like-btn">
    <svg viewBox="0 0 1024 1024"
         width="20px"
         style="margin-right: 10px"
         height="20px">
      <path d="M466.88 908.96L113.824 563.296a270.08 270.08 0 0 1 0-387.392c108.8-106.56 284.896-106.56 393.696 0 1.504 1.472 2.976 2.944 4.448 4.48 1.472-1.536 2.944-3.008 4.448-4.48 108.8-106.56 284.896-106.56 393.696 0a269.952 269.952 0 0 1 34.016 347.072l-387.392 385.6a64 64 0 0 1-89.92 0.384z" p-id="13650" fill="#ee4242" />
    </svg>
    喜欢作者
  </label>
</div>

    
    <div class="post-nav">
  
    <a class="post-nav-item-left" href="/2024/10/31/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">
      <div class="text-align">
        <svg t="1670570876164"
             class="icon"
             viewBox="0 0 1024 1024"
             width="16"
             height="16">
          <path d="M384 512L731.733333 202.666667c17.066667-14.933333 19.2-42.666667 4.266667-59.733334-14.933333-17.066667-42.666667-19.2-59.733333-4.266666l-384 341.333333c-10.666667 8.533333-14.933333 19.2-14.933334 32s4.266667 23.466667 14.933334 32l384 341.333333c8.533333 6.4 19.2 10.666667 27.733333 10.666667 12.8 0 23.466667-4.266667 32-14.933333 14.933333-17.066667 14.933333-44.8-4.266667-59.733334L384 512z" p-id="14596" />
        </svg>
        <span class="text-small">上一篇</span>
      </div>
      <div>拷贝构造函数</div>
    </a>
  
  <div class="vhr"></div>
  
    <a class="post-nav-item-right" href="/2024/10/31/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/">
      <div class="text-align">
        <span class="text-small">下一篇</span>
        <svg t="1670570876164"
             class="icon"
             viewBox="0 0 1024 1024"
             transform="scale(-1,-1)"
             width="16"
             height="16">
          <path d="M384 512L731.733333 202.666667c17.066667-14.933333 19.2-42.666667 4.266667-59.733334-14.933333-17.066667-42.666667-19.2-59.733333-4.266666l-384 341.333333c-10.666667 8.533333-14.933333 19.2-14.933334 32s4.266667 23.466667 14.933334 32l384 341.333333c8.533333 6.4 19.2 10.666667 27.733333 10.666667 12.8 0 23.466667-4.266667 32-14.933333 14.933333-17.066667 14.933333-44.8-4.266667-59.733334L384 512z" p-id="14596" />
        </svg>
      </div>
      析构函数
    </a>
  
</div>

    
      <div class="related-post">
  <div class="related__head">
  <a href="/tags/CPP/" class="post-tag">#CPP</a>

</div>
  <div class="realated__body">
    
      <div class="null"><div class="null-item"><div class="null-title"><a href="\2024\09\13\C-中的友元类\" title="C++中的友元类" rel="bookmark">C++中的友元类</a></div></div><div class="null-item"><div class="null-title"><a href="\2024\12\02\C-中的多态\" title="C++中的多态" rel="bookmark">C++中的多态</a></div></div><div class="null-item"><div class="null-title"><a href="\2024\12\29\C-杂谈（一）\" title="C++杂谈（一）" rel="bookmark">C++杂谈（一）</a></div></div><div class="null-item"><div class="null-title"><a href="\2024\09\30\AOF持久化\" title="AOF持久化" rel="bookmark">AOF持久化</a></div></div><div class="null-item"><div class="null-title"><a href="\2024\09\01\Base64-和-MD5-的使用\" title="Base64 和 MD5 的使用" rel="bookmark">Base64 和 MD5 的使用</a></div></div></div>
    
  </div>
</div>

    
    
      <div id="gitalk-container"></div>
    
  </div>

    </div>
    <div class="foot">
  <div class="foot-inner">
    <div class="foot__head">
      
        <div class="foot-line">
          <div class="matts">我</div><div class="matts">们</div><div class="matts">应</div><div class="matts">该</div><div class="matts">坚</div><div class="matts">守</div><div class="matts">正</div><div class="matts">确</div><div class="matts">的</div><div class="matts">道</div><div class="matts">路</div><div class="matts">，</div><div class="matts">而</div><div class="matts">不</div><div class="matts">是</div><div class="matts">看</div><div class="matts">似</div><div class="matts">正</div><div class="matts">确</div><div class="matts">的</div><div class="matts">道</div><div class="matts">路</div><div class="matts">，</div><div class="matts">可</div><div class="matts">有</div><div class="matts">太</div><div class="matts">多</div><div class="matts">不</div><div class="matts">深</div><div class="matts">思</div><div class="matts">的</div><div class="matts">人</div><div class="matts">误</div><div class="matts">入</div><div class="matts">歧</div><div class="matts">途</div><div class="matts">了</div>
        </div>
      
    </div>
    <div class="foot__body">
      
        <div class="foot-item">
          <div class="foot-item__head">朋友</div>
          <div class="foot-item__body">
            
            


  
  
    <div class="foot-link-group">
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://zarathustrasay.github.io/">个人原创作品集</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://hasucn.me/i/O7OXkNEk">推荐机场（用多少买多少，不重置）</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://subingwen.cn">爱编程的大丙</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://dusays.com">杜老师说</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://echosorari.github.io/">清和</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://www.zzzzhi.com">祈星海</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://taifua.com/">太傅博客</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://noheart.cn">今今今生</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://paugram.com/">保罗的小宇宙</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://www.javatiku.cn/gitguide.html">笨鸟教程</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://draveness.me/">draveness</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://www.incredibuild.cn/blog">incredibuild</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://blog.tangly1024.com/">Tangly的学习笔记</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://www.kashiwabyte.tech">KashiwaのBlog</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://wiki.deepin.org/zh/home">deepin</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://colobu.com/">鸟窝</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://shuyi.tech/">陈树义的博客</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://www.freeconvert.com/zh">文件转换免费网站</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://yihui.org/cn/">yihui</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://wpfx.org/">wpfx网盘分享</a>
          </div>
        
      
    </div>
  
    <div class="foot-link-group">
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://arthurchiao.art/articles-zh/">ArthurChiao's Blog</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://tech.dewu.com/">得物技术</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="http://www.uml.org.cn/wenzhang/artindex.asp">火龙果</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://knowledge.zhaoweiguo.com/">计算机技术学习笔记</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="http://kaito-kidd.com/">kaito</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://www.xiaojingge.com">筱晶IT知识库</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://wuli.wiki/online/">wuli.wiki</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://www.luozhiwen.com/categories">skynet教程</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://www.cnblogs.com/yidengjiagou">分享Java+MySQL+Redis教程</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://hewei.blog.csdn.net/category_9866493.html">libhv网络库教程</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://cppguide.cn/">C++后端开发进阶教程</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-link+.svg" />
            <a class="foot-link" href="mailto:ydfox@foxmail.com?subject=申请https://xiaoyangst.github.io的友链">申请友链</a>
          </div>
        
      
        
        
      
        
        
      
        
        
      
        
        
      
        
        
      
        
        
      
        
        
      
        
        
      
    </div>
  


          </div>
        </div>
      
      
        <div class="foot-item">
          <div class="foot-item__head">账号</div>
          <div class="foot-item__body">
            


  
  
    <div class="foot-link-group">
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/logo-github.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://github.com/xiaoyangst">xiaoyangst</a>
          </div>
        
      
        
        
      
        
        
      
        
        
      
        
        
      
        
        
      
        
        
      
        
        
      
        
        
      
        
        
      
        
        
      
        
        
      
        
        
      
        
        
      
        
        
      
        
        
      
        
        
      
        
        
      
        
        
      
        
        
      
    </div>
  


          </div>
        </div>
      
      <div class="foot-item">
        <div class="foot-item__head">联系</div>
        <div class="foot-item__body">
          


  
  


        </div>
      </div>
    </div>
    <div class="copyright">
      <a href="https://xiaoyangst.github.io"></a> &nbsp;|&nbsp;由&nbsp;<a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>&nbsp;及&nbsp;
      <svg width="20" height="20" viewBox="0 0 725 725">
        <path fill-rule="evenodd" fill="rgb(221, 221, 221)" d="M145.870,236.632 L396.955,103.578 L431.292,419.44 L156.600,522.53 L145.870,236.632 Z" />
        <path fill-rule="evenodd" fill="rgb(159, 159, 159)" d="M396.955,103.578 L564.345,234.486 L611.558,513.469 L431.292,419.44 L396.955,103.578 Z" />
        <path fill-rule="evenodd" fill="rgb(0, 0, 0)" d="M431.292,419.44 L611.558,513.469 L358.327,595.18 L156.600,522.53 L431.292,419.44 Z" />
      </svg>
      <a target="_blank" rel="noopener" href="https://github.com/hooozen/hexo-theme-tranquility">致远</a>&nbsp;驱动
    </div>
  </div>
</div>

    
      <script src="https://unpkg.com/js-polyfills@0.1.43/es6.js"></script>
      <script id="MathJax-script"
              async
              src="https://www.unpkg.com/mathjax@3.2.2/es5/tex-mml-chtml.js"></script>
    
    
      <script src="/js/search.js"></script>
      <script>searchInitialize("/search.json")</script>
    
    <script src="/js/copy-code.js"></script>
    
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script type="text/javascript">
  const param = JSON.parse('{"enable":true,"owner":"xiaoyangst","admin":["xiaoyangst"],"repo":"comment","clientID":"Ov23lithQvbR0TMcvtc1","clientSecret":"c85019d9e22adb662b6de5b3321d1db1c2107615","distractionFreeMode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN"}')
  let title = location.pathname.substr(0, 50); 
  param.id = title
  const gitalk = new Gitalk(param)
  gitalk.render('gitalk-container')
</script>

  

  </body>
</html>

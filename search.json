[{"title":"要认识到TCP是一个可靠的，但并不绝对可靠的协议","url":"/2024/08/10/要认识到TCP是一个可靠的，但并不绝对可靠的协议/","content":"\n我们会误以为只要基于 TCP 编程，那么通信的数据必然能够到达对端主机，毕竟 TCP 是可靠的传输协议。然而， TCP 是处在传输层的协议，其可靠性只针对传输层，但是消息最终要达到应用层才算有价值。从传输层到应用层的消息会不会出现问题，可不由 TCP 来保证。\n\n数据流从应用程序 A 通过它所在主机的 TCP/IP 栈向下传输，经过几台中间路由器，通过应用程序 B 所在主机的TCP/IP 栈向上传输，最后抵达应用程序 B。一个 TCP 段离开应用程序 A 所在主机的 TCP 层时，会被封装到一个数据报中，传送给其对等实体主机。它所走的路由可能要经过很多路由器，但如下图所示，这些路由器都没有TCP层，它们只是转发了IP数据报。\n\n![TCP可靠之处.png](/images/2024/08/10/ba1a28b0-56c4-11ef-a3e6-51327ae276c7.png)\n\n当一个段抵达应用程序 B 所在主机的 TCP 层时，唯一可以确定的就是这个段已经到达了，但它可能损坏了，可能是重复的数据，可能是错序的，或者是由于其他一些原因无法接受的。注意，发送端 TCP 无法对这些抵达接收端 TCP的段做出任何保证。但接收端 TCP 要向发送端 TCP 确认，也就是说它 ACK 的数据以及在此数据之前到达的所有数据在 TCP 层都已经正确收到了，发送端 TCP 可以安全地删除这些数据的副本了。这并不意味着已经将数据传送，或者总是可以将数据传送给应用程序。比如，接收端主机可能在刚刚对数据进行了 ACK，但应用程序还没有将其读走之前，就崩溃了。\n\n## 故障模式\n\nTCP 是一个端对端协议，也就是说它自己要在对等实体之间提供可靠的传输机制。但是，认识到“端点”位于对等的 TCP层，而不是对等的应用程序中是非常重要的。要求进行端到端确认的应用程序必须自身提供此项功能。\n\n看看其他一些“常见的”故障模式。只要两个对等实体仍然连着，TCP 就能保证将数据按序无损坏地传送。只有连接中断时才会出现故障。什么类型的事件会造成这种中断呢?有三种情况可能引发这类问题：\n\n1. 永久或临时的网络中断\n2. 对等的应用程序崩溃\n3. 运行对等应用程序的主机崩溃\n\n## 网络中断\n\n路由器或骨干链路损毁，某人被本地以太网电缆绊倒，踢松了网线……很多原因都会造成网络的中断。在端点之外发生的损坏通常都是临时的，因为路由协议会发现问题，并使路由绕开出问题的节点。\n\n端点出现问题，通常没有备用的路径，所以问题会一直存在，直到端点修复为止。\n\n除非中间路由器发送一条ICMP报文，说明目的网络或主机不可达，否则应用程序及其 TCP/IP 栈都无法立即获知中断的发生。在这种情况下，发送端最终会超时，并重新发送所有未被确认的段。在发送端 TCP 放弃发送、丢弃连接并报告错误之前会一直持续这种操作。\n\n在传统 BSD 栈中，发送端 TCP 会在重传 12 次(大约 9 分钟)之后放弃。如果读操作被挂起，会返回一条错误状况，并将 errno 置为 ETIMEDOUT。如果没有挂起的读操作，接下来的写操作就会失败，根据信号是忽略还是捕获，写操作失败时会携带一个 SIGPIPE 信号，或 EPIPE 错误。\n\n如果某个中间路由器无法转发包含段的 IP 数据报，它会向源端主机发送一个 ICMP 报文，说明目的网络或主机不可达。在这种情况下，有些实现会返回 ENETUNREACH 或 EHOSTUNREACH 作为错误原因。\n\n## 对等实体崩溃\n\n接下来，我们来看看如果对等应用程序崩溃或者终止，会发生什么情况。首先要意识到从应用程序的角度来看，对等实体崩溃与对等实体调用 c1ose 及 exit 是无法区分的。**在这两种情况下，对等实体的 TCP 都会向我们的 TCP 发送一个 FIN**。FIN 作为 EOF 使用，表示发送它的那一端已经没有数据发送了。这并不（一定）表示发送 FIN 的这一端已经退出了，甚至无法说明它不愿意接收更多数据。\n\n## 对等实体的主机崩溃\n\n要研究的最后一种故障模式是对等实体主机的崩溃。这种故障模式与对等实体崩溃不同，因为对等实体的 TCP 无法通过 FIN 来通知我们的应用程序，其对等实体已经不在运行了。\n\n在对等实体主机重启之前，这个错误看起来和网络故障一样：对等实体的TCP不再应答了。和网络故障的情况一样，我们的应用程序 TCP 会持续重传未经确认的段。最终，如果对等实体主机没有重启，它就会放弃并向应用程序返回一条 ETIMEDOUT 错误。\n\n如果在我们的 TCP 放弃并丢弃连接之前，对等实体主机就重启了，会发生什么情况呢？在这种情况下，会有重传的段到达对等实体刚刚重启的主机，而这台主机并没有连接记录。在这种情况下，TCP 技术规范要求接收端主机向发送端主机回送一个 RST。这样发送端主机才会丢弃连接，应用程序才会收到一条 ECONNRESET 错误(如果它有挂起的读操作的话)，或者会在下一条写操作时得到一个 SIGPIPE 信号或 EPIPE 错误。\n\n---\n\n⭐️内容取自译者陈涓、赵振平《TCP/IP高效编程：改善网络程序的44个技巧》，仅从中取出个人以为需要纪录的内容。不追求内容的完整性，却也不会丢失所记内容的逻辑性。如果需要了解细致，建议读原书。","tags":["网络编程"],"categories":["technology"]},{"title":"记住：TCP是一种流协议","url":"/2024/08/10/记住：TCP是一种流协议/","content":"\nTCP 是一种流协议，这就意味着数据是以字节流的形式传递给接收者的，**没有固有的”报文”或”报文边界”的概念**。从这方面来说，读取 TCP 数据就像从串行端口读取数据一样——无法预先得知在一次指定的读调用中会返回多少字节。\n\n## 流协议存在的问题\n\n发送的数据没有边界，接收方可能对接收到的数据存在多读或少读的问题。为了说明这一点，我们假设在主机 A 和主机 B 的应用程序之间有一条 TCP 连接，主机 A 上的应用程序向主机 B 发送一条报文。进一步假设主机 A 有两条报文要发送，并两次调用 send 来发送，每条报文调用一次。很自然就会想到从主机 A 向主机 B 发送的两条报文是作为两个独立实体，在各自的分组中发送的。\n\n![主机A和主机B通信.png](/images/2024/08/10/b584bcb0-56b1-11ef-9b76-6d6092cc6dd4.png)\n\n但不幸的是，实际的数据传输过程很可能不会遵循这个模型。\n\n主机A上的应用程序会调用send，我们假设这条写操作的数据被封装在一个分组中传送给B。**实际上，send通常只是将数据复制到主机A的TCP/IP栈中，就返回了。由TCP来决定（如果有的话）需要立即发送多少数据**。做这种决定的过程很复杂，取决于很多因素，比如发送窗口（当时主机B能够接收的数据量），拥塞窗口（对网络拥塞的估计），路径上的最大传输单元（沿着主机A和B之间的网络路径一次可以传输的最大数据量），以及连接的输出队列中有多少数据。\n\n下图只显示了主机A的TCP封装数据时可能使用的诸多方法中的4种\n\n![数据分割.png](/images/2024/08/10/44a4f210-56b3-11ef-9b76-6d6092cc6dd4.png)\n![注解M1和M2.png](/images/2024/08/10/487b0050-56b3-11ef-9b76-6d6092cc6dd4.png)\n\n现在，我们从主机 B 应用程序的角度来看这种情形。总的来说，主机 B 应用程序任意一次调用 recv 时，都不会对 TCP 发送给它的数据量做任何假设。比如，当主机 B 应用程序读取第一条报文时，可能会出现下列 4 种结果：\n\n1. 没有数据可读，应用程序阻塞，或者 recv 返回一条指示说明没有数据可读。到底会发生什么情况取决于套接字是否标识为阻塞，以及主机B的操作系统为系统调用 recv 指定了什么样的语义\n2. 应用程序获取了报文 M1 中的部分而不是全部数据。比如，发送端TCP像上图 D 那样对数据进行分组就会发生这种情况\n3. 用程序获取了报文 M1 中所有的数据，除此之外没有任何其他内容。如果像上图 A 那样对数据分组就会发生这种情况\n4. 应用程序获取了报文M1的所有数据，以及报文M2的部分或全部数据。如果像上图 B 或上图 C 那样对数据进行分组就会发生这种情况\n\n注：实际可能的结果不止4种，但我们忽略了出错和EOF之类的结果。我们还假设应用程序读取了所有可读的数据。\n\nTCP 是一个流协议（stream protocol），**尽管数据是以 IP 分组的形式传输的，但分组中的数据量与 send 调用中传送给 TCP 多少数据并没有直接关系**。而且，接收程序也没有什么可靠的方法可以判断数据是如何分组的，因为在两次 recv 调用之间可能会有多个分组到来。\n\n**TCP会记录它发送了多少字节，以及确认的字节，但它不会记录这些字节是如何分组的**。实际上，有些实现在重传丢失分组的时候传送的数据可能比原来的多一些或少一些。\n\n## 解决方法\n\n- 固定报文长度\n- 记录结束标记来分割记录，要注意在数据中如果出现结束标记，需要转义以表明此为数据而非结束标记\n- 每条报文前面加一个首部，首部至少记录有实际数据的长度\n\n![自实现协议.png](/images/2024/08/10/baf4a4d0-56b1-11ef-9b76-6d6092cc6dd4.png)\n\n---\n\n⭐️内容取自译者陈涓、赵振平《TCP/IP高效编程：改善网络程序的44个技巧》，仅从中取出个人以为需要纪录的内容。不追求内容的完整性，却也不会丢失所记内容的逻辑性。如果需要了解细致，建议读原书。","tags":["网络编程"],"categories":["technology"]},{"title":"基本套接字 API 的回顾","url":"/2024/08/10/基本套接字-API-的回顾/","content":"\n![客户端和服务端的通信.png](/images/2024/08/10/06fe8b80-56b1-11ef-9b76-6d6092cc6dd4.png)\n\n基本套接字 API 概览\n\n`socket()`: 创建一个套接字\n\n`bind()`: 绑定套接字到一个地址和端口\n\n`listen()`: 监听端口上的连接请求（用于服务器）\n\n`accept()`: 接受连接请求（用于服务器）\n\n`connect()`: 连接到一个远程地址（用于客户端）\n\n`send()`: 发送数据\n\n`recv()`: 接收数据\n\n`close()`: 关闭套接字\n\n注：在 UNIX 中，可以像文件描述符那样，直接用套接字描述符来调用 read 和 write。但正如我们曾经提到的那样，Windows 并没有用套接字语法重载这些系统调用，因此，只能用 recv 和 send 来代替。除了包含一个额外参数，这些调用与 read 和 write 是一样的。如果你用的UDP的话，那么你应该使用 recvform 和 sendto。\n\n## socket\n\n功能：返回一个文件描述符，它是一个用于标识新创建的套接字的引用\n\n```c++\n#include <sys/types.h>         \n#include <sys/socket.h>\n\nint socket(int domain, int type, int protocol);\n\n/*\n  int socket_fd = socket(AF_INET, SOCK_STREAM, 0);\n  if (socket_fd < 0) {\n    perror(\"socket error\");\n    return -1;\n  }\n  */\n```\n\n`domain`（指定通信的协议族） 核心参数:：\n\n- AF_LOCAL: 本地进程间通信\n- AF_INET（常用）: 远端基于IPV4进程间通信\n- AF_INET6: 远端基于IPV6进程间通信\n\n`type`（指定套接字的类型） 核心参数：\n\n- SOCK_STREA（常用）: 流套接字，提供面向连接的稳定数据传输（TCP）\n- SOCK_DGRAM: 数据报套接字，提供无连接的数据传输（UDP）\n- SOCK_RAW: 原始套接字，提供对底层协议的直接访问\n\n`protocol`（指定要使用的协议） 核心参数：通常为 0，表示自动选择合适的协议。对于 AF_INET 和 SOCK_STREAM ，0 通常表示 TCP，对于 AF_INET 和 SOCK_DGRA，0 通常表示 UDP\n\n## bind\n\n功能：绑定套接字到一个地址和端口\n\n```c++\n#include <sys/types.h>         \n#include <sys/socket.h>\n\nint bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);\n\n/*\n  struct sockaddr_in server_addr;\n  memset(&server_addr, 0, sizeof(server_addr));\n  server_addr.sin_family = AF_INET;\n  server_addr.sin_port = htons(port);\n  server_addr.sin_addr.s_addr = inet_addr(ip.c_str());\n  \n  int ret = bind(socket_fd, (struct sockaddr *)&server_addr, sizeof(server_addr));\n  if (ret < 0) {\n    perror(\"bind error\");\n    return -1;\n  }\n*/\n```\n\nsockfd: 就是前面 socket 创建成功的返回值\n\naddr: 结构体 sockaddr，用于**存放服务端的协议族、端口和地址信息**。客户端的 connect 函数和服务端的 bind 函数需要这个结构体\n\naddrlen: 是参数 addr 的长度，用 sizeof 计算 \n\n---\n\n```c++\nstruct sockaddr {\n    unsigned short sa_family;    // 协议族 (AF_INET, AF_INET6, etc.)\n    char sa_data[14];            // 地址数据 (协议相关)\n};\n```\n\n存放协议族、端口和地址信息。客户端的 connect 函数和服务端的 bind 函数需要这个结构体。\n\nsockaddr 结构体是为了统一地址结构的表示方法，统一接口函数，但是这个结构体并不方便使用，因此定义了等价的 sockaddr_in 结构体，它的大小和 sockaddr 结构体相同，可以强制转换成 sockaddr。\n\n```c++\nstruct sockaddr_in {\n    short int sin_family;         // 协议族 (AF_INET)\n    unsigned short int sin_port;  // 16位端口号 ，大端序。用htons(整数的端口)转换。\n    struct in_addr sin_addr;      // IP地址\n    unsigned char sin_zero[8];    // 填充，使得结构体大小与sockaddr一致（不用管）\n};\n \nstruct in_addr {\n    unsigned long s_addr;         // 32位的IP地址，大端序 (使用网络字节序)\n};\n```\n\n因此，在实际的网络编程中，先定义 sockaddr_in结构体把相关信息存储之后，再强制转换成 sockaddr，毕竟提供的API接受的类型是 sockaddr。\n\n## listen\n\n功能：将一个套接字设置为被动模式，以便接收来自远程主机的连接请求\n\n```c++\n#include <sys/types.h>          \n#include <sys/socket.h>\n\nint listen(int sockfd, int backlog);\n\n/*\n  #define LISTEN_NUM 10\n  \n  ret = listen(socket_fd, LISTEN_NUM);\n  if (ret < 0) {\n    perror(\"listen error\");\n    return -1;\n  }\n*/\n```\n\n`sockfd`: 就是前面 socket 创建成功的返回值，而且必须 bind 之后的 sockfd\n\n`backlog`: 会影响到半连接队列和全连接队列的大小\n\n![全连接半连接队列.png](/images/2024/08/10/ff2c2250-56b0-11ef-9b76-6d6092cc6dd4.png)\n\n从上面这种图可以看到，listen 接受到客户端连接请求之后，开始进行三次握手。如果第一次握手成功，连接被加入到半连接队列；如果第三次握手也成功，连接被加入到全连接队列。三次握手成功，加入到全连接队列的连接可以用于后续通信，而 accept 实际上就是去全连接队列里面去取这些连接出来用于通信的。\n\n那么多大的 backlog 是合适的？\n\n- 如果你的接口处理连接的速度要求非常高，或者做压力测试，很有必要调高这个值\n- 如果业务接口本身性能不好，accept 取走已连接的速度较慢，那么把 backlog 调的再大也没有用，只会增加连接失败的可能性\n\n关于 backlog 传递的值究竟会为多少（你传递的值未必就会成为实际的 backlog 最终值），需要去看内核的实现，详细可见此文：[三次握手背后的秘密：半连接队列和全连接队列](https://www.yuque.com/xiaoyang-wyxle/gdb3m3/xntqpx4a75l074qg)\n\n## accept\n\n功能： 系统调用 sockfd 的全连接队列中的第一个连接请求，创建一个新的连接套接字，并返回一个新的文件描述符\n\n```c++\n#include <sys/types.h>  \n#include <sys/socket.h>\n\nint accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);\nint accept4(int sockfd, struct sockaddr *addr, socklen_t *addrlen, int flags);\n\n/*\n  struct sockaddr_in client_addr;\n  socklen_t client_len = sizeof(client_addr);\n  int listen_fd = accept(socket_fd, (struct sockaddr *)&client_addr, &client_len);\n  if (listen_fd < 0) {\n    perror(\"accept error\");\n    return -1;\n  }\n*/\n```\n\n`sockfd`: 就是前面 socket 创建成功的返回值，而且必须 listen 之后的 sockfd\n\n`addr`: 指向 `sockaddr` 结构体的指针，用于**存储客户端的地址信息**（新连接的对等实体地址）。如果不需要客户端地址，可以传递 `NULL`。\n\n`flags` (accept4 专用): 额外的标志，可以是以下值的按位或组合：\n\n- SOCK_NONBLOCK: 使返回的文件描述符变为非阻塞模式\n- SOCK_CLOEXEC: 在执行 exec 系列函数时自动关闭文件描述符\n\n也就是，我们后续服务器和客户端实际通信的套接字是 accept 函数返回的文件描述符。此前的 socket 创建并返回的文件描述符仅仅用于添加相关信息并和客户端成功建立连接，并不用于后续通信，却是后续通信不可或缺的基础。\n\n注：这里的 addr 参数是新建的客户端的结构体，而非之前创建用于 bind 参数的 addr 参数（它属于服务端）。\n\n## recv\n\n功能：用于从套接字接收消息\n\n```c++\n#include <sys/types.h>\n#include <sys/socket.h>\n\nssize_t recv(int sockfd, void *buf, size_t len, int flags);\n\n/*\n  char buf[1024] = {0};\n  ssize_t bytes_read = recv(listen_fd, buf, sizeof(buf) - 1,0);\n  if (bytes_read < 0) {\n    perror(\"read error\");\n  } else if (bytes_read == 0) {\n    std::cout << \"Client disconnected.\" << std::endl;\n  } else {\n    buf[bytes_read] = '\\0'; \n    std::cout << \"Received data: \" << buf << std::endl;\n  }\n*/\n```\n\n`sockfd`: 一个有效的套接字文件描述符，从中接收数据。就是之前调用 accept 之后返回的套接字文件描述符\n\n`buf`: 一个指向接收数据的缓冲区的指针\n\n`len`: 缓冲区的长度，即最多接收的字节数\n\n`flags`: 控制接收操作的标志。常用的标志包括：\n\n- 0: 默认标志，无特殊行为。\n- MSG_DONTWAIT: 使操作非阻塞\n- MSG_PEEK: 查看数据但不将其从缓冲区中移除\n- MSG_WAITALL: 等待所有请求的数据被接收\n\n## send\n\n功能：用于从套接字发送消息\n\n```c++\n#include <sys/types.h>\n#include <sys/socket.h>\n\nssize_t send(int sockfd, const void *buf, size_t len, int flags);\n\n/*\n  const char *message = \"Hello, client!\";\n  ssize_t bytes_sent = send(listen_fd, message, std::strlen(message), 0);\n  if (bytes_sent < 0) {\n    std::cerr << \"Error sending message\" << std::endl;\n  } else {\n    std::cout << \"Sent \" << bytes_sent << \" bytes to client\" << std::endl;\n  }\n*/\n```\n\n`sockfd`: 一个有效的套接字文件描述符，通过该套接字发送数据\n\n`buf`: 指向包含待发送数据的缓冲区的指针\n\n`len`: 缓冲区中待发送数据的长度\n\n`flags`: 控制发送操作的标志。常用的标志包括：\n\n- 0: 默认标志，无特殊行为\n- MSG_DONTWAIT: 使操作非阻塞\n- MSG_OOB: 发送带外数据\n- MSG_NOSIGNAL: 阻止发送 SIGPIPE 信号\n\n## connect\n\n功能：用于连接服务端\n\n```c++\n#include <sys/types.h>          /* See NOTES */\n#include <sys/socket.h>\n\n int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);\n\n/*\n    // 配置服务器地址\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(12345); // 服务器端口号\n    server_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); // 服务器地址\n\n    // 连接到服务器\n    if (connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {\n        perror(\"connect\");\n        close(sockfd);\n        exit(EXIT_FAILURE);\n    }\n*/\n```\n\n## 阻塞与非阻塞\n\n阻塞：在进程/线程中，发起一个调用时，**在调用返回之前，进程/线程会阻塞等待**，等待中的进程/线程会让出CPU\n\n非阻塞：在进程/线程中，发起一个调用时，**会立即返回**\n\n前面介绍的 API 中，会阻塞的四个函数有 connect()、accept()、send()、recv()\n\n阻塞IO与非阻塞IO的应用场景：\n\n- 在穿透的网络服务端程序中（每连接每线程/进程），采用阻塞IO\n- 在IO复用的模型中，事件循环（select、poll、epoll）不能被阻塞在任何环节，应该采用非阻塞IO\n\n## 实战代码\n\n服务端\n\n```c++\n#include <iostream>\n#include <cstring>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <unistd.h>\n\n#define LISTEN_NUM 10\n\nint main(int argc, char *argv[]) {\n  if (argc != 3) {\n    std::cout << \"./server 172.17.32.175 8888\" << std::endl;\n    return -1;\n  }\n\n  std::string ip = argv[1];\n  int port = std::stoi(argv[2]);\n\n  int socket_fd = socket(AF_INET, SOCK_STREAM, 0);\n  if (socket_fd < 0) {\n    perror(\"socket error\");\n    return -1;\n  }\n\n  struct sockaddr_in server_addr;\n  memset(&server_addr, 0, sizeof(server_addr));\n  server_addr.sin_family = AF_INET;\n  server_addr.sin_port = htons(port);\n  server_addr.sin_addr.s_addr = inet_addr(ip.c_str());\n\n  int ret = bind(socket_fd, (struct sockaddr *)&server_addr, sizeof(server_addr));\n  if (ret < 0) {\n    perror(\"bind error\");\n    return -1;\n  }\n\n  ret = listen(socket_fd, LISTEN_NUM);\n  if (ret < 0) {\n    perror(\"listen error\");\n    return -1;\n  }\n\n  struct sockaddr_in client_addr;\n  socklen_t client_len = sizeof(client_addr);\n  int listen_fd = accept(socket_fd, (struct sockaddr *)&client_addr, &client_len);\n  if (listen_fd < 0) {\n    perror(\"accept error\");\n    return -1;\n  }\n\n  char buf[1024] = {0};\n  ssize_t bytes_read = recv(listen_fd, buf, sizeof(buf) - 1,0);\n  if (bytes_read < 0) {\n    perror(\"read error\");\n  } else if (bytes_read == 0) {\n    std::cout << \"Client disconnected.\" << std::endl;\n  } else {\n    buf[bytes_read] = '\\0';\n    std::cout << \"Received data: \" << buf << std::endl;\n  }\n\n  const char *message = \"Hello, client!\";\n  ssize_t bytes_sent = send(listen_fd, message, std::strlen(message), 0);\n  if (bytes_sent < 0) {\n    perror(\"send error\");\n    return -1;\n  } else {\n    std::cout << \"Sent message: \" << message << std::endl;\n  }\n\n\n  close(listen_fd);\n  close(socket_fd);\n\n  return 0;\n}\n```\n\n客户端\n\n```c++\n#include <iostream>\n#include <cstring>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <unistd.h>\n\nint main(int argc, char *argv[]) {\n  if (argc != 3) {\n    std::cout << \"Usage: \" << argv[0] << \" <server_ip> <server_port> <message>\" << std::endl;\n    return -1;\n  }\n\n  std::string server_ip = argv[1];\n  int server_port = std::stoi(argv[2]);\n  std::string message;\n  std::cout<<\"input message : \";\n  std::cin>>message;\n\n  int sock_fd = socket(AF_INET, SOCK_STREAM, 0);\n  if (sock_fd < 0) {\n    perror(\"socket error\");\n    return -1;\n  }\n\n  struct sockaddr_in server_addr;\n  memset(&server_addr, 0, sizeof(server_addr));\n  server_addr.sin_family = AF_INET;\n  server_addr.sin_port = htons(server_port);\n  inet_pton(AF_INET, server_ip.c_str(), &server_addr.sin_addr);\n\n  int ret = connect(sock_fd, (struct sockaddr *)&server_addr, sizeof(server_addr));\n  if (ret < 0) {\n    perror(\"connect error\");\n    return -1;\n  }\n\n  ssize_t bytes_sent = send(sock_fd, message.c_str(), message.size(), 0);\n  if (bytes_sent < 0) {\n    perror(\"send error\");\n    return -1;\n  } else {\n    std::cout << \"Sent message: \" << message << std::endl;\n  }\n\n  char buf[1024] = {0};\n  ssize_t bytes_read = recv(sock_fd, buf, sizeof(buf) - 1,0);\n  if (bytes_read < 0) {\n    perror(\"read error\");\n  } else if (bytes_read == 0) {\n    std::cout << \"Server disconnected.\" << std::endl;\n  } else {\n    buf[bytes_read] = '\\0';\n    std::cout << \"Received data: \" << buf << std::endl;\n  }\n\n  close(sock_fd);\n  return 0;\n}\n```\n\n通信效果：\n\n![实战TCP通信.png](/images/2024/08/10/ef5a9aa0-56b0-11ef-9b76-6d6092cc6dd4.png)\n\n---\n\n⭐️内容取自译者陈涓、赵振平《TCP/IP高效编程：改善网络程序的44个技巧》，仅从中取出个人以为需要纪录的内容。不追求内容的完整性，却也不会丢失所记内容的逻辑性。如果需要了解细致，建议读原书。","tags":["网络编程"],"categories":["technology"]},{"title":"记住：TCP不是轮询的","url":"/2024/08/10/记住：TCP不是轮询的/","content":"\nTCP 无法将连接的丢失立即通知应用程序，我们下面就探讨为什么 TCP 不提供这种通知机制，不这么做的优点和缺点，以及应用程序程序员必须完成哪些工作以检测连接的丢失。\n\n## 为什么不设计连接丢失即时通知机制\n\n显然，对可用网络带宽的耗费是 TCP 不提供连接丢失即时通知的原因之一。大部分应用程序都不需要即时通知，因此**不应该为之付出降低带宽的代价**。如果应用程序确实需要及时获得对等实体不可达的信息，可以像稍后讨论的那样，实现自己的丢失发现机制。比方说 HTTP 只支持客户端向服务端主动通信，服务端却不可以主动给客户端推送消息。如果非要服务端主动和客户端通信，就可以利用轮询机制，即让客户端定时发送消息给服务端，服务端再给客户端回消息来营造服务端主动和客户端通信的假象。尽管轮询机制是常见的思想，但是非常容易被替代，因为对资源有太多不必要的消耗，这就是为什么 WebSocket 有出现的必要。\n\n但 TCP 不提供连接丢失即时通知最重要的原因与其主要设计目标之一有关：出现网络故障时维护通信的能力。国防部赞助的一项研究要提供一种即使在发生战争或自然灾害这种严重网络损坏的情况下，也能维护可靠网络通信的网络协议，TCP就是这种研究的产物。**通常，网络故障只是暂时的，有时路由器会为连接找到另一条路径。TCP允许临时的连接丢失，但通常可以在终端应用程序还没意识到的情况下处理好这些网络中断**。\n\n强制应用程序去监视网络的缺点在于必须将代码构建到每个（需要它的）应用程序中去，如果实现上考虑不周，就会浪费带宽，还可能产生一些对网络及其他用户有不利影响的行为。但也有人持不同的意见，认为应该在应用程序去监视网络，就可以对其进行精细调整以适应应用程序的需要，并尽可能地与应用程序协议无缝结合。\n\n## 如何在应用层实现连接丢失即时通知机制\n\n这里不介绍POSIX套接字提供的保持活跃机制，而是着重介绍心跳信号机制。书里面介绍两种实现方式：\n\n- `规定通信格式`来确定客户端的存活，即只需要为心跳报文增加一个报文类型\n  1. **定义心跳消息类型**：在协议中定义一个特殊的消息类型，例如 `HEARTBEAT`\n  2. **定期发送心跳消息**：客户端和服务器定期发送心跳消息以表示连接仍然活跃\n  3. **接收并处理心跳消息**：接收方收到心跳消息后，更新最后一次接收到心跳消息的时间\n- `没有规定通信格式`，那么通信的数据中就无法找到客户端发送的消息，心跳信号机制也就失效。对于没有规定通信格式的这种，启动一个独立的连接来发送和接受心跳信号\n  1. **建立心跳连接**：客户端和服务器建立一个独立的连接专门用于心跳信号\n  2. **定期发送心跳消息**：在心跳连接上定期发送心跳消息\n  3. **接收并处理心跳消息**：接收方在心跳连接上接收并处理心跳消息\n---\n⭐️内容取自译者陈涓、赵振平《TCP/IP高效编程：改善网络程序的44个技巧》，仅从中取出个人以为需要纪录的内容。不追求内容的完整性，却也不会丢失所记内容的逻辑性。如果需要了解细致，建议读原书。","tags":["网络编程"],"categories":["technology"]},{"title":"理解面向连接和无连接协议之间的区别","url":"/2024/08/10/理解面向连接和无连接协议之间的区别/","content":"\n**面向连接和无连接指的都是协议**。也就是说，这些术语指的**并不是物理介质本身**，而是用来**说明如何在物理介质上传输数据的**。面向连接和无连接协议可以，而且通常也确实会共享同一条物理介质。\n\n如果两者的区别与承载数据的物理介质无关，又和什么有关呢？它们的本质区别在于，对无连接协议来说，每个分组的处理都独立于所有其他分组，而对面向连接的协议来说，协议实现则维护了与后继分组有关的状态信息。\n\n请看如下表格：\n\n| 面向连接/无连接 | 具体协议 | 可靠/不可靠 |\n| --------------- | :------: | ----------- |\n| 面向连接        |   TCP    | 可靠传输    |\n| 面向无连接      |   UDP    | 不可靠传输  |\n\n**无连接协议**中的分组被称为数据报（datagram），每个分组都是独立寻址，并由应用程序发送的。从协议的角度来看，**每个数据报都是一个独立的实体，与在两个相同的对等实体之间传送的任何其他数据报都没有关系**，这就意味着协议很可能是不可靠的。也就是说，网络会尽最大努力传送每一个数据报，但并不保证数据报不丢失、不延迟或者不错序传输。\n\n另一方面，**面向连接的协议**则**维护了分组之间的状态**，使用这种协议的应用程序通常都会进行长期的对话。记住这些状态，协议就可以提供可靠的传输。比如，发送端可以记住哪些数据已经发送出去了但还未被确认，以及数据是什么时候发送的。如果在某段时间间隔内没有收到确认，发送端可以重传数据。接收端可以记住已经收到了哪些数据，并将重复的数据丢弃。如果分组不是按序到达的，接收端可以将其保存下来，直到逻辑上先于它的分组到达为止。\n\n使用无连接协议就像寄信，而使用面向连接的协议就像打电话。前者不管对方是否已经和自己连接成功，直接把数据发送出去，也就不关心数据是否真的到达了。后者和对方发送数据之前务必保证连接已经成功，通过三次握手来确保双方发送和接受能力以及连接成功，后续的数据发送也有相应的防丢失机制，比方说重传机制等。\n\n---\n\n⭐️内容取自译者陈涓、赵振平《TCP/IP高效编程：改善网络程序的44个技巧》，仅从中取出个人以为需要纪录的内容。不追求内容的完整性，却也不会丢失所记内容的逻辑性。如果需要了解细致，建议读原书。","tags":["网络编程"],"categories":["technology"]},{"title":"提防对等实体的不友好动作","url":"/2024/08/10/提防对等实体的不友好动作/","content":"\n亦如在程序中接受用户的输入前，要对用户的输入进行“安全检测”，以防止恶意输入破坏应用程序的正常运行。可见，防御性编程在编码中是必备的意识，网络编程中也要考虑各种概率看似很小的事件，做出相应的处理动作。\n\n## 检测客户端的终止\n\n![检测客户端的终止.png](/images/2024/08/10/ddfaa030-56af-11ef-9b76-6d6092cc6dd4.png)\n\n这段代码中，如果客户端发送字符串\"quit\"代表客户端要退出，服务器这边就可以正常和客户端断开连接。如果客户端发生故障或者异常导致没有发生字符串\"quit\"，那么服务器这边就会频繁执行最后一条分支语句。\n\n可以只在读操作上设置一个定时器，如果客户端在某段时间区间内没有发出请求，服务器就假定客户端已经不存在了。很多 FTP 服务器就是这么做的：如果客户端在某段时间区间内没有发送任何请求，服务器就放弃连接。用一个显式定时器或者像心跳实例那样使用 select 定时器，就可以很方便地解决这个问题。\n\n## 检测无效输入\n\n即客户端恶意输入无效字符，服务器如果没有进行“拦截检测”，可能会造成程序崩溃。崩溃最常见的两种原因是缓冲器溢出和指针丢失。\n\n`缓冲区溢出`是由于写入的数据超过了缓冲区的大小，从而覆盖了相邻的内存区域。为了防止缓冲区溢出，可以采取以下措施：\n\n1. **使用安全函数**：使用库中提供的安全函数，例如 `strncpy` 代替 `strcpy`，`snprintf` 代替 `sprintf` 等\n2. **手动检查长度**：在写入数据之前，手动检查输入数据的长度是否超过了缓冲区的大小\n\n`指针丢失`通常是由于未正确初始化指针或错误释放内存导致的。为了防止指针丢失，可以采取以下措施：\n\n1. **初始化指针**：确保所有指针在使用之前都被初始化\n2. **检查指针有效性**：在使用指针之前，检查指针是否为空（`nullptr`）\n3. **正确管理内存**：C++11 提供的智能指针\n---\n⭐️内容取自译者陈涓、赵振平《TCP/IP高效编程：改善网络程序的44个技巧》，仅从中取出个人以为需要纪录的内容。不追求内容的完整性，却也不会丢失所记内容的逻辑性。如果需要了解细致，建议读原书。","tags":["网络编程"],"categories":["technology"]},{"title":"实践论","url":"/2024/08/09/实践论/","content":"\n再多的想法，还只是停留在认识阶段，而认识终归是要落实的，如果只是认识而不去实践，永远不可能和真理沾边。人类的理性是有限的，没人能够绝对保证自己认识的准确性，一定要把自己的认识投身于实践中去，在实践中证明认识的准确性，在实践中修正认识的不足性。真正长久的智慧不可能来源于一成不变的理论，而是来源于持续迭代并且保持学习的理论。\n\n> 判定认识或理论之是否真理，不是依主观上觉得如何而定，而是依客观上社会实践的结果如何而定。真理的标准只能是社会的实践。\n\n经验可分为直接经验和间接经验，如书本中获取的经验就属于间接经验，结合书本中的知识去实践得到的经验是直接经验。我们不能说间接经验一定是认识的低级阶段，首先间接经验也来源于直接经验，其次历史也不断从直接经验中迭代间接经验，从间接经验中依旧能获取高阶的认识，甚至是绝大部分获取高阶认识的来源，这同样源于间接经验比直接经验更容易获得并掌握。然而，回顾间接经验之所以能作为高阶认识的来源，恰恰就是在历史场合中接受直接经验的更正，如果我们依旧想要后面的人能够从间接经验中获取更高的认识，那么通过实践获得直接经验并丰富或修正间接经验依旧是必不可少的。前面这种为后人考虑的说法确实伟大，但从个体角度来看，这同样是适用的。常言到“尽信书不如无书”，恰恰就是对人类理性的尊重，并且强调要用直接经验检验间接检验。\n\n> 我们的实践证明：感觉到了的东西，我们不能立刻理解它，只有理解了的东西才更深刻地感觉它。感觉只解决现象问题，理论才解决本质问题。这些问题的解决，一点也不能离开实践。无论何人要认识什么事物，除了同那个事物接触，即生活于（实践于）那个事物的环境中，是没有法子解决的。不能在封建社会就预先认识资本主义社会的规律，因为资本主义还未出现，还无这种实践。\n\n拥有足够多大的信息，理性才能充分发挥。这叫好像一堆拼图碎片，如果能够尽可能获取更多的碎片，那么距离得到此拼图的本质模样就更容易。\n\n> 认识的过程，第一步，是开始接触外界事情，属于感觉的阶段。第二步，是综合感觉的材料加以整理和改造，属于概念、判断和推理的阶段。只有感觉的材料十分丰富（不是零碎不全）和合于实际（不是错觉），才能根据这样的材料造出正确的概念和论理来。\n\n通过循环再次回来，但每次回来都拿着进一步地正确认识，就好像注入新的生命力一样。认识、实践、再认识、再实践，如此反复，永无止尽。\n\n> 通过实践而发现真理，又通过实践而证实真理和发展真理。从感性认识而能动地发展到理性认识，又从理性认识而能动地指导革命实践，改造主观世界和客观世界。实践、认识、再实践、再认识，这种形式，循环往复以至无穷，而实践和认识之每一循环的内容，都比较地进到了高一级的程度。这就是辩证唯物论的全部认识论，这就是辩证唯物论的知行统一观。\n\n","tags":["毛泽东选集"],"categories":["article"]},{"title":"接受毛泽东的思想批评之没有把握是缺乏认识和实践","url":"/2024/08/09/接受毛泽东的思想批评之没有把握是缺乏认识和实践/","content":"\n常常听到一些同志在不能勇敢接受工作任务时说出来的一句话：没有把握。为什么没有把握呢？因为他对于这项工作的内容和环境没有规律性的了解，或者他从来就没有接触过这类工作，或者接触得不多，因而无从谈到这类工作的规律性。及至把工作的情况和环境给以详细分析之后，他就觉得比较地有了把握，愿意去做这项工作。如果这个人在这项工作中经过了一个时期，他有了这项工作的经验了，而他又是一个肯虚心体察情况的人，不是一个主观地、片面地、表面地看问题的人，他就能够自己做出应该怎样进行工作的结论，他的工作勇气也就可以大大地提高了。只有那些主观地、片面地和表面地看问题的人，跑到一个地方，不问环境的情况，不看事情的全体（事情的历史和全部现状），也不触到事情的本质（事情的性质及此一事情和其他事情的内部联系），就自以为是地发号施令起来，这样的人是没有不跌交子的。","tags":["反省"],"categories":["various"]},{"title":"40.组合总和 II","url":"/2024/08/09/40-组合总和-II/","content":"\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtrace(vector<int>& candidates, int target,int start,bool note) {\n        if (target == 0) {\n            result.push_back(path);\n            return;\n        }\n        if (target < 0) {\n            return;\n        }\n        for (int i = start; i < candidates.size(); i++) {\n            if(!note && i > 0 && candidates[i-1] == candidates[i]) continue; // 应对重复元素\n            path.push_back(candidates[i]);\n            target -= candidates[i];\n            backtrace(candidates, target, i + 1,true);\n            note = false;\n            path.pop_back();\n            target += candidates[i];\n        }\n    }\n\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        sort(candidates.begin(),candidates.end());\n        backtrace(candidates,target,0,false);\n        return result;\n    }\n};\n```\n\n前面做的组合题，不管强调与否，我们都知道数组中的元素是没有重复的，但这道题恰恰相反。看来只要解决重复元素可能带来的问题就可以了。\n\n首先需要对元素进行排序，这样益于跳过重复的元素，可以说必须做这一步。难道我们只需要判断 前后两个数据是否相同就能忽略重复的元素带来的问题吗？\n\n```c++\ni > 0 && candidates[i-1] == candidates[i]\n```\n\n不是，因为进入 backtrace 中导致本来用来满足需求的元素被忽略，仔细看下面这个例子：\n\n```bash\ncandidates = {1，1，1，2，1}，target = 2\n```\n\n第一个元素和第二个元素可以组合，但是由于如上的判断条件导致忽略。造成这个的原因是，我们本意忽略的元素是处于同一层的相同元素，但是进入 backtrace  中的元素属于要和上一层元素进行组合的，不应该忽略。\n\n那么我们就用一个布尔值 note 标记，如果 note 为 false 表明在同一层（同一个栈），否则在不同层（不同栈）。同层的元素相同可被忽略，不同层的元素相同不可被忽略。","tags":["回溯"],"categories":["leetcode"]},{"title":"39.组合总和","url":"/2024/08/09/39-组合总和/","content":"\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtrace(const vector<int>& candidates, int target,int start) {\n        if (target == 0) {\n            result.push_back(path);\n            return;\n        }\n        if (target < 0) {\n            return;\n        }\n        for (int i = start; i < candidates.size(); i++) {\n            path.push_back(candidates[i]);\n            target -= candidates[i];\n            backtrace(candidates, target,i);\n            path.pop_back();\n            target += candidates[i];\n        }\n    }\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        backtrace(candidates, target,0);\n        return result;\n    }\n};\n```\n\n相较于之前的题目，数组中的元素**同一个**数字可以**无限制重复被选取**，我们就得保证当前元素在下一次选择中依旧可以选择自己。要记住这是一道组合题，后续的元素是不能往前看的，即不能再选择之前的元素。要想同时达到前面两个条件，我们的做法是 传递到 backtrace 中的 start 参数 不在 自加，既 传递 i 作为参数，而不是 i + 1 作为参数。\n\n为什么组合中，其后的元素不能往前看，即不能再选择之前的元素？\n\n因为我们的回溯会把当前元素和后面的元素所有可能都尝试一遍，而组合不强调顺序性，这就是为什么组合中其后的元素没有必要往前看。","tags":["回溯"],"categories":["leetcode"]},{"title":"17.电话号码的字母组合","url":"/2024/08/09/17-电话号码的字母组合/","content":"\n```c++\nclass Solution {\npublic:\n    const string list[10] = {\"\",    \"\",    \"abc\",  \"def\", \"ghi\",\n                             \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n\n    vector<string> result;\n    string path;\n    void backtrace(string digits, int size, int note, int start) {\n        if (note == size) {\n            result.push_back(path);\n            return;\n        }\n        for (int i = start; i < size; i++) {\n            int num = digits[i] - '0';\n            for (int j = 0; j < list[num].size(); j++) {\n                path.push_back(list[num][j]);\n                note++;\n                backtrace(digits, size, note, i + 1);\n                path.pop_back();\n                note--;\n            }\n        }\n    }\n\n    vector<string> letterCombinations(string digits) {\n        if (!digits.empty()) {\n            backtrace(digits, digits.size(), 0, 0);\n        }\n        return result;\n    }\n};\n```\n\n在完成《77.组合》基础上，这道题你要会两个技能，分别是建立映射关系（通常是数组）和单个数字字符转换为对应的整数（ch - '0'）。\n\n","tags":["回溯"],"categories":["leetcode"]},{"title":"218.组合III","url":"/2024/08/09/218-组合III/","content":"\n```c++\nclass Solution {\npublic:\n    int SIZE = 9;\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtrace(int k, int n,int start,int note,int sum) {\n        if(k == note && sum == n){\n            result.push_back(path);\n            return;\n        }\n        for(int i = start; i <= SIZE; i++){\n            path.push_back(i);\n            sum += i;\n            note++;\n            backtrace(k,n,i + 1,note,sum);\n            path.pop_back();\n            sum -= i;\n            note--;\n        }\n    }\n\n    vector<vector<int>> combinationSum3(int k, int n) {\n        backtrace(k,n,1,0,0);\n        return result;\n    }\n};\n```\n\n在完成《77.组合》基础上，这道题无外乎增加一个额外的条件，即需要 path 中数的总和为 n，其中限制元素个数为 k。至于题目中明确强调的“每个数字**最多使用一次** ”无需多言，在《77.组合》中就已经没有重复利用已用过的数字，因为我们都是从当前数的下一个数开始遍历，并不会回头看。","tags":["回溯"],"categories":["leetcode"]},{"title":"77.组合","url":"/2024/08/09/77-组合/","content":"\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtrace(int n, int k, int start, int note) {\n        if (note == k) { // 终止条件\n            result.push_back(path);\n            return;\n        }\n        for (int i = start; i <= n; i++) {\n            path.push_back(i);\n            note++;\n            backtrace(n, k, i + 1, note);\n            path.pop_back();\n            note--;\n        }\n    }\n\n    vector<vector<int>> combine(int n, int k) {\n        backtrace(n, k, 1, 0);\n        return result;\n    }\n};\n```\n\nnote 记录已存储路径的长度，用以终止回溯，终止条件是回溯当中不可获取的。\n\n组合不在意顺序，因此 [1,4] 和 [4,1] 属于同一个路径，不能同时加入到总路径中，只能取其一。为了方便，按照有序进行排布会容易做题，在代码中也是通过 i + 1 传递 到 backtrace 中作为 start 参数，表示遍历路径的起始位置。\n\n回溯的体现就在于，你添加的操作在从 backtrace 结束之后对应的删除操作，比方说 `path.push_back(i)` 对应 `path.pop_back()`，`note++` 对应 `note--`。\n\n![组合.png](/images/2024/08/09/bc6fb5b0-55f9-11ef-9ecf-d962743c35c1.png)","tags":["回溯"],"categories":["leetcode"]},{"title":"8. 字符串转换整数 (atoi)","url":"/2024/08/09/8-字符串转换整数-atoi/","content":"\n```c++\nclass Solution {\npublic:\n    void clearSpaces(std::string& str) {\n        size_t i = 0;\n        while (i < str.size() && str[i] == ' ') {\n            ++i;\n        }\n        str.erase(0, i);\n    }\n\n    std::string readNum(const std::string& str) {\n        std::string reStr;\n        for (char s : str) {\n            if (isdigit(s)) {\n                reStr += s;\n            } else {\n                break;\n            }\n        }\n        return reStr;\n    }\n\n    void clearZero(std::string& str){\n        int i;\n        for(i = 0; i < str.size(); i++){\n            if(str[i] != '0'){\n                break;\n            }\n        }\n        str.erase(str.begin(),str.begin() + i);\n    }\n\n    unsigned long long strToNum(string& str, bool note) {\n        if(str.size() > 10){\n            if(note){\n                return INT32_MIN;\n            }\n            return INT32_MAX;\n        }\n        reverse(str.begin(), str.end());\n        unsigned long long chen = 1;\n        unsigned long long renum = 0;\n        for (auto s : str) {\n            int num = s - '0';\n            renum += chen * num;\n            chen *= 10;\n            if (renum >= INT32_MAX) {\n                if(note){\n                    if(renum != INT32_MAX){\n                        return INT32_MIN;\n                    }else{\n                        return -renum;\n                    }\n                }\n                return INT32_MAX;\n            }\n        }\n        if(note){\n            return -renum;\n        }\n        return renum;\n    }\n\n    int myAtoi(std::string s) {\n        if (s.empty()) {\n            return 0;\n        }\n        bool isNegative = false;\n\n        // 去除字符串中无用的空格\n        clearSpaces(s);\n\n        // 如果第一个字符是字母，直接返回0\n        if (s.empty() || isalpha(s[0])) {\n            return 0;\n        }\n\n        // 处理正负号\n        if (s[0] == '-') {\n            isNegative = true;\n            s.erase(s.begin());\n        } else if (s[0] == '+') {\n            s.erase(s.begin());\n        }\n\n        // 读取完整的字符型数字\n        std::string numStr = readNum(s);\n        if (numStr.empty()) {\n            return 0;\n        }\n        // 排除前面的0\n        clearZero(numStr);\n\n        // 一切准备工作完成，开始把 字符串 转换为 数字\n        long long re = strToNum(numStr,isNegative);\n\n        return re;\n    }\n};\n```\n\n这道题在力扣上的通过率非常低，当前是21.3%的通过率。我花费一个早上写的代码，最终还有一个测试用例没有通过，由于有其他事情暂时搁置。直到明天的早上，也就是今天早上，没过多久就把测试用例给过了，因为在搁置之后发现最后一个没有通过的测试用例可以通过判断数字是否过大而直接返回 INT32_MAX 或 INT32_MIN。\n\n我们在进行字符串转换为数字之前，需要做很多预备工作，因为字符串里面有很多混杂的非数字字符：\n\n1. 如果是空字符，直接返回 0\n2. 去除字符串中无用的空格\n3. 如果第一个字符是字母，直接返回 0\n4. 记录正负号\n5. 读取完整的字符型数字\n6. 排除前面的 0\n\n按照这个顺序来，我们的字符串就必然是全部由数字组成，就可以真正的去做字符串转数字的工作了\n\n```c++\nunsigned long long strToNum(string& str, bool note) {\n    if(str.size() > 10){\n        if(note){\n            return INT32_MIN;\n        }\n        return INT32_MAX;\n    }\n    reverse(str.begin(), str.end());\n    unsigned long long chen = 1;\n    unsigned long long renum = 0;\n    for (auto s : str) {\n        int num = s - '0';\n        renum += chen * num;\n        chen *= 10;\n        if (renum >= INT32_MAX) {\n            if(note){\n                if(renum != INT32_MAX){\n                    return INT32_MIN;\n                }else{\n                    return -renum;\n                }\n            }\n            return INT32_MAX;\n        }\n    }\n    if(note){\n        return -renum;\n    }\n    return renum;\n}\n```\n\n按照题目要求，应该返回[INT32_MIN,INT32_MAX]区间内的数字，下面部分说明\n\n1. 如果字符串的长度大于 10，表明必然已经越界。如果这个数为负数，那么返回INT32_MIN，否则返回INT32_MAX\n2. 在循环取值计算的过程中，如果 renum 有 大于等于 INT32_MAX情况就要进行处理，避免后续没有意义的计算\n\n下面这个地方容易让人不理解，但这实际是由 INT32_MIN（2147483648） 和 INT32_MAX（2147483647）不对称导致的。由于 INT32_MIN 绝对值 大于 INT32_MAX 绝对值，所以当 renum >= INT32_MAX 进入判断的时候，我们继续考虑当这个数为负数情况下，如果 renum = INT32_MAX，应该返回 -renum，而不能直接返回 INT32_MIN。\n\n```c++\nif (renum >= INT32_MAX) {\n    if (note) {\n        if (renum != INT32_MAX) {\n            return INT32_MIN;\n        } else {\n            return -renum;\n        }\n    }\n    return INT32_MAX;\n}\n```","tags":["字符串"],"categories":["leetcode"]},{"title":"CPP 中 cctype 库的常用方法","url":"/2024/08/08/CPP-中-cctype-库的常用方法/","content":"\n`std::isalpha`: 判断是否为字母\n\n`std::isdigit`: 判断是否为数字\n\n`std::isalnum`: 判断是否为字母或数字\n\n`std::iscntrl`: 判断是否为控制字符\n\n`std::isgraph`: 判断是否为除空格外的可打印字符\n\n`std::islower`: 判断是否为小写字母\n\n`std::isupper`: 判断是否为大写字母\n\n`std::isprint`: 判断是否为可打印字符（包括空格）\n\n`std::ispunct`: 判断是否为标点符号\n\n`std::isspace`: 判断是否为空白字符（如空格、换行、制表符等）\n\n`std::isxdigit`: 判断是否为十六进制数字\n\n如上这些方法是用来判断是否为某种字符的，如果是返回true，如果不是返回false\n\n通常我们在处理哪种需要判断给定的字符串中有多少数字、多少字母等会非常好用\n\n下面再介绍此头文件中的另外两个方法，即大小写字母转换\n\n`std::tolower`：转换为小写\n\n`std::toupper`：转换为大写","tags":["CPP"],"categories":["technology"]},{"title":"66.加一","url":"/2024/08/08/66-加一/","content":"\n```c++\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        bool flag = true;   // 存在进位\n        vector<int> data;\n        if(digits[digits.size() - 1] + 1 != 10){    // 如果加1不会进位，返回最后一个元素加1的原数组\n            digits[digits.size() - 1]++;\n            return digits;\n        }\n\n        for(int i = digits.size() - 1; i >= 0; i--){\n            if(flag){\n                if(digits[i] + 1 != 10){    // 后续不会有进位，flag = false;\n                    data.push_back(digits[i] + 1);\n                    flag = false;\n                }else{  // 后续还有进位，flag保持不变\n                    data.push_back(0);\n                }\n            }else{  // 没有进位，添加原数组元素即可\n                data.push_back(digits[i]);\n            }\n        }\n        if(flag){   // 如果有进位，代表这个数是 N 个 9组成，所以添加元素 1\n            data.push_back(1);\n        }\n        reverse(data.begin(),data.end());   // 反转\n        return data;\n    }\n};\n```\n\n这道题容易让人误解，应该把题意讲得清楚些。有一个自然数，被拆分成个位数存储在数组中，对这个自然数进行加 1 操作。很明显，如果我们的自然是99，那么加 1 的结果就是 100，显然原数组是存储不下的，因为vector容器不支持头部插入元素。\n\n如果数组中的末尾元素 加 1 之后不存在进位，只需要把原数组的末尾元素加 1 之后返回即可。\n\n如果存在进位，就需要声明一个新的容器 data 来存储元素，避免原数组因为进位操作导致无法存储超过原长度的元素个数。基于存在进位的这种情况开始对原数组进行计算，第一次进入 for 循环中肯定是存在进位的情况。如果当前元素加 1 依旧满足进位，那么 flag 保持不变，添加元素 0 到 data 容器中。如果当前元素 加 1 不满足进位，flag 设置为 false，添加当前元素 加 1 之后的结果到 data容器中。\n\n前面讲，进入 for 循环的第一次必然存在进位，那么此后就会出现两种情况：如果 flag 为 false ，后续的原数组元素添加到 data 容器中即可。如果 flag 依旧为 true，那不过是重复上面的逻辑，直到 flag 为 false 才进入到”原数组元素添加到 data 容器中即可“阶段。\n\n如果 flag 始终为 true ，那么还需要添加元素 1 到 data 容器中。假定自然数为99，那么上面的逻辑执行下来，数组中存储的元素是 0 0。所以，如果 flag 依旧为 true，我们需要继续添加 元素 1 进来，否则不进行新的元素添加。然后就可以 data 容器反转之后进行返回，得到符合题意的结果。","tags":["数组"],"categories":["leetcode"]},{"title":"26.删除有序数组中的重复项","url":"/2024/08/08/26-删除有序数组中的重复项/","content":"\n```c++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if(nums.size() == 1) return 1;\n        int left = 0;       // 用于比较是否重复\n        int right = 1;      // 用于指定更新值的下标\n        for(int i = 1; i < nums.size(); i++){\n            while(nums[left] != nums[i]){\n                nums[right] = nums[i];\n                right++;\n                left = i;\n            }\n        }\n        return right;\n    }\n};\n```\n\n双指针法，right 用于指向更新值的下标，left 用于比较是否重复。\n\n如果nums[left] 和 nums[i] 不相等，表明遇到不是重复的新值，然后把这个新值赋值给 nums[right]，继而把 right 和 left 的下标进行更新。","tags":["数组"],"categories":["leetcode"]},{"title":"关心群众生活，注意工作方法","url":"/2024/08/07/关心群众生活，注意工作方法/","content":"\n要想动员群众，就得关心群众生活，否则只是向人民群众提出要求，不仅没想着解决矛盾，倒还创造矛盾，激化矛盾，这是不可以的。我们的党和政府始终要与群众保持联系，否则提出的新规划不能解决当下的矛盾，群众得不到实际的好处，就会被认为是大话，空话，甚至沦为笑话。\n\n> 在我们的工作人员中，曾经看见这样的情形：他们只讲扩大红军，扩充运输队，收土地税，推销公债，其他事情呢，不讲也不管，甚至一切都不管。\n\n> 就得和群众在一起，就得去发动群众的积极性，就得关心群众的痛痒，就得真心实意地为群众谋利益，解决群众的生产和生活的问题，盐的问题，米的问题，房子的问题，衣的问题，生小孩子的问题，解决群众的一切问题。\n\n理论和实践有很大的差距，提出利于群众的政策，下面有实权的人就要实打实地去做，不要群众没得到实惠，就用假数据假信息蒙骗上级。不要让下级成为过滤网，过滤好的留在自己手里，留些残渣渗下去，层层滤网，还能流出多少实惠给到群众？需要严格把关下级传递上来的信息，保证信息的准确性、完整性、可靠性，若有半点偷奸耍滑者，立即处置。\n\n> 我们的任务是过河，但是没有桥或没有船就不能过。不解决桥或船的问题，过河就是一句空话。不解决方法问题，任务也只是瞎说一顿。不注意扩大红军的领导，不讲究扩大红军的方法，尽管把扩大红军念一千遍，结果还是不能成功。","tags":["毛泽东选集"],"categories":["article"]},{"title":"19.删除链表的倒数第 N 个结点","url":"/2024/08/07/19-删除链表的倒数第-N-个结点/","content":"\n```c++\nclass Solution {  \npublic:  \n    ListNode* removeNthFromEnd(ListNode* head, int n) {  \n        ListNode* getLen = head;  \n  \n        ListNode* virtualHead = new ListNode(-1);  \n        virtualHead->next = head;  \n        ListNode* delNode = virtualHead;  \n  \n        int len = 0;  \n        while(getLen){  // 获取链表长度   \n            getLen = getLen->next;  \n            len++;  \n        }  \n        len = len - n;  \n        for(int i = 0; i < len; i++){   // 找到需要移除节点的前一个节点  \n            delNode = delNode->next;  \n        }  \n  \n        delNode->next = delNode->next->next;    // 删除节点  \n          \n        return virtualHead->next;   // 返回头节点  \n    }  \n}; \n```\n\n只要明白链表的特性，以及删除的特点就很容易想到该怎么处理这道题，不会想复杂。我们要删除链表的倒数第 N 个节点，只需要找到这个节点的前一个节点，因为删除链表节点的准则就是找到待删除节点的前一个节点。由于我们是要找倒数第 N 个节点，就要先获取链表长度（只能遍历一次得到），然后`len = len - n`计算出 len ，用于找到待删除节点的前一个节点。","tags":["链表"],"categories":["leetcode"]},{"title":"2.两数相加","url":"/2024/08/07/2-两数相加/","content":"\n```c++\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        bool note = false;\n        ListNode* head = new ListNode(-1);\n        ListNode* rehead = head;\n        while (l1 != nullptr && l2 != nullptr) {\n            int num = l1->val + l2->val;\n            if (note) {\n                num++;\n                note = false;\n            }\n            if (num >= 10) {\n                num = num % 10;\n                note = true;\n            }\n            ListNode* tmp = new ListNode(num);\n            rehead->next = tmp;\n            rehead = rehead->next;\n            l1 = l1->next;\n            l2 = l2->next;\n        }\n        if (l2) {\n            swap(l1, l2);\n        }\n        while (l1 != nullptr) {\n            int num = l1->val;\n            if (note) {\n                num++;\n                note = false;\n            }\n            if (num >= 10) {\n                num = num % 10;\n                note = true;\n            }\n            ListNode* tmp = new ListNode(num);\n            rehead->next = tmp;\n            rehead = rehead->next;\n            l1 = l1->next;\n        }\n        if (note) {\n            ListNode* tmp = new ListNode(1);\n            rehead->next = tmp;\n        }\n        return head->next;\n    }\n};\n```\n\n还是要看懂题目，实际上就是将两个链表从头到尾取相同位置的节点相加，这可能出现以下情况：\n\n- 两个链表长度相同且最后没有产生进位，返回 head->next 即可\n- 两个链表长度相同且最后有产生进位，创建一个值为 1 的新节点 tmp，然后 rehead->next 指向 tmp节点，最后返回 head->next 即可\n- 两个链表长度不同，那么对于没有处理完的链表中的节点逐一移动到 rehead 节点之后，接着进入上述的两种情况中继续处理\n\n```\n输入：l1 = [5,6,4,9], l2 = [2,4,9]\n输出：[7,0,4,0,1]\n解释：9465 + 942 = 10407\n```\n\n当然，还有就是关于进位的处理，这并不难，只需要用一个标记位 note 来标识是否有进位，还有要记得正确更新 note 的情况。\n\n```c++\nif (note) {\n      num++;\n      note = false;\n }\nif (num >= 10) {\n      num = num % 10;\n      note = true;\n}\n```","tags":["链表"],"categories":["leetcode"]},{"title":"143.重排链表","url":"/2024/08/07/143-重排链表/","content":"\n```c++\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) {\n            return head;\n        }\n        ListNode* left = head;\n        ListNode* right = head->next;\n        while (right) {\n            ListNode* node = right->next;\n            right->next = left;\n            left = right;\n            right = node;\n        }\n        head->next = nullptr;\n        return left;\n    }\n\n    void reorderList(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) {\n            return;\n        }\n        // 找到中间节点进行切割，左半部分链表保持不变，反转右半部分链表\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while (fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        ListNode* left = head;\n        ListNode* right = slow->next;\n        slow->next = nullptr;\n        right = reverseList(right);\n\n        // 准备工作已做好，开始重排\n        ListNode* virtualHead = new ListNode(-1);\n        ListNode* tmp = virtualHead;\n        while (left != nullptr && right != nullptr) {\n            tmp->next = left;\n            left = left->next;\n            tmp->next->next = right;\n            right = right->next;\n            tmp = tmp->next->next;\n        }\n\n        if (left != nullptr) {\n            tmp->next = left;\n        }\n\n        head = virtualHead->next;\n    }\n};\n```\n\n这道题只要能够把题目看明白，即它究竟是如何重排，逻辑上理清楚并不难\n\n1. 先找到中间节点，将当前链表分割成两部分，即左链表和右链表\n2. 左链表的尾节点要指向 nullptr，右链表需要反转\n3. 创建一个虚拟头节点用来链接后续重排的节点，先链接左链表的第一个节点，接着链接右链表的第一个节点，如此循环\n4. 如果左链表当前节点和右链表当前节点有一个不满足不为空就退出循环。由于左链表的长度大于或等于右链表（如果大于，也只会比其多一个节点），退出循环之后，继续判断左链表当前节点是否为空，不为空就代表还有一个节点被遗漏，tmp 指向这个节点即可\n5. 最后，记得更换 head 节点为 virtualHead->next\n\n---\n\n完成本题的过程中，犯下的错误是 tmp 节点的移动，错误的逻辑代码如下：\n\n```c++\nwhile (left != nullptr && right != nullptr) {\n  tmp->next = left;\n  tmp = tmp->next;\t\t// 错误的逻辑代码，后续代码也没价值\n  tmp->next = right;\n  tmp = tmp->next;\t\t\n  left = left->next;\n  right = right->next;\n}\n```\n\n因为我们的 left 和 right 节点后面也跟着很多的节点，如果你 tmp = tmp->next，然后再 tmp->next = right，就失去 left 链表的掌控了（left 链表被污染），从而出现错误。\n\n![重排链表.png](/images/2024/08/07/802b1dd0-549e-11ef-996a-6b29d9dcc7bf.png)\n\n所以，只需要每次让 tmp 指向 left 或 right 的节点之后，及时更新 left 和 right 指针即可，保证不被污染\n\n```c++\nwhile (left != nullptr && right != nullptr) {\n     tmp->next = left;\n     left = left->next;\n     tmp->next->next = right;\n     right = right->next;\n     tmp = tmp->next->next;\n }\n```","tags":["链表"],"categories":["leetcode"]},{"title":"142.环形链表II","url":"/2024/08/07/142-环形链表II/","content":"\n```c++\nclass Solution {  \npublic:  \n    ListNode* detectCycle(ListNode* head) {  \n        if (head == NULL || head->next == NULL) {  \n            return nullptr;  \n        }  \n        // 快慢指针，有环必相遇  \n        ListNode* node = head;  \n        ListNode* slow = head;  \n        ListNode* fast = head;  \n        while (fast != nullptr && fast->next != nullptr) {  \n            slow = slow->next;  \n            fast = fast->next->next;  \n            if (slow == fast) { // 有环  \n                while (true) {  \n                    if (node == slow) {  \n                        return slow;  \n                    }  \n                    node = node->next;  \n                    slow = slow->next;  \n                }  \n            }  \n        }  \n        return nullptr;  \n    }  \n};  \n```\n\n此题建立在你已经完成 《141.环形链表》题目，我们重点就关注判断有环之后如果找到第一次相遇的节点。\n\n![环形链表II.png](/images/2024/08/07/fcf6ef00-5490-11ef-996a-6b29d9dcc7bf.png)\n\n我们可以确定如下信息：\n\n- 慢指针必然不可能环绕圆形一圈，快指针至少环绕环形一圈\n- 快指针和慢指针从同一个起点出发，并且快指针是慢指针的两倍\n\n设定 相应的变量之后，得到如下等式：n >= 1，且 n 为正整数 （因为快指针至少环绕环形一圈）\n\n```tex\n(x + y) * 2 = x + y + n ( y + z ) \n\t\t↓\nx = (n - 1)(x + y) + z\n```\n\n我们假定 n == 1，那么 x = z。这个时候再看图，就发现只要 快慢指针的相遇节点和头节点同时向前移动，它们两个的相遇点就是链表开始入环的第一个节点。\n\n---\n\n在完成《141.环形链表》题目的时候，我的第一份代码如下：\n\n```c++\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(head == NULL || head->next == NULL){\n            return false;\n        }\n        ListNode* slow = head;\n        ListNode* fast = head->next;\n        while(fast != nullptr && fast->next != nullptr){\n            if(slow == fast){\n                return true;\n            }\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return false;\n    }\n};\n```\n\n我企图用这份代码来套用到本题，却发现犯了一个大错误，那就是 slow 和 fast 不是同一个起点开始，导致上面的推导公式失效。所以，我们务必保证最初的快慢指针的起点是一致的，即指向头节点。如果是这样，上面的代码还需要改正的地方是，要先进行指针移动，再判断快慢指针是否指向同一个节点，从而判断是否为环形链表。\n\n```c++\nclass Solution {\npublic:\n    bool hasCycle(ListNode* head) {\n        if (head == NULL || head->next == NULL) {\n            return false;\n        }\n        \n        ListNode* slow = head;\n        ListNode* fast = head;\n        while (fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next->next;\n            if (slow == fast) { // 快慢指针，有环必相遇\n                return true;\n            }\n        }\n        return false;\n    }\n};\n```","tags":["链表"],"categories":["leetcode"]},{"title":"141.环形链表","url":"/2024/08/07/141-环形链表/","content":"\n```c++\nclass Solution {\npublic:\n    bool hasCycle(ListNode* head) {\n        if (head == NULL || head->next == NULL) {\n            return false;\n        }\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while (fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next->next;\n            if (slow == fast) { // 快慢指针，有环必相遇\n                return true;\n            }\n        }\n        return false;\n    }\n};\n```\n\n定义快慢指针：\n\n- 慢指针 slow：指向头节点\n- 快指针 fast：指向头节点的下一个节点（在此之前已经有判断条件，保证当前链表至少有一个节点，不会出现未定义行为）\n\n指针的移动在 while 循环中进行，暂且不管 while 得以进行的条件，先假定作用域中的代码能够正常往下推进。先移动快慢指针，慢执行移动一个节点，快指针移动两个节点。如果两个指针指向同一个节点表明有环，如果不是就继续循环。如果最终退出循环，说明这个链表没有环。\n\n这个时候我们再回头看 while中的条件应该怎么写？\n\nfast 指针比 slow 指针更容易指向 nullptr，我们保证 fast 不为 nullptr 就能保证 slow 不为 nullptr。从 while 循环中的移动情况来看，fast 会移动两个节点，那我们就需要保证 fast != nullptr && fast->next != nullptr 。\n\n为什么快慢指针能判断环形链表呢？\n\n如果这是一条直线，快的车永远不可能遇到慢的车，如果遇到必然就是一个环。","tags":["链表"],"categories":["leetcode"]},{"title":"1. 两数之和","url":"/2024/08/07/1-两数之和/","content":"\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int,int> data;\n        vector<int> result;\n        for(int i = 0; i < nums.size(); i++){\n            int re = target - nums[i];\n            auto it = data.find(re);\n            if(it != data.end()){\t\n                result.push_back(i);\t// 当前元素下标\n                result.push_back(it->second);\t// 配对元素下标\n                break;\n            }\n            data[nums[i]] = i;\n        }\n        return result;\n    }\n};\n```\n\n拿到此题个人的解题思路是采用哈希表\n\nC++中具有哈希表特征的是 set 和 map 容器，题目要求获取下标同时又需要参考`target - nums[i]`的结果。因此采用unordered_map容器最佳，即 key 存储`target - nums[i]`的结果，value 存储下标\n\n个人遇到的问题是记不清 map 容器的 find 的方法究竟寻找的 key 还是 value？答案是 key！！！\n\n`std::unordered_map::find` 用于查找键，并返回一个指向该 键-值对 的迭代器","tags":["数组"],"categories":["leetcode"]},{"title":"常用网站","url":"/2024/08/06/常用网站/","content":"\n## API 查阅网站\n\n[cppreference](https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5)：C 和 CPP 库查询\n\n[cplusplus](https://cplusplus.com/reference/)：C 和 CPP 库查询\n\n","tags":["推荐"],"categories":["various"]},{"title":"百香果","url":"/2024/08/06/百香果/","content":"\n## 介绍\n\n西番莲，又名百香果、热情果、鸡蛋果，产于美洲的热带及亚热带地区。原产于巴西，巴拉圭，1610年间传入欧洲西番莲的果汁**常被用作香料，加在其他果汁中**\n\n黄色百香果：营养价值最高，最优选择\n\n![黄色百香果.png](/images/2024/08/06/5b61dc60-5394-11ef-ba61-71329f1643ea.png)\n\n紫色百香果\n\n![紫色百香果.png](/images/2024/08/06/578628d0-5394-11ef-ba61-71329f1643ea.png)\n\n紫红色百香果\n\n![紫红色百香果.png](/images/2024/08/06/4fd02140-5394-11ef-ba61-71329f1643ea.png)\n\n## 名称的来源\n\n西番莲自西班牙语转译至英语称passion fruit，**意即“受难果”**，“百香果”这个名称实际上是“passion”一字为音译。当时西班牙传教士发现其花的形状极似基督之十字架刑具，柱头上3个分裂，极似3根钉，花瓣红斑、恰似耶稣头部被荆棘刺出血形象，5个花药，恰似钉子或伤痕。西班牙人以Passioflos名之，直译为受难花（Passion Flower）。**但英语中passion一词还有“热情”之意，故也常被误译为“热情果”，与原意无关**\n\n## 营养\n\n| 名称       | 含量 |\n| ---------- | ---- |\n| 水分       | 73%  |\n| 碳水化合物 | 22%  |\n| 蛋白质     | 2%   |\n| 脂肪       | 0.7% |\n\n每100克（3.5盎司）的生西番莲提供97卡路里的热量，是**维生素C（33%每日摄入量）的丰富来源**（指比每日摄入量的20%更多），也是**核黄素与钾的中等来源（10-19%每日摄入量）**。其他微量营养素的含量不显著\n\n## 注意点\n\n 一般3~4个就好，多了容易胃酸\n\n因此，对于部分患有胃肠炎、胃溃疡、十二指肠溃疡的患者应谨慎食用\n\n## 挑选方法\n\n1. 观察百香果果皮的质感：最佳选择是**果皮微皱**的略带深紫色的果子，这样的果子最成熟也最甜。可能你想买干净的卖相好的果子，但实际上这并不重要，因为你只吃里面的果肉。果壳越软，果实越成熟\n2. 摇一摇：如果晃动强，说明果肉与果皮分离，很可能是坏的\n3. 闻一闻：通过闻也可以判断口味。如果闻起来有热带水果的香味，一定很香甜；如果闻不出任何味道，果肉要么很酸要么淡而无味\n\n果皮微皱\n\n![挑选百香果.png](/images/2024/08/06/433b9c20-5394-11ef-ba61-71329f1643ea.png)\n\n颜色深，为深紫色（紫红色百香果）\n\n![看颜色.png](/images/2024/08/06/3dc7bc60-5394-11ef-ba61-71329f1643ea.png)\n\n## 参考链接\n\n[维基百科](https://zh.wikipedia.org/wiki/西番莲)\n\n[百度百科](https://baike.baidu.com/item/%E7%99%BE%E9%A6%99%E6%9E%9C/1484850)\n\n[wikiHow](https://zh.wikihow.com/%E4%BA%AB%E7%94%A8%E7%99%BE%E9%A6%99%E6%9E%9C)","tags":["水果"],"categories":["life"]},{"title":"适当谈心的益处","url":"/2024/08/05/适当谈心的益处/","content":"\n回忆学生时代，大家会有过类似的体验：和朋友闹矛盾和好之后，关系比以往更加亲密了。这是因为通过上次不友好的碰撞事件，彼此发现双方的底线位置，相比之前没有距离感的关系，自然离健康的关系更近些。可是，这样的成本未免过高，毕竟以不好的情绪收场，能不能重归于好也只能画个问号。况且，人脱离教室这种空间限制之后，会因为更多的选择而轻易放弃掉这种因不美好收场而暂时破裂的友情，并作为最终结局。\n\n谈心是可行的，能够低成本知道对方的喜恶，以及很多你需要花费智力和感受能力才得知的信息。袒露自己给对方更多就是相信对方的表现，自然而然会距离眼前这个人更加亲近，亲密感、舒适感和熟悉感呈现递增趋势。但不要谈的过多，要选择自己能够谈的内容去谈，如果谈的内容会让你感到恐惧和被威胁的可能，就不要去谈了，除非这个人永远不会和你产生半点联系。","tags":["零碎之思"],"categories":["article"]},{"title":"模板元编程的意义","url":"/2024/08/05/模板元编程的意义/","content":"\n## 模板、元编程和泛型编程\n\n**模板**是一种能够产生代码的代码，本身不进入程序中\n\n**元编程**意味着你撰写一段程序A（前面提到的模板），程序A会运行后生成另外一个程序B，程序B才是真正实现功能的程序。那么这个时候程序A可以称作程序B的元程序，撰写程序A的过程，就称之为“元编程”\n\n如果元编程中所有的变化的量（或者说元编程的参数）都是类型，那么这样的编程，我们称为**泛型编程**\n\n区分泛型编程和元编程，可参考王建伟老师的区分：\n\n- 泛型编程：重点突出的是“通用”的概念，这个“泛”字就是通用的意思。例如函数模板、类模板代码，这些代码很多都以类型作为模板参数进行传递，程序员不需要关心具体的类型，编译器会进行相关的类模板或函数模板的实例化工作。模板的设计初衷也是用于泛型编程--对数据类型和算法等进行抽象\n- 元编程：重点突出的是一种程序设计技巧，达到用常规的编程手段难以达到的效果。这种程序设计技巧非常注重模板在实例化过程中的一些推导过程，而这些推导过程恰恰是解决问题和体现程序设计技巧的过程\n\n```C++\ntemplate <typename T>\nT const& Max (T const& a, T const& b) \n{ \n    return a < b ? b:a; \n} \n```\n\n如上是函数模板，但它并不算是代码，而是用来生成代码（实例化的时候会生成对应的代码），假定你调用如下方法（`Max(3,5)` 和 `Max(1.2,3.1)`）\n\n那么你的程序中只有两部分代码（函数代码 A 和函数代码 B），函数模板并不在其中\n\n从这点我们就明白，模板会在编译期间帮我们把代码生成，而不是在运行时（说此是为了强调和多态机制的不同）\n\n**模板本身并不是最终可执行代码的一部分，而是用于生成最终可执行代码的“蓝图”。模板定义了一个通用的模式，但真正的代码是在模板实例化时生成的**\n\n```c++\nMax(3,5);\n\n//生成函数代码 A\nint const& Max (int const& a, int const& b) \n{ \n    return a < b ? b:a; \n} \n\nMax(1.2,3.1);\n\n//生成函数代码 B\n\nfloat const& Max (float const& a, float const& b) \n{ \n    return a < b ? b:a; \n} \n```\n\n通过模板，我们可以将形形色色的堆栈代码分为两个部分，一个部分是不变的接口，以及近乎相同的实现；另外一部分是元素的类型，它们是需要变化的。因此同函数类似，需要变化的部分，由模板参数来反应；不变的部分，则是模板内的代码。可以看到，使用模板的代码，要比不使用模板的代码简洁许多\n\n## 模板、宏和重载\n\n宏只是替换，没有类型安全检查，代码永远只有一份\n\n模板用来生成代码，编译期间就确定程序所需的代码并实际产生\n\n宏既然是替换，意味着是在运行期间运作，如果暂时不考虑安全问题，效率问题也是不可忽视（通常宏用于短小代码）。函数重载倒是可以编译期间确定，却也因为不具备模板“变化莫测”的特性，略输一筹。这样看来，模板倒是非常强大了，既是在编译期间确定且能应对变化\n\n> 编译期间确定（编译期决策）通常比运行时确定（运行时决策）效率更高。这主要是因为编译期决策在程序运行之前已经确定好了具体的操作，而运行时决策需要在程序执行时进行额外的计算和判断\n>\n> 比方说 if 判断语句，编译期间就已经判断完成，而运行期间会在运行时才去做这个判断\n\n## 面向过程编程、面向对象编程和模板元编程\n\n以牲口圈舍举例谈三种编程，即有三种动物（马羊猪），要给它们分别搭建一个棚（马棚、羊圈、猪圈）\n\n（1）面向过程\n\n一种动物一个棚，种类越多类越多，代码量增多（关键是得自己一个一个写）\n\n但不得不承认，这种编程符合现实世界，即每种动物放在各自的棚里面\n\n![面向过程.png](/images/2024/08/05/ffded890-5323-11ef-8091-ed2d3d2eaedb.png)\n\n（2）面向对象\n\n把棚抽象为一个类，所有动物都放在一个棚里面，继承者只需要实现抽象基类的虚函数即可\n\n相对于面向过程，尽管方法getHeight依旧需要实现，但是无需每次都创建一个棚了，代码量明显减少\n\n可是这脱离现实了，因为没人会把所有动物放在一个棚里面管理（这个棚也是不存在的，是虚拟的）\n\n![面向对象.png](/images/2024/08/05/f8511980-5323-11ef-8091-ed2d3d2eaedb.png)\n\n（3）模板元编程\n\n面向过程要手写很多代码，因为每个动物的类型不同\n\n面向对象又不符合现实情况，按理改为每种动物在不同的棚中，而不是放在一个棚中管理\n\n模板元编程可以只需要设计一份代码，传入不同的类型并生成实际的代码，完美解决面向过程和面向对象的不足\n\n![模板元编程.png](/images/2024/08/05/f249fa70-5323-11ef-8091-ed2d3d2eaedb.png)\n\n## 模板函数和模板类的语法\n\n（1）函数模板\n\n```c++\ntemplate <typename type> \nret-type func-name(parameter list)\n{\n   // 函数的主体\n}\n\n// 举例\ntemplate <typename T>\ninline T const& Max (T const& a, T const& b) \n{ \n    return a < b ? b:a; \n} \n```\n\n（2）类模板\n\n```c++\ntemplate <class type> \nclass class-name \n{\n\t//成员变量、成员方法\n}\n\n// 举例\ntemplate <class T>\nclass Stack { \n  private: \n    vector<T> elems;     // 元素 \n \n  public: \n    void push(T const&);  \t\t// 入栈\n    void pop();                 // 出栈\n    T top() const;             // 返回栈顶元素\n}; \n```\n\n------\n\n参考链接\n\nhttps://sg-first.gitbooks.io/cpp-template-tutorial/content/TMP_ji_chu_md.html","tags":["CPP","模板元编程"],"categories":["technology"]},{"title":"为什么在你的进程退出时没有内存泄露？","url":"/2024/08/05/为什么在你的进程退出时没有内存泄露？/","content":"\n当你编写一个短时间运行的程序时，可能会使用 malloc()分配一些空间。程序运行并即将完成：是否需要在退出前调用几次 `free() `？虽然不释放似乎不对，但在真正的意义上，没有任何内存会“丢失”。原因很简单：系统中实际存在两级内存管理。\n\n第一级是由操作系统执行的内存管理，操作系统在进程运行时将内存交给进程，并在进程退出（或以其他方式结束）时将其回收。第二级管理在每个进程中，例如在调用 `malloc()` 和  `free()` 时，在堆内管理。即使你没有调用 `free()`（并因此泄露了堆中的内存），操作系统也会在程序结束运行时，收回进程的所有内存（包括用于代码、栈，以及相关堆的内存页）。无论地址空间中堆的状态如何，操作系统都会在进程终止时收回所有这些页面，从而确保即使没有释放内存，也不会丢失内存。\n\n因此，对于短时间运行的程序，泄露内存通常不会导致任何操作问题（尽管它可能被认为是不好的形式）。如果你编写一个长期运行的服务器（例如 Web 服务器或数据库管理系统，它永远不会退出），泄露内存就是很大的问题，最终会导致应用程序在内存不足时崩溃。当然，在某个程序内部泄露内存是一个更大的问题：操作系统本身。这再次向我们展示：编写内核代码的人，工作是辛苦的……\n\n---\n\n内容取自译者王海鹏《操作系统导论》，仅从中取出个人以为需要纪录的内容。不追求内容的完整性，却也不会丢失所记内容的逻辑性。如果需要了解细致，建议读原书","tags":["技术摘录"],"categories":["technology"]},{"title":"多线程中的虚假唤醒","url":"/2024/08/05/多线程中的虚假唤醒/","content":"\n当一个正在等待条件变量的线程由于条件变量被触发而唤醒时，却发现它等待的条件（共享数据）没有满足\n\n避免虚假唤醒，就不应该采用 if 条件判断，而应该采用 while 循环判断\n\n这样，即便生产者唤醒所有消费者，由于消费者这边采用 while 循环判断，确保`wait`方法会在唤醒后重新检查条件，哪怕 g_deque 中已经没有可消费对象，也不会导致这边出现虚假唤醒\n\n如果消费者这边采用 if 条件判断，由于生产者唤醒，消费者接收到信号不重新检查g_deque中是否还有可消费对象（有可能已经被其它消费者消费），导致可能出现虚假唤醒\n\n```c++\n// 虚假唤醒\n\nif (g_deque.empty())\n{\n    g_cond.wait(lck);\n}\n\n// 避免虚假唤醒\n\nwhile (g_deque.empty())\n{\n    g_cond.wait(lck);\n}\n```\n\n还有通过Lambda表达式，同样可以避免虚假唤醒\n\n即在wait方法的第二个参数提供Lambda表达式，如果返回值为true就获取锁往下执行代码\n\n```c++\ng_cond.wait(lock, []{ return !g_deque.empty(); });\n```\n\n如上两种写法的产生，就是C++11提供wait的两种方法的参数列表不同\n\n```c++\nvoid wait (unique_lock<mutex>& lck);\n\ntemplate <class Predicate>  \nvoid wait (unique_lock<mutex>& lck, Predicate pred);\n```\n\n其中 pred 代表一个可调用的对象或函数，它不接受任何参数，并返回一个可以计算为 `bool` 的值。 这将被反复调用，直到它的计算结果为 `true`\n\n\n\n\n\n","tags":["并发编程"],"categories":["technology"]},{"title":"确定剧情和不确定剧情的思考方式","url":"/2024/08/05/确定剧情和不确定剧情的思考方式/","content":"\n时常犯一个错误，就是将对文学作品的思考方式套用到现实剧情中。这种倾向容易导致一个令人困扰的现象：深思熟虑的分析有面临剧情的反转的可能。\n\n对于不确定的剧情，我们不妨避免过度的细致讨论，可以选择用武断且不失道理的话回复，或者采用模糊的措辞来回避真正的问题。不细致之故，还在于涉及到具体到人物上容易造成误会的是像大家聚堆议论他，可能出现不利于个体的情况，这种现实层面的考虑也必不可少。\n\n我不必列举文学作品的价值有哪些，你若在意答案可去别人那里寻，尽管我不知道这样的价值在哪里。从上面的认识可知，至少有一点价值可以肯定，即文学作品的剧情确定无疑由读者把握。\n\n你会注意到，同样的剧情，放到小说中更容易被接受和理解，而在现实中由于信息的不足，人们往往不得不做出最坏的设想来思考角色的所作所为。回顾《仙剑奇侠传三》，我发现龙葵的行为在某种程度上类似于绿茶，至少从晴雪的角度来看是这样。但为什么观众没有这样认为呢？因为观众站在上帝的视角，知道二人前世是兄妹关系，不可能对晴雪和景天的关系构成威胁。龙葵以血献祭来帮助哥哥（即现在的景天）铸剑，使得龙葵的心中永远只有景天，能让她感到难过的也只有景天，因此观众可以理解并同情龙葵在锁妖塔中的遭遇，了解她一路的坎坷经历。\n\n智慧只能在确定性的基础上产生，对于不确定的事情，我们应该保持一定的距离，学会倾听别人的看法，同时保留自己的意见。因为不确定的事情就像眼前的迷雾，想要看得清楚，拨雾的动作只会显得多余。更好的做法是耐心等待迷雾散去的时刻。当然，你若急于弄清真相，就要实事求是地收集资料求证，而不是对自己的言论持不负责任的态度。","tags":["零碎之思"],"categories":["article"]},{"title":"分手以后的两种方案","url":"/2024/08/05/分手以后的两种方案/","content":"\n尽管我们讲一段关系走向破碎并不是瞬时发生的事情，在此之前会有一段双方不断消耗的过程。即便如此，分手之后的后悔与无奈的情绪难免浮现，可这种随时可能复合的情感和之前记忆犹新的失望比起来略输一筹，给周边人讲起经典玻璃破碎即使修复也无法还原的故事，让众人明白没有可能回去了。\n\n如果以理性的角度来看待，尽管这可能看起来有些不近人情，快速的寻找下一任对象会得到最佳的收益。如果你是被动分手的一方，寻找下一任对象，能够回击对方带给你的伤害，而斩断两人之前错觉下的唯一性观点是最关键的一点，不用困在深情的愚蠢道德约束里面。而对于主动分手的一方，自是不用多提。\n\n恋爱初期是充满甜蜜的，因为陌生和神秘感带来的探索和占有欲。在这种感觉还没有被满足之前，恋爱的价值逐渐增加，至于刚刚分手的人来说，忘记悲伤，享受快乐，仿佛恋爱又恢复如此。而选择保持单身的人就需要付出很大的代价，自我愈合伤口，从过去的生活抽离出来，这让虚弱的身体还要去主动调动积极性去对抗的人而言属实不易，却绝非不可。然而，选择下一个伴侣可以将这些任务委托给新的伴侣，从容享受成果。\n\n从长远来看，保持单身并且努力过上健康丰富的生活，价值就比急匆匆选择下一任对象更高，因为后者的行为把自己表现的毫无价值，证明自己价值的方式不是依赖别人的肯定，而是恰如其是的自我肯定。如果一件事情只有利而无害，傻子才去做选择，而如上的两种选择的利弊关系有种很强的互补性。此外，这两种选择与道德无关，而是反映了当时你的内在状态。\n\n我知道，通常情况下，人们很少会在事情进展顺利时质疑自己的选择，问题出现时才会开始寻找原因。在那之前，很少有人会愿意深入思考这个问题。","tags":["亲密关系","零碎之思"],"categories":["article"]},{"title":"虚析构函数的场景","url":"/2024/08/05/虚析构函数的场景/","content":"\n如果这个类不作为任何类的基类，析构函数是否为虚函数并不重要，因为它不必承担回收派生类资源的责任。那什么情况下给析构函数声明为虚函数是必要的？\n\n**通过基类的指针来删除派生类的对象时，基类的析构函数应该是虚函数**。\n\n## 会被继承但不需要虚析构函数\n\n```c++\nclass NonCopyable {\n protected:\n  NonCopyable(const NonCopyable &) = delete; // 阻止拷贝\n  NonCopyable &operator=(const NonCopyable &) = delete;  // 阻止赋值\n  NonCopyable() = default;\n  ~NonCopyable() = default;\n};\n```\n\n任何需要防止被拷贝和赋值都需要删除拷贝构造函数和赋值运算符函数，为了方便，继承 NonCopyable类 即可。既然这个类就是用来给其它类继承，为何却没有把析构函数声明为虚函数呢？因为我们不会通过 NonCopyable类 来创建对象，仅仅只是提供阻止拷贝和阻止赋值的功能给到派生类。\n\n## 会被继承且需要虚析构函数\n\n```c++\nclass Derived : public NonCopyable {\npublic:\n    virtual ~Derived() {  // 添加虚析构函数\n        // Derived 的清理代码\n    }\n    void doSomething() {\n        // 示例方法\n    }\n};\n\nclass MoreDerived : public Derived {\npublic:\n    ~MoreDerived() override {\n        // MoreDerived 的清理代码\n    }\n};\n```\n\nDerived 类是 NonCopyable 的派生类，是 MoreDerived 的基类。我们前面讲过 NonCopyable 类不可能用来创建对象，现在Derived 类作为MoreDerived 的基类，当Derived 类作为MoreDerived 类对象的指针的时候，Derived 类就需要承担回收MoreDerived 类对象资源的责任（调用MoreDerived 类对象的析构函数）。基于上述分析，我们需要把Derived 类的析构函数声明为虚函数。\n\n## 析构函数的调用顺序\n\n当删除一个基类指针指向的派生类对象时，首先调用派生类的析构函数，然后调用基类的析构函数。这是为了确保派生类的资源先被正确释放，然后再释放基类的资源。\n\n```c++\nclass Base {\npublic:\n    virtual void func() {\n        std::cout << \"Base::func\" << std::endl;\n    }\n    virtual ~Base() {\n        std::cout << \"Base destructor\" << std::endl;\n    }\n};\n\nclass Derived : public Base {\npublic:\n    void func() override {\n        std::cout << \"Derived::func\" << std::endl;\n    }\n    ~Derived() override {\n        std::cout << \"Derived destructor\" << std::endl;\n    }\n};\n\nint main() {\n    Base* ptr = new Derived();\n    ptr->func(); // 调用 Derived::func\n    delete ptr;  // 确保调用 Derived 析构函数，然后调用 Base 析构函数\n    return 0;\n}\n```\n\n那我们就要提出一些有趣的问题：\n\n通过基类创建的派生类对象究竟是基类对象还是派生类对象？是派生类对象。\n\n既然是创建的派生类对象为什么需要调用基类的析构函数？虽然基类没有创建对象，但派生类对象不仅包含派生类的成员，还包含基类的成员。基类的成员是派生类对象的一部分，因此在创建派生类对象时，实际上包含了两个部分：基类部分和派生类部分。基类的成员只能由基类清理，不能由派生类清理。派生类的成员也只能由派生类清理，不能由基类清理。但是将基类的析构声明为虚函数会调用派生类的析构函数，否则只会调用自己的析构函数，从而造成派生类对象的内存泄漏。\n\n## 最后的话\n\n只要弄清楚什么情况下把析构函数声明为虚函数，才不会盲目给任何类的析构函数声明为虚函数。因为虚函数会创建虚函数表，这个不必要的开销能避免就要避免。","tags":["CPP"],"categories":["technology"]},{"title":"偶遇表哥","url":"/2024/08/05/偶遇表哥/","content":"\n当语文老师微弱的中指和食指轻夹着那只垂垂欲坠的粉笔，她的笔尖刚好足够在黑板上勉强书写。然而，随着时间推移，字迹不可避免地开始逐渐扭曲，仿佛代表着生命的枯萎。她的大拇指坚定地托着，食指却用力压住粉笔，而她的右手明显地微微颤抖。这一切似乎与学生们的课堂听课与否无关，只有前几排的学生在静静地聆听，而其他地方则是一片喧哗。\n\n刚开始转到这所学校时，我曾是一个成绩相当理想的学生，然而，逐渐深陷恶劣的学习环境后，我渐渐明白，我并非那种具备坚强意志力，能够随环境变化而灵活调整学习方法的人。仅仅不到几个月，我的学习动力就彻底消失了。一开始，我感到奇怪为什么老师不干涉学生的不良行为，她不会觉得自己受到侮辱吗？然而，我渐渐理解到，老师固然年迈，早已看透这个年龄段的学生。而我也逐渐融入了这个班级的氛围，不再关心老师的态度。\n\n那个年纪的我不会感到压力，满脑子就是玩，总计划着如何避开家里人的视线和注意溜出去。家里边不怎么给零花钱，只能到游戏厅看别人玩游戏，要是能遇到哪个熟人或者刚开始到游戏厅不会使用机器的人，主动好心帮助他人是有机会一起玩的。\n\n记得有天放学回家的路上，一如既往要去游戏厅看看，得经过一座平桥，桥上两边大概率会站着几个小混混，专门收小学生的钱，一般会招手叫你过去，拍拍你两边的裤兜，没有就放行。我的应对策略是，给里面剪一个口子，钱就会掉到最底端，或者把钱放在鞋底板下面也是比较安全的。实际上搜索的繁杂性，是对自身权力和力量的宣张，也逐渐提高对被搜索者的侮辱性。常在河边走，哪有不湿脚？但对方的目标是我表哥，可就是这样一个人，身体力量与我平起平坐的人，却在我的懦弱之下肆意妄为。但时隔多年，我却心生一个疑问，他怎么知道钱会有藏在鞋底板的可能？想必也是“天涯沦落人”，这一高一下的世界里，谁又是绝对意义上的强者，谁又是绝对意义上的弱者、可怜者，也许我没有谈及自己，从整体性来讲是不道德的，遮人耳目的。\n\n只要过了这个关卡，后面基本不会遇到麻烦事，但我已经没有心情去游戏厅，在接下来转角就会走进一个小区，对这个地方有点印象。之前刚好是枇杷树开花时期，被白洁的外表惊艳到，和朋友决定势必要上树将其取下，嗅一嗅气味后，失望之余还得骂上几句。继续往前走，小区里边有两座水泥做的石板乒乓球台，旁边就是一小段梯步，梯步后面就是平坦的小路。正打算从那边过去，刚好看到一群人正围着一个学生，我看得出他满眼惊恐，眼神盯着刚刚踹他一脚的人，立即被其呵斥，不敢再看。人群中有熟人，是我的表哥！紧张的身体一下子就放松下来，有种自信，有种理所应当的上前，不会有任何危险的以为，慢慢来到这些人的面前打声招呼，如此自然融入其中？见我在旁边看着，他就像一个足球在众人围的圆中来回折腾，圆的面积会在施加不同力度和身体稳定性变化的情况下忽大忽小，我在旁边看此圆的外表被围成的畸形无比，像个身心轻松的数学家思考此圆的面积的求法。表哥问我要不要给这个人来上一脚，反正他不敢还手，我笑着摇手以示拒绝，随后退在一旁，苦笑中略感难受。这个人被打的原因是没有完成偷手机的任务，怪不得表哥手里面有那么多的手机，当时被翻盖手机闪亮亮的外壳，以及开屏的铃声吸引，还幻想什么时候自己也能有一个。\n\n怒气在暴力的持续输出下渐渐得到安抚，人是铁饭是钢嘛，手机今天是无论如何也拿不到了，可也不能轻易地放过这小子，总得用他的手艺给大家伙办点实事，捞点好处吧？表哥一群人带着他穿过几条马路，路过一家小商铺，当时的小商铺老板眼睛也没有盯着外边。起初我不觉得这是一个破绽，但事实证明只要有胆量和手法，你观念中的不可能只是从来没有得到证明的狭隘认知而已，同时也从他身上知道熟练的小偷光天化日之下实施具体行为是表现得自然而然，而非像个小偷。他先是观察老板的动向，然后故作拉开裤子拉链撒尿的姿态，以速度略微快于普通买家但又不会以他明显能更快的速度拿走面前最近的一瓶绿茶饮料，整个过程就像付了钱一样，理应拿走属于自己的东西。老板在毫无察觉的情况下就像头上自然地脱落一根细发，无足轻重，唯我惊讶不已。小商铺的右侧就是一个小巷口，大家伙收获满满的躲进小巷，饮料你一口我一口，没一会儿就空瓶了，留了一点因来回交接的撞击下产生的气泡沫沫留给他，和小气鬼吃完辣条后给你舔包包上的辣椒油和辣椒籽一个德行。我没有参与分享饮料的过程，我身体本能的拒绝参与开始到现在的一切不正当活动，我想这是后来我与表哥走上不同人生道路的原因。后面表哥一伙还要去同学家，才知道这几个人都是互相认识的同班同学，我也就没跟着去，而是半路就选择离开，毕竟走几步就到家门口，也就告别了他们。后来听说他们也参与了偷盗行为，合伙偷了几包烟，把两个老人玩得团团转。具体情况是先安排几个人去前面故作姿态要买东西，吸引火力过去之后，由于商店的橱柜是半圆形，安排两个人去另外一个地方取出橱柜里面的烟即可，调虎离山之计得以实施。\n\n后面家里边生意发生变故，与表哥家合伙干的五金店铺最后闹掰了，为了公平起见，大家选择抓阄的方式，结果是我家没能得到店铺，最后进行财产的平均分割。我非常清楚父母为了赚钱做出过很多尝试，所以我短短几年就随着父母到处折腾，更换了很多城市和学校，成绩也是因为环境的质量忽高忽低。父母毕竟积累了一些经验，实在是不甘心放弃开五金店铺的想法，到处在周边找店铺，但是价格总不让满意，最后也是不得不选择离开那座城市，回到老家县城那边开店到现在，至此和表哥几乎断了联系。只是后面听说他没有读初中，而是选择打工，这应该是被读书无用论的想法迫害，对于几乎包里边没钱的未成年人来说，年纪轻轻被两三千元的工资诱惑是情有可原的。\n\n再一次偶遇表哥是在我从县城回老家的路上，简单的聊聊天。表哥和很多没选择继续读书的人一样，后悔当初冲动的选择，表达还是该读书的想法，但我知道这类人还是没能够想明白读书是不受太多条件制约的，感叹那番话只是错误的认为读书是安逸的地方。又或者，这只是他试图逃避当前不好处境的极端的想法，真要是把学校的内容摆在面前，恐怕就会回忆起当初的决定是多么符合自己的心意。于我而言，叶公好龙之举而已。但很遗憾，亦如当初，我只是浅笑以示回应，并没有说出这番带有提醒意味的话。也许，我一直觉得年龄比他小一岁的缘故。","tags":["短篇"],"categories":["article"]},{"title":"男女情感历程发展及其意义","url":"/2024/08/05/男女情感历程发展及其意义/","content":"\n如果不能明确表达对一个人的喜欢，那就不要随意说出来。倒不是讲传递喜欢一个人的信息之后，没过多久另喜她人是多么可耻的事情，而是会让你的话语失去可信度，想必你没有忘记“狼来了”的寓言故事。思想观念的转变更可能是进步的表征，特别是年轻的时候，可这种转变的过程应该放在心里，不管你鼓捣多少次都不为过，但如果一说出口就又收回，就难免被人看不起。接下来，我们谈论的“喜欢”是指那种已经确定不会轻易改变的情感。\n\n我发觉有些错误的观念源于对过去真实情况的遮蔽或者人为强行建立的联系。就拿社会上的感情观来讲，大家默许喜欢一个人就应该以谈恋爱为目的，谈恋爱就应该以结婚为目的。这种潜规则可不会让大家都满意，起码不让我满意。那么，为什么会发展成为这样，自然而然地事情居然堕落成非本来面目？\n\n喜欢一个人需要解释吗？可以有，可麻烦的很，你在思考这个原因的过程就是思考你自己，我建议你把这个机会留在分手之后，因为那时悲伤情绪与困惑将激发你的大脑来寻找问题的解决方案。希望这句话没有任何诅咒的隐义。\n\n为了使喜欢的情感变得更加具体，与对方建立友谊是必要的。如果你不能成为她的朋友，还指望这段关系能够长久吗？从成为朋友开始，你能够真正地了解彼此，喜欢不再是虚无缥缈的情感。不久之后，你可能会发现一个问题，她的异性朋友可能不止你一个，那怕排除这种可能，同性朋友也会影响你与她之间关系的发展。在还未成为恋人之前，异性朋友的优先权低于同性朋友，除非她喜欢你。朋友关系和恋人关系之间有明显的不同，更多的本性可能会暴露，因为距离更近了。如果在恋情中，你没有想要离开她或寻找新对象的想法，那接下来就是让两人的关系得到亲友和社会认可\n\n有一句话流传甚广：不以结婚为目的的恋爱就是流氓。但这样的言论是否道德？恋爱还只是一个选择的过程，你怎么能确定对方就是你要找的那个人，又如何确定对方是否愿意与你共度余生？如果没有足够了解对方，那么你的想法可能不太礼貌。\n\n事实上，从喜欢到恋爱，再到婚姻的过程中，两人的关系变得更加紧密，伴随着更多的道德约束。你要明白失与得就像一对双胞胎兄弟，形影不离。","tags":["亲密关系","零碎之思"],"categories":["article"]},{"title":"非此即彼之外找寻第三条路","url":"/2024/08/05/非此即彼之外找寻第三条路/","content":"\n像我这种悲观的人，一部分源于内心非此即彼的错误观念，遇到矛盾的问题就会选择逃避。逃避问题是解决问题的一种不错的选择吗？是这样的，只要你往后无需再面对这个问题，不去解决也是一种解决。可是亲密关系遭遇此类问题如果不去面对，就进入另一个矛盾中，即为放弃这段关系埋下难以根除的种子。\n\n第三条路，这是对抗看似矛盾的情景可行的思考方式，调动智慧看穿背后本质的非矛盾性。用异地恋的故事进行说明，很好体现第三条路的含义，即满足双方需求。男女双方异地，希望彼此周末能够相处一段时间，又都希望是对方来自己的城市见面，各有合理的理由和未道明的内心话，出现看似不可解决的矛盾。第三条路是什么？二人选择自己所在城市的中间城市为目的地，这样彼此能在周末见面，而且往返的路线得到缩短，就不存在你为何不满足我带来的猜疑引发对亲密关系破坏性极强的信任危机。对待同一个问题，永远不要局限于世界抛给你的选项，每多一个选项就拓宽一份认知，也就是说你得主动去认知，不要懈怠。\n\n前面提到满足这个词，我们总有一个情不自禁的假设，叫做：满足，就等于要别人为我让步。比如说，当我需要安静的时候，怎么才能满足？很多人会自动把它理解为：让别人闭嘴。那么它就会和别人的利益造成冲突，别人也不会配合。那有没有第三条路？你可以把门关上，可以出门去图书馆，你可以用降噪耳塞。有很多种方法可以实现你的需求，不是非得要别人为你让步。也就是说，我会坚持我想要实现的目标，即获得安静，但同时也不去强求别人满足我的需求，更不会去评判对方的所作所为，也就是李松蔚老师提到的对自己的每一个需求做到：不强制，不委屈，不评判。","tags":["亲密关系","零碎之思"],"categories":["article"]},{"title":"性格的一致性和互补性","url":"/2024/08/05/性格的一致性和互补性/","content":"\n曾有一个问题一直令我困扰：一本书告诉我，性格一致的人更容易获得幸福，而另一本书则坚称性格互补的人更快乐。矛盾双方给我带来的折磨激励我思考，并破除表面诱骗众人不解的虚设矛盾，实现思想上的统一，我找到了解决我内心困扰的答案。\n\n就人性而言，我们更倾向于接近那些与我们性格一致的人，这可以归因于\"吸引力三大法则\"：人们倾向于喜欢与自己相似的人、身边的人，以及难以获得的人。冲突的一部分来源于性格和观点的不一致，所以性格上背离的二人之间很难一开始建立亲密的关系。也就是说，我们会更乐意和观点上和性格上一致性强的人建立亲密关系。通过观察，我们会发现人们通常不会深入与那些持续给自己带来负面情绪的人交往，与他们保持距离常常是明智之选。因此，我们的讨论前提是：建立亲密关系的对象通常具有观点和性格上的让人感到舒服的一致性。\n\n然而，这个世界上是否存在精神层面完全相同的人？答案是否定的。即使建立在强烈一致性基础上的亲密关系也不会免于偏差，这是不可避免的事实。冲突意味着关系中可能会出现裂痕，而修复这些裂痕的过程常常令人感到难堪，独处的过程中也带来不好的情绪体验，生活中尽可能避免冲突是正常的心理。所以，现在面临的困境就是因为一致性而建立亲密关系的二人体验到不一致性，而且相处越深发现的越多。这种矛盾源于观点的错误，即冲突不好，对方和我意见不同就是不支持。\n\n首先，我们不应将一致性的强度视为最终目标，因为在面临不可避免的不一致性时，这可能会导致挫折。相反，我们应该学会适应不一致性，以实现互补性。一个很好的比喻是，我们每个人都有缺点，就像我们的后背一样，但在亲密关系中，两个人可以互相扶持，只留下积极的一面展现出来。在这种互补关系中，我们可以不断成长，变得更好。不要因为对方存在不一致之处而产生争吵，相反，可以通过适当的方法将这些不一致之处朝着积极的方向调整，以实现自我提升。此外，不一致性也为关系增加了乐趣和活力，可以让你更丰富地体验生活。","tags":["亲密关系","零碎之思"],"categories":["article"]},{"title":"浅谈AI参与写作","url":"/2024/08/05/浅谈AI参与写作/","content":"\n如果说搜索引擎可以帮我们把可能的答案罗列出来，由用户进行挑选，倒也难免没有自己想要的答案。相比之下，ChatGPT可以根据用户的提问进行理解，直接提供答案，节约时间成本显著。\n\nAI会渐渐地走向各个领域，今天就浅谈AI参与写作这件事情。首先，我持反对态度。如果你让AI写作的话，那请问还有你什么事情？你的身份是什么？除非你并不是要成为一个合格的写作者，不然你就和机器进行身份调换了，你不再是被服务者。我改动太宰治的一句话向你发问：生而为人，你很抱歉？\n\n然而，既然AI是为人类服务的，难道它在写作领域真的是罪恶至极吗？我觉得，AI可以在写作中充当润色的角色。整个作品全部要由你完成，完成之后交给AI润色是完全可以的，它的作用就相当于一个导师帮你提升作品的质量，同时你也没有成为奴隶。\n\n文章的末尾再提及AI提示功能，应用在写作上称为续写。这应用在程序员写代码上提升巨大，工作量得到明显降低，实实在在的事倍功半。但不支持用在写作上，程序员的代码重复度高，跳出的代码更接近于程序员的意图。续写功能却并非如此，而且推荐的内容无法兼顾上下文，影响到写作者的创造思路，借此反驳以此为由说续写功能能够给予作者灵感的乐观看法。\n\n无论是写作还是编写代码，初学者都不应过早依赖AI。我的建议是，像这种需要时间积累的技能，不要轻易让别人代劳。","tags":["零碎之思"],"categories":["article"]},{"title":"大学毕业","url":"/2024/06/21/大学毕业/","content":"\n大学毕业是和学生时代彻底告别\n\n![091138AF9551798EF736F25216376B06.jpg](/images/2024/08/05/86691200-52f6-11ef-a753-f7b4ec4e347a.jpg)","tags":["杂文"],"categories":["various"]}]
[{"title":"欧绪弗洛篇","url":"/2024/08/18/欧绪弗洛篇/","content":"\n因为欧绪弗洛自称有关神的知识如此精确，懂得什么是虔敬，什么是亵渎，苏格拉底于是向他求教，希望他从本质上讲清楚什么是虔敬，什么是亵渎。欧绪弗洛回答道：“凡是诸神喜爱的就是虔敬的，凡是诸神不喜爱的就是亵渎的”。但是，对相同的事物诸神有各自的判断，那么意见不统一的情况下，欧绪弗洛的回答就有问题了。于是，欧绪弗洛修正自己的观点为“虔敬就是诸神所喜爱的，亵渎就是诸神所痛恨的”。\n\n然而，欧绪弗洛并没有回答出虔敬和亵渎的本质，哪怕直到文章的结束。因为虔敬和亵渎的本质与诸神是否喜爱无关，这是欧绪弗洛没有弄明白的地方。\n","tags":["柏拉图","柏拉图中短篇全集"],"categories":["article"]},{"title":"捭阖第一","url":"/2024/08/18/捭阖第一/","content":"\n本篇内容由两部分组成。前半部分言捭阖之原理，又可分为三层：即捭阖之定义，捭阖之术用于游说之原理及捭阖之术如何运用。后半部分言捭阖之术在游说中如何具体运用。\n\n本篇提出“捭”就是“开”，主要是针对对方而言，让对方“开”，暴露真实意图，从而为我所利用；“阖”则是针对己方而言，己方要“合”，要密而自保；这是运用捭阖之术的总原则。捭阖之术可用于游说。口开即阳，口默即阴。自己或以阴结阳，让对方夸夸其谈；自己或以阳求阴，以谈辩之锋逼对方哑口无言。如何为之，应伺机而动，因时而应，此即为“说人之法”。\n\n```tex\n变化无穷，各有所归 ，或阴或阳，或柔或刚，或开或闭，或弛或张\n\n万事万物的变化虽然是无穷无尽的，但是都以避亡趋存作为它们的归宿。有的表现为阴，有的表现为阳；有的表现为柔，有的表现为刚；有的表现为开，有的表现为闭；有的表现为弛，有的表现为张\n```\n\n## 如何了解对方的实际情况？\n\n顺应每个人的特点来驾驭他。如果要弄清对方是有还是无，搞清对方的实际情况，一般情况下，是**顺着他的爱好和欲望来推测出对方心里的真实意图**。可以暗暗排查对方言辞，然后依据已知情况反问过去，以得其实情，了解到他的旨意；先“阖”后“捭”，从中得到利益。\n\n或公开自己的真实情况显示给对方，或不公开自己的真实情况而将它隐藏起来，不让对方知道。当己方的实际情况或目的等与对方完全相同的时候，就可以公开显示给对方看；当己方的实际情况或目的等与对方不同的时候，就不能公开。如果要用“捭”的方式，一定要做到周到；如果要用“阖”的方式，一定要做到严密。周到、严密还要注意隐蔽，**隐蔽的最佳效果就像“道”一样微而不显**。\n\n## 只有开口才有实话的可能\n\n用捭使对方开，而对其虚实进行辨别；辨别清楚之后用阖，确定下来对方的实情。圣人都是根据对方实际需要的轻重缓急来揣度对方的所想，然后再顺其所想而为对方作出谋划。圣人即因势考虑，如果不合对方的心意或其实际所需，就替自己作谋划，留好退路。\n\n所以用捭或能使对方开而真实情况暴露出来，或能让对方开而使己方的观点被接纳；用阖或能使己方有所获取，或能使己方顺利地躲过祸患。\n\n## 如何进行游说？\n\n把凡是有关长生、安乐、富贵、尊荣、显名、爱好、财利、得意、喜欲的，都视作“阳”，称为“始”。把凡是有关死亡、忧患、贫贱、苦辱、弃损、亡利、失意、有害、刑戮、诛罚的，都视作“阴”，称为“终”。那些在言谈时采用“阳”一类的事情来立说的，我们都可以称之为“始”，因为他们是**从事情好的一面来进行游说，劝诱对方开始行动，促成游说得到成功**；那些在言谈时采用“阴”一类的事情来立说的，我们都可以称之为“终”，因为他们是**从事情恶的一面来进行游说，阻止对方的谋略策划实施，使它终止行动**。\n\n捭阖之道，就是反复地使用阴阳进行试探。所以与品行高尚的人言说，就要说“阳”类的事；与品行卑劣的人言说，就要说“阴”类的事。下与小，均为阴，故可以用低下的去求合志向渺小的人；高与大，均为阳，故可以用高尚的去求合志趣高远的人。","tags":["鬼谷子"],"categories":["article"]},{"title":"局限性","url":"/2024/08/17/局限性/","content":"\n我们将局限分为两类：可改变的局限和不可改变的局限。不管是哪种局限皆需要建立正确的看待方式，比方说不可改变局限中的天生残疾和容貌焦虑以及可改变局限中的认知局限。\n\n## 发现我们的认知局限，可以帮助我们提升向外兼容度\n\n阿伽门农一家三口的悲剧：父献女、妻弑夫、子杀母。这里存在一个人类古老的困境，即每个人皆认为自己手握正义和真理，但我们每个人都有自己的认知盲区。特别是**从某个特定角度去看待问题，会看到一部分真实，而另一部分的真实会被忽视掉**。古希腊贤哲之间会通过辩论来避免，辩论的目的不是输赢，而是为了看到对方眼中的真实，来弥补自身的认知局限。\n\n无法容纳别人的优点和长处，是等级制度带来的攀比思维。通常产生攀比心理的个体与被选作为参照的个体之间往往具有极大的相似性，导致自身被尊重的需要过分夸大，虚荣动机增强，甚至产生极端的心理障碍和行为。**正确的“攀比思维”是见贤思齐**，即优秀的人出现在身边，意味着优质的学习资源出现，只要你肯积极主动向他学习，也就实现共同进步带来的利益最大化了。\n\n## 发现我们自身能力和条件局限，可以帮助我们提升向内兼容度\n\n没有好不好，只有合适不合适。这是因为每个人都有自己的能力薄弱点，这不是羞耻，而看见自己身上的薄弱点很明智。\n\n社会存在很多看似正确的错误规训，往往就是把我们的弱势变成我们的耻辱，甚至变成我们的罪名。这就需要建立强大的免疫对抗系统，来防止用别人错误的观点伤害到自己。在那些惯常的看似正确的行为背后，反而隐藏着很多的不正常。\n\n人生的原点是不一样的，意味着我们的成长背景和资源是不一样的。人和人不同，意味着我们彼此的能力特点和条件也不同。在这些不同的前提下，跟别人横向比较，赢只是一种没有意义的虚荣，输只是一种毫无意义的精神自虐。除了说明我们不懂得爱自己，没有能力给自己一份正义，其他什么都说明不了。横向比较经常是用别人的尺子来丈量自己，用别人的图纸来建自己的房子。你追求的是别人的样子，成为的也是别人，而非你自己。","tags":["杜素娟","自我"],"categories":["article"]},{"title":"高质量伴侣","url":"/2024/08/17/高质量伴侣/","content":"\n爱情婚姻很难脱离现实，不可能做到只是一场风花雪月的事。在残酷的现实中，人们缺什么，往往会把缺乏的内容投射到婚恋的择偶目标之中。如果体谅人类生存的这些局限，人们如何理解高质量伴侣之间存在差异也就不难理解了。\n\n基于精神需求层面的亲密关系的理解来谈一谈什么才是高质量的亲密关系呢？\n\n- 在精神层面不消耗你\n- 在资源和能量上不消耗你\n\n归根结底，高质量的伴侣关系必然是双向付出，低质量的伴侣关系必然是单向或双向的消耗。双向付出看似是互相抵消，但是一来一回这个过程的价值便是对高质量的伴侣关系的赠予。\n\n> 在这个人面前，你知道对方知道你的不完美，但你也知道，你依然是对方心中最珍贵的、最不可替代的存在。\n>\n> 某一方在单方面输出资源和能量，甚至是某一方在不断地向下兼容，这个亲密关系其实是隐患重重的。\n>\n> 好的伴侣一定是比翼齐飞，而不是某一方变成了另一方的燃料或是垫脚石\n>\n> 人性的基本规律是我们只会被自己所欣赏的人所吸引，我们只会被对自己有价值和意义的人所吸引。","tags":["亲密关系","杜素娟"],"categories":["article"]},{"title":"边界感","url":"/2024/08/17/边界感/","content":"\n没有边界感带来的两种隐患，即失守和越界。\n\n失守：没有守好自己的边界，随便把被人放进自己的领地来。\n\n越界：随意踏越别人的领地。\n\n- **空间边界**：包括个人空间、隐私和物理距离。例如，不经允许进入别人的房间或随意翻看别人的物品\n- **时间边界**：指的是对时间的管理和分配。例如，不尊重别人的时间安排，随意打扰别人的工作或休息时间\n- **资源边界**：包括金钱、物品和信息。例如，未经允许使用别人的物品或占用别人的资源\n- **情感边界**：涉及个人情感和情绪的界限。例如，不尊重别人的情感需求或强迫别人接受自己的情感\n- **情绪边界**：指的是对情绪的管理和表达。例如，把自己的情绪强加给别人，或者不顾别人的情绪感受\n- **行为边界**：包括个人行为和习惯。例如，强迫别人接受自己的行为方式或干涉别人的行为选择\n- **选择边界**：涉及个人选择和决策。例如，不尊重别人的选择和决定，试图替别人做决定\n- **评价边界**：指的是对别人的评价和意见。例如，随意评判别人的行为或生活方式\n\n面对自己的边界不失守，面对他人的边界不越界。","tags":["杜素娟","自我"],"categories":["article"]},{"title":"克里托篇","url":"/2024/08/17/克里托篇/","content":"\n## 克里托为什么要帮助苏格拉底？\n\n1. 不愿失去一位无法替代的朋友\n2. 如果苏格拉底没有被救助，那么外人会以为克里托重钱财轻朋友，实在不想背负这个骂名\n\n第二个理由会让人觉得克里托是为了自己的名声才来救助苏格拉底，但他完全可以选择不说出这个理由，而他说出来的目的就是告诉苏格拉底，你如果不逃狱，我和那些本来能够帮助你的朋友和亲人将获得不好的名声。克里托企图唤醒苏格拉底的愧疚，这种谈话方式克里托后面还会继续使用。\n\n## 苏格拉底驳支持众人意味着正确\n\n> 克里托：大多数人不会相信，尽管我们全力督促你离开此地，是你自己拒绝了。\n\n前面讲克里托企图唤醒苏格拉底的愧疚，但苏格拉底本意是拒绝逃狱，而是支持法官的判决，哪怕这个判决是错误的。因此，苏格拉底要驳斥支持众人意味着正确的观点来打消克里托的顾虑。\n\n克里托觉得苏格拉底不愿逃狱是因为心中还有顾忌：\n\n1. 担心离开，朋友和家人会遇到麻烦，如财产没收或赔付巨款\n2. 贿赂执法人员的钱财不够\n3. 离开雅典，会感受不适应\n\n于是，克里托逐一打消这些顾虑：\n\n1. 冒险救你是正当的\n2. 还有外邦人愿意支持，钱财足够\n3. 在其它地方，你同样是受欢迎，而且那些地方有我的朋友\n\n克里托接着用惯用的手法，来让苏格拉底意识到，如果不逃狱，你身边的人都会受到影响。\n\n> 另外，苏格拉底，我认为你的做法是不公正的，在能够得救的时候放弃自己的生命，像你的敌人一样加快你的命运进程，如他们所愿加速毁掉你自己。更有甚者，我认为你辜负了你的儿子，在能够抚养和教育他们的时候，你却要离开和抛弃他们。这样做，表明你不关心他们的命运。他们将来的命运可能就是孤儿的命运。要么不要孩子，要么就与他们在一起，精心抚养和教育他们。在我看来你似乎选择了一条最轻松的道路，而我认为你应当像一名善良、勇敢的人那样去选择，尤其是一个自称要终身关注德性的人。\n>\n> 我感到羞耻，既为你，也为我们这些朋友，省得你碰上的所有事情都被人归因于我们一方的胆怯；你上法庭去接受审判，这样做其实没有必要，而现在这个荒唐的结果会被人认为，由于我们一方胆小怕事，事情失控了，在我们有可能救你、也能够救你的时候，我们没能救你，或者说你没能救你自己，哪怕说我们还有一丁点儿用处。想一想吧，苏格拉底，这样做不仅是邪恶，而且是羞耻，既对你，也对我们。你仔细想一想吧，或者说，考虑的时间已经过了，现在到了该下决心的时候了，以后不会再有机会了，整件事今晚必须完成。如果我们再拖延，那就不可能了，就太迟了。让我用各种理由来说服你，苏格拉底，听我的话，不要再固执了。\n\n克里托讲完，苏格拉底说自己只接受正义的建议，希望克里托能和自己讨论该不该逃狱的问题。\n\n苏格拉底需要驳斥克里托最初的观点，驳斥逻辑如下：\n\n- 一个人要尊重好意见，而不是坏意见\n- 好意见就是聪明人的意见，坏意见就是愚蠢人的意见\n- 专家的意见是好的，应该听从专家的意见\n\n所以我们不应当过多地考虑大多数人会怎么说我们，而应当考虑那个懂得正义和不义的人会说些什么，这个人就是真理本身。在这个世上，能静下心来思考的人并不多，能深入思考的就更少了。大部分人的观点都不重要，只不过是它人观点的转述，只要听起来合理或合乎自己的利益就收纳过来，一传十，十传百，相信的人也就会越来越多。\n\n![墙头草.png](/images/2024/08/17/2d2daab0-5c3e-11ef-a3ac-cb9da6ad142e.png)\n\n## 苏格拉底为什么不选择逃狱？\n\n苏格拉底决意向克里托说明为什么不可以逃狱，但在此之前需要先确定几个观点：\n\n1. 不能以恶报恶\n2. 应当履行公正的协议\n\n在没有受到法律的制裁之前，我始终受到法律的恩惠，即法律对那些恶人进行的判决，让城邦的和平得以继续维持。城邦的人之所以被法律所保护，是因为大家共同和法律签订了协议；城邦的人之所以能够被法律制裁，也是因为大家共同和法律签订了协议。现如今，法律对我判处死刑，如果违背法律，那就是没有履行公正的协议。如果这个判决是错误的，我同样不能违背法律的判决，否则就是以恶报恶。看来，违背法律的判决与之前正确的观点相违背，所以不可以逃狱。\n\n## 苏格拉底意欲何为？\n\n苏格拉底如果讲这番话的目的是为了说服那些被误判的人接收法律的制裁，那他就是在痴心妄想，没有任何一个人能够接收被污蔑，并且受到身体的伤害而不反抗。苏格拉底维护法律的判决是以死明志，志为维护法律的不可侵犯性。他认为错误不在法律，而是在执行法律的人，法律本身是正义的。\n\n我想苏格拉底似乎没有弄清楚一个事实，正确的观点要看在怎样的场景下运用才能发挥正确性。如果我没有做任何不正义的事情，一个法官就对我执行判决，说我恶意杀人当判有期徒刑 5 年，这是不可理喻的。首先，恶意杀人判处有期徒刑 5 年是正义的，但是将其放在一个没有犯此法的人身上就是不正义的，难道苏格拉底你要支持不正义的行为吗？\n\n谁让内心真实的想法不可能说服克里托呢，不然也不必大费周章讲这么多与本意无关的话。","tags":["柏拉图","柏拉图中短篇全集"],"categories":["article"]},{"title":"理想国第一卷：苏格拉底与色拉叙马霍斯的对话","url":"/2024/08/16/理想国第一卷：苏格拉底与色拉叙马霍斯的对话/","content":"\n> 色：苏格拉底，你们见了什么鬼，你吹我捧，搅的什么玩意儿？如果你真是要晓得什么是正义，就不该光是提问题，再以驳倒人家的回答来逞能。你才精哩！你知道提问题总比回答容易。你应该自己来回答，你认为什么是正义。别胡扯什么正义是一种责任、一种权宜之计，或者利益好处，或者什么报酬利润之类的话。你得直截了当地说，你到底指的是什么。\n\n还是不要看色拉叙马霍斯和苏格拉底之间的争论了，但色拉叙马霍斯的攻击性确实很强，好在苏格拉底轻松应对。现在我们可以确定的是，苏格拉底需要正面回答正义是什么。\n\n只是我不知道为什么色拉叙马霍斯把话头给到自己了，明明他要让苏格拉底不要再提问了，因为提问总比回答容易。我想色拉叙马霍斯还是太急于表达，就如文中介绍“当我们正谈话的时候，色拉叙马霍斯几次三番想插进来辩论，都让旁边的人给拦住了，因为他们急于要听出个究竟来。等我讲完了上面那些话稍一停顿的时候，他再也忍不住了，他抖擞精神，一个箭步冲上来，好像一只野兽要把我们一口吞掉似的，吓得我和玻勒马霍斯手足无措。”\n\n> 色：那么，听着！我说正义不是别的，就是强者的利益。——你干吗不拍手叫好？当然你是不愿意的啰\n>\n> 苏：我先得明白你的意思，才能表态。可这会儿我还闹不明白。你说对强者有利就是正义。色拉叙马霍斯啊！你这到底说的是什么意思？总不是这个意思吧：因为浦吕达马斯是运动员，比我们大伙儿都强，顿顿吃牛肉对他的身体有好处，所以正义；而我们这些身体弱的人吃牛肉虽然也有好处，但是就不正义？\n>\n> 色：你真坏！苏格拉底，你成心把水搅混，使这个辩论受到最大的损害。\n>\n> 苏：绝没有这意思。我的先生，我不过请你把你的意思交代清楚些罢了。\n>\n> 色：难道你不晓得统治各个国家的人有的是独裁者，有的是平民，有的是贵族吗？\n>\n> 苏：怎么不知道？\n>\n> 色：政府是每一城邦的统治者，是不是？\n>\n> 苏：是的。\n>\n> 色：难道不是谁强谁统治吗？每一种统治者都制定对自己有利的法律，平民政府制定民主法律，独裁政府制定独裁法律，依此类推。他们制定了法律明告大家：凡是对政府有利的对百姓就是正义的；谁不遵守，他就有违法之罪，又有不正义之名。因此，我的意思是，在任何国家里，所谓正义就是当时政府的利益。政府当然有权，所以唯一合理的结论应该说：不管在什么地方，正义就是强者的利益。\n>\n> 苏：现在我明白你的意思了。这个意思对不对，我要来研究。色拉叙马霍斯，你自己刚才说，正义是利益，可是你又不准我这么说。固然，你在“利益”前面加上了“强者的”这么个条件。\n>\n> 色：这恐怕是一个无足轻重的条件。\n>\n> 苏：重要不重要现在还难说。但是明摆着我们应该考虑你说得对不对。须知，说正义是利益，我也赞成。不过，你给加上了“强者的”这个条件，我就不明白了，所以得好好想想。\n>\n> 色：尽管想吧！\n\n色拉叙马霍斯说：“正义不是别的，就是强者的利益。”\n\n首先苏格拉底最初的举例来明确色拉叙马霍斯的含义是没说错的，只是色拉叙马霍斯依旧选择反驳。不管怎样，色拉叙马霍斯选择换个例子，但是含义却没有变化。后面苏格拉底就追问，这个追问是想探讨出正义的本质是什么，可是色拉叙马霍斯明显谈的是现实中的正义是什么样子。二人从此刻已经分道扬镳，完全不在一个语言环境下。\n\n你会觉得色拉叙马霍斯说的正确，但你听苏格拉底一番言论之后也觉得没错。色拉叙马霍斯讲的是现实中的正义，你眼中的世界就是这样，符合经验的事情总是容易轻易得到支持。但是你对这份正义并不满意。不单是现实中的正义是理想中的正义的偏离，更因为强者必然引出弱者，那就说明总有人没有从中受益。\n\n如果你觉得色拉叙马霍斯的观点正确，可你又不是其中的受益者，那你必然适合做奴隶，因为你连争取自己的利益的想法都没有。而你所谓的正确居然就是你眼中所看到的，看来还蠢得厉害。理想无法实现，现实又处处与我为难。要么就去成为强者，利益就偏向于我。要么臣服于现实的残酷，不去招惹强者即可，至少能让利益少被搜刮些。如果此刻我说“我们每个人心中都要心怀正义，对于弱者应该多加照顾，博爱才是世间大道，唯有真理永恒不变”，你却是要说我像个疯子了。可我不过是把现实中的话语体系和理想中的话语体系都说出来了而已。\n\n我们现在要能够区分讲话者究竟是在描述现实，还是在描述理想。追求理想是为了让心中常善，接受现实是不让理想被误解。如果法律不追求绝对的正义，那么法律就不再正义。如果男女不追求爱情，那么遍地是演员了。\n\n> 色：因为在你想象中牧羊或牧牛的人把牛羊喂得又肥又壮是为牛羊的利益，而不是为他们自己或者他们主人的利益。你更以为各国的统治者当他们真正是统治者的时候，并不把自己的人民当作上面所说的牛羊；你并不认为他们日夜操心，是专为他们自己的利益。你离了解正义不正义，正义的人和不正义的人简直还差十万八千里。因为你居然不了解：正义也好，正义的人也好，反正谁是强者，谁统治，它就为谁效劳，而不是为那些吃苦受罪的老百姓，和受使唤的人效劳。不正义正相反，专为管束那些老实正义的好人。老百姓给当官的效劳，用自己的效劳来使当官的快活，他们自己却一无所得。头脑简单的苏格拉底啊，难道你不该好好想想吗？正义的人跟不正义的人相比，总是处处吃亏。先拿做生意来说吧。正义者和不正义者合伙经营，到分红的时候，从来没见过正义的人多分到一点，他总是少分到一点。再看办公事吧。交税的时候，两个人收入相等，总是正义的人交得多，不正义的人交得少。等到有钱可拿，总是正义的人分文不得，不正义的人来个一扫而空。要是担任了公职，正义的人就算没有别的损失，他自己私人的事业也会因为无暇顾及，而弄得一团糟。他因为正义不肯损公肥私，也得罪亲朋好友，不肯为他们徇私情干坏事。而不正义的人恰好处处相反。我现在要讲的就是刚才所说的那种有本事捞大油水的人。你如愿弄明白，对于个人不正义比起正义来是多么的有利这一点，你就去想想这种人。如果举极端的例子，你就更容易明白了：最不正义的人就是最快乐的人；不愿意为非作歹的人也就是最吃亏苦恼的人。极端的不正义就是大窃国者的暴政，把别人的东西，不论是神圣的还是普通人的，是公家的还是私人的，肆无忌惮巧取豪夺。平常人犯了错误，查出来以后，不但要受罚，而且名誉扫地，被人家认为大逆不道，当作强盗、拐子、诈骗犯、扒手。但是那些不仅掠夺人民的钱财，而且剥夺人民的身体和自由的人，不但没有恶名，反而被认为有福。受他们统治的人是这么说，所有听到他们干那些不正义勾当的人也是这么说。一般人之所以谴责不正义，并不是怕做不正义的事，而是怕吃不正义的亏。所以，苏格拉底，不正义的事只要干得大，是比正义更有力、更如意、更气派。所以像我一上来就说的：正义是为强者的利益服务的，而不正义对一个人自己有好处、有利益。\n\n色拉叙马霍斯对现实的观察真是太精准。这么多年过去了，世界依旧如此，《理想国》不愧为理想二字。\n\n> 苏：我们因此可以说匠人之得到报酬，是从他们在运用了自己特有的技术以外又运用了一种挣钱之术而得来的。\n>\n> 〔色拉叙马霍斯勉强同意。〕\n>\n> 苏：既然得到报酬的这种利益，并不是来自他本职的技术，严格地讲，就是：医术产生健康，而挣钱之术产生了报酬，其他各行各业莫不如此，——每种技艺尽其本职，使受照管的对象得到利益。但是如果匠人得不到报酬，他能从自己的本职技术得到利益吗？\n>\n> 色：看来不能。\n>\n> 苏：那么工作而得不到报酬，那对他自己不是确实没有利益吗？\n>\n> 色：的确没有利益。\n\n看得出苏格拉底是在探求本质，这是认识世界本源的方式，很多事物的本源在历史中掩盖。医生医治病人这个技艺本身并不会带来钱财，救人和钱财没有直接联系，只是救人得到钱财能够维持自身和家庭的生存，能激发更多人学习这份技艺。如果救人是善，那么善就在利益的绑定下得到扩张。我们从来不是不满于行善之后的适当利益，而是不满于医生心中为了利益而忘了救人才是本质。理想情况是行善而不求回报，但我们考虑到现实层面还是认可行善之后的适当利益已是善的彰显。而为了利益而忘了救人是不可能成立的，荒谬的事情必然会发生，但是必然不可能被允许存在。故而现实情况是救人依旧还在，但是利益的设定值存在相当大的泡沫，且不为外行所见。你要让我说关于医生最离谱的事情，那就是药房买药更多优惠更多的活动。以及救治病人只需一种药物，但为了利益却安排多种新药物来剥取病人的更多的钱财，因为新药物会给更多的广告费，药房的人自然优先给病人推送这种产品。\n\n\n\n关于他们的谈话就论述至此，后面还是一部分他们的讨论，但已无记录的必要。\n\n最后记录一下知乎某人的回答，其实和我前面所讲并无差别，只不过他的表述更为专业。\n\n> 因为两者对于真的定义是不一样。\n>\n> 柏拉图那里指的是，事实符合概念。比如说牧羊人的概念要求所谓的真，就是牧羊，而不是别的什么东西。因此他是目的论，以及偏向于应然\n>\n> 但是色拉叙马霍斯对于真的定义则是概念要符合事实。他是通过经验观察获得概念的内涵，偏向于实然。\n>\n> 正因为两者的这种差异，所以两者弄不到一块","tags":["柏拉图","理想国"],"categories":["article"]},{"title":"理想国第一卷：苏格拉底与玻勒马霍斯的对话","url":"/2024/08/16/理想国第一卷：苏格拉底与玻勒马霍斯的对话/","content":"\n> 苏：什么是烹调术所给的恰如其分的报答？给予什么人？给的什么东西？\n>\n> 玻：把美味给予食物。\n>\n> 苏：那么，什么是正义所给的恰如其分的报答呢？给予什么人？\n>\n> 玻：苏格拉底，假如我们说话要前后一致，那么，正义就是“把善给予友人，把恶给予敌人”。\n\n后面苏格拉底和玻勒马霍斯继续辩论，这个过程中苏格拉底引导玻勒马霍斯肯定两个观点：\n\n1. 其他有用正义就无用，其他无用正义就有用了\n2. 正义之人亦是熟悉如何不正义\n\n玻勒马霍斯坦白被弄得晕头转向，不顾之前肯定的观点，再次声明“我终归认为帮助朋友，伤害敌人是正义的”。\n\n> 玻：我们应该说朋友不是仅看起来可靠的人，而是真正可靠的人。看起来好，并不真正好的人只能当作外表上的朋友，不算作真朋友。关于敌人，理亦如此。\n>\n> 苏：照这个道理说来，好人才是朋友，坏人才是敌人。\n>\n> 玻：是的。\n>\n> 苏：我们原先说的以善报友，以恶报敌是正义。讲到这里我们是不是还得加上一条，即，假使朋友真是好人，当待之以善，假如敌人真是坏人，当待之以恶，这才算是正义？\n>\n> 玻：当然。我觉得这样才成为一个很好的定义。\n\n经过苏格拉底的追问，玻勒马霍斯觉得之前的观点确有不合理之处。因为朋友不一定都是好的，敌人也不一定都是坏的。当前玻勒马霍斯的观点是“假使朋友真是好人，当待之以善，假如敌人真是坏人，当待之以恶，这才算是正义”。\n\n辩论的意义不是为了输赢，而是为了接近真理。如果一个问题没有经过大脑长期而周密的思考，就进入到辩论中，不可避免地出现不恰当的语言表述。通过细问和反驳来修正原先观点的不恰当性，让此次辩论得以顺利且有意义的进行下去。如果辩论就是死守某句话和某个观点，而不能及时给予修正，那这场辩论哪还有继续进行下去的价值呢？\n\n> 苏：正义的人不是好人吗？\n>\n> 玻：当然是好人。\n>\n> 苏：玻勒马霍斯啊！伤害朋友或任何人不是正义者的功能，而是和正义者相反的人的功能，是不正义者的功能。\n>\n> 玻：苏格拉底，你的理由看来很充分。\n>\n> 苏：如果有人说，正义就是还债，而所谓“还债”就是伤害他的敌人，帮助他的朋友。那么，我认为说这些话的人不可能算是聪明人。因为我们已经摆明，伤害任何人无论如何总是不正义的。\n>\n> 玻：我同意。\n\n在苏格拉底持续追问之下，玻勒马霍斯赞成最新的观点：“正义的人不可能做出不正义的事，那是不正义者的功能。”\n\n至此，玻勒马霍斯最初的观点就被驳斥了，即“正义就是助友害敌。”","tags":["柏拉图","理想国"],"categories":["article"]},{"title":"理想国第一卷：苏格拉底与克法洛斯的对话","url":"/2024/08/16/理想国第一卷：苏格拉底与克法洛斯的对话/","content":"\n> 克法洛斯：我要告诉你，随着对肉体上的享受要求减退下来，我爱上了机智的清谈，而且越来越喜爱。我可是真的求你多上这儿来，拿这里当自己家一样，跟这些年轻人交游，结成好友。\n\n如果一个人说他不再喜欢什么，含义就是他曾经对此注入过不少的精力。克法洛斯对肉体的享受需求减退（性欲），看来还没有完全丢弃，可能想着精力充沛的时候再现当年风流。他还爱上了机智的清谈，这在后面会被他自行推翻，但这句话也能看出此前他是不喜欢清谈的，年轻的时候他在苦心积虑如何赚更多的钱财，哪怕不择手段。\n\n> 苏格拉底：说真的，克法洛斯，我喜欢跟你们上了年纪的人谈话。我把你们看作经过了漫长的人生旅途的老旅客。这条路，我们多半不久也是得踏上的，我应该请教你们：这条路是崎岖坎坷的呢，还是一条康庄坦途呢？克法洛斯，您的年纪已经跨进了诗人所谓的“老年之门”，究竟晚境是痛苦呢还是怎么样？\n>\n> 克法洛斯：上了年纪的确使人心平气和，宁静寡欲。到了清心寡欲，弦不再绷得那么紧的时候，这境界真像索福克勒斯所说的，像是摆脱了一帮子穷凶极恶的奴隶主的羁绊似的。苏格拉底，上面所说的许多痛苦，包括亲人朋友的种种不满，其原因只有一个，不在于人的年老，而在于人的性格。如果他们是大大方方，心平气和的人，年老对他们称不上是太大的痛苦。要不然的话，年轻轻的照样少不了烦恼\n\n克法洛斯声称自己喜欢清谈，苏格拉底就抛出一个问题，即已至晚年的克法洛斯对生活是怎样的感受？\n\n克法洛斯的看法是无关年纪，而取决于人的性格或境界。只要心态好，生活也会更好。可这种话也就家财万贯的人能去讲，生活贫困的人还被困在温饱问题之中，心态好可解决不了这些。\n\n> 苏格拉底：亲爱的克法洛斯，我想，一般人是不会以你的话为然的。他们会认为你觉得老有老福，并不是因为你的性格，而是因为你家财万贯。他们会说“人有了钱当然有许多安慰”\n>\n> 克法洛斯：一个好人，同时忍受贫困、老年，固然不容易，但是一个坏人虽然有钱，到了老年其内心也是得不到满足和宁静的\n\n克法洛斯的这个回复很有意思，他否定有钱就能晚年快乐的观点，这点他没有说谎，因为他现在正在受苦，受他幻想出来的死后面临的地狱之苦。所以，后面说“一个坏人虽然有钱，到了老年其内心也是得不到满足和宁静的”讲的就是他自己当前的处境。\n\n> 苏格拉底：真的，我还要向您讨教一个问题。据您看有了万贯家财最大的好处是什么？\n>\n> 克法洛斯：当一个人想到自己不久要死的时候，就会有一种从来不曾有过的害怕缠住他。关于地狱的种种传说，以及在阳世作恶，死了到阴间要受报应的故事，以前听了当作无稽之谈，现在想起来开始感到不安了——说不定这些都是真的呢！不管是因为年老体弱，还是因为想到自己一步步逼近另一个世界了，他把这些情景都看得更加清楚了，满腹恐惧和疑虑。他开始扪心自问，有没有在什么地方害过什么人？如果他发现自己这一辈子造孽不少，夜里常常会像小孩一样从梦中吓醒，无限恐怖。我并不是说每一个人都是这样，我是说对于一个通情达理的人来说，有了钱财他就用不着存心作假或不得已而骗人了。当他要到另一世界去的时候，他也就用不着为亏欠了神的祭品和人的债务而心惊胆战了。在我看来，有钱固然有种种好处，但比较起来，对于一个明白事理的人来说，我上面所讲的好处才是他最大的好处。\n\n克法洛斯已经暴露自己年轻时的种种恶行，现在他开始祭祀和行善也并非弥补和悔过，而是怕入地狱受苦。\n\n说到底克法洛斯只是描述自己的经历，并没有反省过自己的生活。所谓是未经审视的生活是不值得过的。\n\n> 苏格拉底：克法洛斯，您说得妙极了。不过讲到“正义”嘛，究竟正义是什么呢？难道仅仅有话实说，有债照还就算正义吗？这样做会不会有时是正义的，而有时却不是正义的呢？打个比方吧！譬如说，你有个朋友在头脑清楚的时候，曾经把武器交给你；假如后来他疯了，再跟你要回去；任何人都会说不能还给他。如果竟还给了他，那倒是不正义的。把整个真情实况告诉疯子也是不正义的。\n\n关于苏格拉底和克法洛斯的对谈已经结束，前面克法洛斯讲到地狱暗示自己年轻时很多的不正义的行为，苏格拉底在这里引出了正义的话题，这个话题就是后面苏格拉底和其他人的对话了。\n\n克法洛斯至此不会再出现了，我们从他年轻的经历中看到色欲和钱财，到晚年倒还显得虔诚和喜欢清谈了，只可惜他并没有改变，而是一如既往地为自己寻求利益。","tags":["柏拉图","理想国"],"categories":["article"]},{"title":"第四章：以旧函数创建新函数","url":"/2024/08/16/第四章：以旧函数创建新函数/","content":"\n**注意**：此文介绍很多[C++11新特性](https://xiaoyangst.github.io/tags/C-11%E6%96%B0%E7%89%B9%E6%80%A7/)的知识（bind绑定器），这不会在此读书笔记中记录，可以在我的其它地方找到相关的笔记，或者你可以自行去学习，毕竟，C++11 是现在 C++ 学习者必备的语法。\n\n## 偏函数的应用\n\n这种通过把已知函数的一个或多个参数设定为特定值的方法创建新函数的概念称为偏函数应用。偏的意思是在计算函数结果时，只需传递部分参数，而不需要传递所有参数。\n\n函数 std::bind1st 和 std::bind2nd 在 C++17中已经删除，C++11也不推荐使用，因为它们可以被更加通用的 std::bind 取代。std::bind 不再局限于二元函数，而是可用于任意数目参数的函数。也不限制用户指定绑定哪些参数，可以以任意顺序绑定任意数目的参数，而留下不需绑定的参数。\n\n还有提及的地方是 如何把 bind 绑定的函数 转化成用 Lambda 表示，示意图如下：\n\n![bind转lambda.png](/images/2024/08/16/5ebb8440-5bcf-11ef-a253-abb20d863bc2.png)\n\n## 柯里化\n\n柯里化的基本思想是将一个接受多个参数的函数转换为一系列只接受单个参数的函数的过程。换句话说，柯里化将一个多元函数（接受多个参数的函数）转换为一个嵌套的一元函数（每个只接受一个参数的函数）。\n\n```c++\nf(x, y, z)  # 原函数\n\n# 柯里化后的函数\nf(x)(y)(z)\n```\n\n在这个过程中，`f(x)` 返回一个新的函数，这个新函数接受参数 y，并返回另一个新的函数，这个函数接受参数 z 并返回最终结果。\n\n```c++\n#include <iostream>\n#include <functional>\n\nauto add = [](int a) {\n    return [a](int b) {\n        return [a, b](int c) {\n            return a + b + c;\n        };\n    };\n};\n\nint main() {\n    std::cout << add(1)(2)(3) << std::endl; // 输出 6\n    return 0;\n}\n```\n\n## 偏函数与柯里化\n\n正如读者看到的，虽然十分类似，但柯里化和偏函数应用各有优缺点，而且都有自己适用的场合。当有一个要绑定其参数的特定函数时，偏函数比较有用。在这种情况下，知道函数有几个参数，可以确切地选择哪些参数要绑定到特定的值。当函数可以有任意多个参数时，柯里化对这种通用情况十分有用。在这种情况下，std::bind 就没有用武之地了，因为既然不知道函数有几个参数，也就不知道有几个参数需要绑定到占位符，甚至不知道需要多少个占位符。\n\n## 函数组合\n\n作者通过一个单词统计列表的故事讲函数的组合，因为即每个函数自有其功能，并且该函数返回处理的结果，这些结果继续传递到下一个函数，直到完成自己的需求。\n\n![单词统计.png](/images/2024/08/16/58749d10-5bcf-11ef-a253-abb20d863bc2.png)\n\n## 函数提升\n\n在第一章接触了提升的概念，这里展开一下。一般来说，提升是种编程模式，它提供了一种方式，把给定的函数转换成一个类似可广泛应用的函数。例如，如果有一个操作字符串的函数，提升允许程序员容易地创建一个新的函数，该函数可以操作字符串向量、列表、字符串指针、整数-字符串 map 和其他包含字符串的结构。\n\n![操作字符串集合的函数.png](/images/2024/08/16/6c9310b0-5bcf-11ef-a253-abb20d863bc2.png)\n\n读者可以创建一个高阶函数，接收操作单个字符串的任意函数，并创建一个操作字符串指针的函数。前面已经分别创建了操作字符串向量和map的函数。这些函数称为提升函数，因为它们把操作某一类型的函数提升为操作包含这种类型的结构或集合的函数。\n\n![提升函数.png](/images/2024/08/16/540bc4b0-5bcf-11ef-a253-abb20d863bc2.png)\n\n---\n⭐️内容取自译者程继洪、孙玉梅、娄山佑《函数式编程》，仅从中取出个人以为需要纪录的内容。不追求内容的完整性，却也不会丢失所记内容的逻辑性。如果需要了解细致，建议读原书。","tags":["函数式编程"],"categories":["technology"]},{"title":"第三章：函数对象","url":"/2024/08/16/第三章：函数对象/","content":"\n**注意**：此文介绍很多[C++11新特性](https://xiaoyangst.github.io/tags/C-11%E6%96%B0%E7%89%B9%E6%80%A7/)的知识（auto 关键字、Lambda 表达式、function 包装器），这不会在此读书笔记中记录，可以在我的其它地方找到相关的笔记，或者你可以自行去学习，毕竟，C++11 是现在 C++ 学习者必备的语法。\n\n## 操作符包装器\n\n![操作符包装器.png](/images/2024/08/16/d632a100-5bc2-11ef-a253-abb20d863bc2.png)\n\nC++11 使用操作符包装器需要指明类型，如greater\\<int\\>()。但是 C++14 之后就可以不用了，如greater\\<\\>()。\n\n## std::function的性能问题和并发安全问题\n\n虽然前面的内容都证明 std::function 很有用，但不能滥用，因为它有明显的性能问题。为了隐藏包含的类型并提供一个对所有可调用类型的通用接口，std::function 使用类型擦除的技术。本书并不打算深入研究这个问题，只需要知道它是基于虚成员函数调用就足够了。因为虚调用是在运行时进行的，编译器不能在线调用，所以也就失去了优化的机会。\n\nstd::function 另一个需要注意的是，虽然它的调用操作符限定为 const，但它可以调用非const对象。在多线程代码中，容易导致各种问题。\n\n---\n⭐️内容取自译者程继洪、孙玉梅、娄山佑《函数式编程》，仅从中取出个人以为需要纪录的内容。不追求内容的完整性，却也不会丢失所记内容的逻辑性。如果需要了解细致，建议读原书。","tags":["函数式编程"],"categories":["technology"]},{"title":"82.删除排序链表中的重复元素 II","url":"/2024/08/16/82-删除排序链表中的重复元素-II/","content":"\n```c++\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        if(head == nullptr || head->next == nullptr){\n            return head;\n        }\n        ListNode* virtualHead = new ListNode(-101);\n        virtualHead->next = head;\n        ListNode* slow = head;\n        ListNode* fast = head->next;\n        ListNode* delPre = virtualHead; // 待删除节点的前一个节点\n\n        while(fast){\n            if(slow->val != fast->val){ // 如果不相等，三个指针集体前移\n                delPre = delPre->next;\n                slow = slow->next;\n                fast = fast->next;\n                continue;\n            }\n            while(fast != nullptr && slow->val == fast->val){   // fast 最终指向 不重复节点的位置\n                fast = fast->next;\n            }\n            if(fast != nullptr){    // 删除重复节点\n                delPre->next = fast;\n                slow = fast;\n                fast = fast->next;\n            }else{  // 如果 fast 为空，表明slow 和 fast 之间都是重复值，delPre 指向 fast 就代表删除这些重复值\n                delPre->next = fast;\n            }\n\n        }\n\n        return virtualHead->next;\n    }\n};\n```\n\n当我们的链表中删除某个节点，如果这个节点可能包含头结点，那么务必使用虚拟头结点，因为删除节点需要拥有待删除节点的前一个节点才能进行删除。","tags":["链表"],"categories":["leetcode"]},{"title":"83.删除排序链表中的重复元素","url":"/2024/08/16/83-删除排序链表中的重复元素/","content":"\n```c++\nclass Solution {  \npublic:  \n    ListNode* deleteDuplicates(ListNode* head) {  \n        if (head == nullptr || head->next == nullptr){  \n             return head;  \n        }  \n  \n        ListNode* slow = head;  \n        ListNode* fast = head->next;  \n  \n        while (fast) {  \n            // 由于 fast 进入循环，需要时刻检测 fast 不为空  \n            while (fast != nullptr && slow->val == fast->val) {  \n                fast = fast->next;  \n                slow->next = fast;  \n            }  \n            // 前面如果 fast 为空会退出循环，因此移动前需要检查是否是因为 fast为空退出  \n            if (fast != nullptr) {  \n                slow = fast;  \n                fast = fast->next;  \n            }  \n        }  \n  \n        return head;  \n    }  \n};  \n```\n\n这道题主要强调 while 循环，由于 fast 检测是否为空在最外层 while 中检测，但它只能保证当前这次循环不为空，所以 fast 如果进入下一个 while 循环（代码中内存 while 循环），记得要继续检测是否为空，不然出现未定义错误。之所以强调，是这种错误容易犯。\n","tags":["链表"],"categories":["leetcode"]},{"title":"206.反转链表","url":"/2024/08/16/206-反转链表/","content":"\n```c++\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        if(head == nullptr || head->next == nullptr){\n            return head;\n        }\n        ListNode* left = head;\n        ListNode* right = head->next;\n        while(right){\n            ListNode* node = right->next;\n            right->next = left;\n            left = right;\n            right = node;\n        }\n        head->next = nullptr;       // 容易被忘记，此时 head 已经是尾节点了，next 该指向 nullptr\n        return left;\n    }\n};\n```\n\n反转链表需要用到三个指针，left 和 right 指针用于反转链表，而 node 指针用来保存还未进行反转的链表。","tags":["链表"],"categories":["leetcode"]},{"title":"933.最近的请求次数","url":"/2024/08/16/933-最近的请求次数/","content":"\n```c++\nclass RecentCounter {\nprivate:\n    queue<int> data; \npublic:\n    RecentCounter() {}\n\n    int ping(int t) {\n        data.push(t);\n        while(data.front() < (t - 3000)){\n            data.pop();\n        }\n        return data.size();\n    }\n};\n```\n\n这道题只要想明白一件事情，即由于题目保证每次对 `ping` 调用所使用的 `t` 值都 **严格递增**，而我们只关心传递进来的 t 在 [t-3000,t] 范围内 ping 的总数，那就表明之前加入的所有数据并不是都有必要一直存在。\n\n简单举例说明：[1], [100], [3001], [3002]\n\n| 加入元素 | 范围内所有请求数 | 容器是否需要移除数据                       |      |\n| -------- | ---------------- | ------------------------------------------ | ---- |\n| 1        | [-2999,1]        | 不需要，还有元素1                          |      |\n| 100      | [-2900,100]      | 不需要，还有元素 1、100                    |      |\n| 3001     | [1,3001]         | 不需要，还有元素 1、100、3001              |      |\n| 3002     | [2,3002]         | 需要，移除元素 1，还有元素 100、3001、3002 |      |\n\n没错，到加入3002开始，由于后续加入的元素必然大于 3002，那么元素 1 没有存在的必要了，因为它都不在 [2,3002]范围，那么后续加入的元素它也必然不可能满足，因此 pop 掉。\n\n如果这道题没有想到这点，就会容易弄复杂，可能头脑清晰的时候一下子就想出来了，可若不是如此，很容易掉进陷阱中，比方说所有数据都保存，但实际上这是没必要的，因为递增的数据说明前面的数据并不一定有价值，在合适的地方就该删掉。","tags":["队列"],"categories":["leetcode"]},{"title":"解开之前的一个误会","url":"/2024/08/16/解开之前的一个误会/","content":"\n本来之前用的是 Gridea 把文章上传到博客，已经习惯使用，但是有天上传文章却出现问题，有些内容莫名其妙被加粗，让我相当不爽，我还以为是 Gridea 本身的问题，即 markdown 转到 HTML 出现的问题。直到今日问题才算解开，因为转到 hexo 这个问题还是出现了，询问 ChatGpt才算一目了然。\n\n原因是<>导致的错误识别，因为 Markdown 语法中的尖括号 `<` 和 `>` 被解释为 HTML 标签，导致内容被解析错误。等我删掉之后就解决了，如果非要保留，需要进行转移。这里就只介绍一种，即通过在尖括号前加上反斜杠 `\\` 来转义它们，使 Markdown 解析器不会将它们当作 HTML 标签处理。\n\n本人解析错误的内容如下： shared_ptr\\<A\\> 和 shared_ptr\\<B\\> 导致，如果你不进行转移，你根本看不到这里的 A 和 B，但我这里转移了，你可以看到。\n\n```tex\n创建 shared_ptr<A>对象 a 管理类 A 对象，a 的引用计数加 1，当前引用计数为 1。创建 shared_ptr<B> 对象 b 管理类 B 对象，b 的引用计数加 1，当前引用计数为 1。接下来将类对象 A 的 成员变量 b_ptr 赋值为前面创建的 b，b 的引用计数加 1，当前引用计数为 2。接下来将类对象 B 的 成员变量 a_ptr 赋值为前面创建的 a，a 的引用计数加 1，当前引用计数为 2。离开作用域之后，a 和 b 都被销毁，各自对应的引用计数减 1，且当前引用计数为 1。也就是说引用计数都没有归 0，这是没有析构的原因。\n```","tags":["一点小事"],"categories":["various"]},{"title":"tuple元组","url":"/2024/08/16/tuple元组/","content":"\nC++11 引入了 std::tuple，它是一种可以**包含多个不同类型元素的容器**（ 它是一个模板类，允许将多个不同类型的对象组合在一起。）。std::tuple 提供了一种方便的方法来将多个值组合在一起，而不需要定义一个结构体或类。\n\n```c++\nstd::tuple<int, double, std::string> myTuple(1, 2.5, \"Hello\");\n```\n\n## 创建和初始化\n\n```c++\nstd::tuple<int, double, std::string> t1;  // 默认构造\nstd::tuple<int, double, std::string> t2(10, 3.14, \"C++\");  // 值构造\nauto t3 = std::make_tuple(20, 6.28, \"Programming\");  // 使用 make_tuple 创建\n```\n\n## 访问元素\n\n```c++\nauto t = std::make_tuple(1, 2.5, \"Hello\");\nint i = std::get<0>(t);           // 获取第一个元素，类型为 int\ndouble d = std::get<1>(t);        // 获取第二个元素，类型为 double\nstd::string s = std::get<2>(t);   // 获取第三个元素，类型为 std::string\n\n// 通过类型访问元素\nauto s1 = std::get<std::string>(t);\n```\n\n## std::tuple_size 和 std::tuple_element\n\n`std::tuple_size<tuple_type>::value` 用于获取 `tuple` 中的元素数量。\n\n`std::tuple_element<N, tuple_type>::type` 用于获取 `tuple` 中第 N 个元素的类型。\n\n```c++\nauto t = std::make_tuple(1, 2.5, \"Hello\");\nconstexpr auto size = std::tuple_size<decltype(t)>::value;  // size = 3\n\nusing ElementType = std::tuple_element<1, decltype(t)>::type;  // ElementType = double\n```\n\n## 应用场景\n\n**返回多个值**：在函数需要返回多个值时，`std::tuple` 是一个很好的选择。\n\n**可变参数模板**：在泛型编程中，可以使用 `std::tuple` 处理不同数量和类型的参数\n\n**组合复杂类型**：将多个不同类型的数据组合在一起，避免定义专门的结构体","tags":["C++11新特性"],"categories":["technology"]},{"title":"auto 和 decltype","url":"/2024/08/16/auto-和-decltype/","content":"\n## auto\n\n使用了 auto 关键字以后，编译器会在编译期间自动推导出变量的类型，这样我们就不用手动指明变量的数据类型了。auto 仅仅是一个占位符，在编译器期间它会被真正的类型所替代。\n\n### 注意点\n\n1. auto 变量**必须在定义时初始化**，因为编译器需要根据初始化表达式来推导类型\n2. auto 不能在函数的参数中使用，因为 auto 后面的变量需要初始化，当时函数的参数还只是声明（哪怕你是给这个函数参数填上默认参数也不行）\n3. auto 其实在 C++11 不能用于推断函数的返回值，当时 C++14 支持了。在 C++11 不支持推断函数的返回值的情况下，利用 decltype 能解决这个问题\n4. 当 auto 用于数组或函数指针时，数组会退化为指针类型，函数会退化为函数指针类型\n5. 推导规则遵循 C++ 类型规则，如：如果表达式是按值传递的，那么 auto 推导出的类型是值类型，而不是引用类型\n6. 当 = 右边的表达式是一个引用类型时，auto 会把引用抛弃，直接推导出它的原始类型\n7. auto 关键字不能定义数组\n8. auto 只能用于类的静态成员，不能用于类的非静态成员（普通成员）\n9. 一旦类型被推导出来，变量的类型就固定了，不会因为初始化表达式的类型发生变化而改变\n\n最后一点可能不容易理解，举例说明：\n\n```c++\nauto x = 42;  // x 的类型被推导为 int\n```\n\n在这个例子中，x 的类型被推导为 int，因为 42 是一个整数字面值（int 类型）。即使你在以后改变 x 的值为不同类型的数据，x 的类型也不会改变，它仍然是 int。\n\n```c++\nx = 3.14;  // 虽然你尝试赋值一个 double 类型，但 x 仍然是 int\n```\n\n在这里，x 已经被推导为 int 类型，因此赋值时，3.14 会被截断为整数 3，因为 x 是 int 类型。\n\n### auto 与 const 结合\n\n- 当类型不为引用时，auto 的推导结果将不保留表达式的 const 属性\n- 当类型为引用时，auto 的推导结果将保留表达式的 const 属性\n\n## decltype\n\ndecltype 和 auto 功能相同，但 auto 有些无法做到的 decltype 可以完成。\n\n```c++\ndecltype(exp) varname = value;\n```\n\nauto 会根据 value 推断类型，当时decltype 根据 exp 表达式（变量、字面量、带有运算符的表达式）推导出变量的类型，跟 = 右边的 value 没有关系。\n\n当程序员使用 decltype(exp) 获取类型时，编译器将根据以下三条规则得出结果：\n\n- 如果 exp 是一个不被括号( )包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么decltype(exp) 的类型就和 exp 一致，这是最普遍最常见的情况\n- 如果 exp 是函数调用，那么 decltype(exp) 的类型就和函数返回值的类型一致\n- 如果 exp 是一个左值，或者被括号( )包围，那么 decltype(exp) 的类型就是 exp 的引用；假设 exp 的类型为 T，那么 decltype(exp) 的类型就是 T&\n\n## auto和decltype的区别\n\n### 类型推导的时机和方式\n\nauto:\n\n- auto 在变量声明和初始化时，根据初始化表达式推导变量的类型。\n- auto 只能用于变量声明，并且必须在声明时进行初始化。\n- 如果表达式是一个引用或 const，auto 会去掉引用性和 const 修饰符（除非明确指定 auto& 或 const auto&）。\n\n```c++\ncppCopy codeint x = 10;\nconst int& ref = x;\n\nauto a = ref;  // a 的类型是 int，引用和 const 被去掉\nauto& b = ref; // b 的类型是 const int&，保持引用和 const\n```\n\ndecltype:\n\n- decltype 在编译时根据表达式的形式推导类型，表达式本身并不一定需要被执行。\n- decltype 不要求表达式初始化，并且可以用于任何有效的表达式。\n- decltype 会保留表达式的原始类型，包括引用性和 const 修饰符。\n\n```c++\ncppCopy codeint x = 10;\nconst int& ref = x;\n\ndecltype(x) a;      // a 的类型是 int\ndecltype(ref) b = x;  // b 的类型是 const int&\n```\n\n### 用途\n\nauto:\n\n- 用于推导变量的类型，简化代码。\n- 经常用于遍历容器、返回值复杂的函数调用、lambda 表达式等。\n\n```c++\ncppCopy codestd::vector<int> vec = {1, 2, 3};\nauto it = vec.begin();  // it 的类型是 std::vector<int>::iterator\n```\n\ndecltype:\n\n- 用于获取表达式的类型，而不是直接声明变量。它可以用于推导函数的返回类型，或者声明与另一个变量具有相同类型的新变量。\n- decltype 常用于模板编程、函数返回类型推导，以及需要精确获取类型的场合。\n\n```c++\ncppCopy codeint x = 10;\ndecltype(x) y = 20;  // y 的类型是 int\n```\n\n### 类型推到的结果\n\nauto:\n\n- auto 的推导结果通常是值类型，除非显式使用引用或指针。\n- 对于引用类型，auto 会去掉引用和 const 修饰符（除非使用 auto& 或 const auto&）。\n\n```c++\ncppCopy codeconst int x = 10;\nauto y = x;  // y 的类型是 int，不是 const int\n```\n\ndecltype:\n\n- decltype 会精确获取表达式的类型，包括引用性和 const 性质。\n- 可以区分左值引用、右值引用等不同情况。\n\n```c++\ncppCopy codeint x = 10;\ndecltype(x) a;    // a 是 int 类型\ndecltype((x)) b = x;  // b 是 int& 类型，因为 (x) 是一个左值表达式\n```","tags":["C++11新特性"],"categories":["technology"]},{"title":"thread库","url":"/2024/08/16/thread库/","content":"\n## 条件变量的正确使用方法\n\n这里只介绍 wait，至于其他如 wait_for和 wait_until 自己查阅即可，无外乎增加一些新的功能而已。wait 提供两种方式：无条件等待和有条件等待\n\n```c++\nvoid wait (unique_lock<mutex>& lck);\t// 无条件等待\n\ntemplate <class Predicate> void wait (unique_lock<mutex>& lck, Predicate pred);\t// 有条件等待\n```\n\n无条件等待只有在唤醒的情况下才会解除阻塞，否则一直阻塞。阻塞期间释放锁（即不占有锁），被唤醒就会重新获取锁，解除阻塞往下执行。\n\n有条件等待在阻塞前会判断谓词 pred，如果为 true 就不会阻塞，如果为false 就会阻塞。当条件变量被通知时，线程会尝试重新获取锁，然后再次评估谓词。如果谓词返回 `true`，线程继续执行；否则，它会再次阻塞。\n\n总的来说无条件等待一上来就会阻塞，直到被唤醒，唤醒就会立即解除阻塞。有条件等待不会立即阻塞，而是先判断谓词情况。也可以说不会立即解除阻塞，要先判断谓词情况。如果为 true 就不阻塞而往下执行，否则就会阻塞。直到下一次被唤醒，再次检测谓词情况，如果为 true 就不阻塞而往下执行，否则就会阻塞。如此反复。\n\n```c++\nwhile(!condition){\n    g_cnd.wait(g_mtx);\n}\n// 等价于 有条件等待\n```\n\n通常条件变量被唤醒，需要配合一个判断条件。当这个条件不满足时，线程应该会再次阻塞。如果条件满足则不会阻塞。\n\n为了对这段描述有清晰的认识，还是有必要看看如果不这么做会有什么不恰当的现象。\n\n```c++\n#include <iostream>\n#include <thread>\n#include <condition_variable>\n#include <mutex>\n\nusing namespace std;\n\ncondition_variable cond_;\nmutex mtx_;\nint share = 0;\n\nvoid func(){\n  std::cout<<\"--start--\"<<std::endl;\n  unique_lock<mutex> um(mtx_);\n  cond_.wait(um);\n  std::cout<<\"share = \"<<share<<std::endl;\n  std::cout<<\"--end--\"<<std::endl;\n}\n\nint main() {\n\n  thread t1(func);\n\n  while (true){\n    lock_guard<mutex> mtt(mtx_);\n    share++;\n    if (share == 18){\n      std::cout<<\"notify\"<<std::endl;\n      cond_.notify_all();\n      break;\n    }\n  }\n  \n  t1.join();\n  return 0;\n}\n```\n\n创建一个线程 t1 并执行线程函数 func，等待被外部线程唤醒并输出 share 的值。主线程中循环 自增share，如果share 等于 18 就唤醒其它线程。执行该程序情况如下：\n\n![条件变量1.png](/images/2024/08/16/0109d110-5b95-11ef-922f-4335b82b6d11.png)\n\n线程中还没有执行 wait 等待被唤醒，主线程这边已经满足 share 等于 18 的条件就执行唤醒操作，我们的线程 t1 就错过被唤醒的机会了，所以会一直阻塞。因为代码中 t1.join 代表 等待线程 t1 结束，否则阻塞。\n\n修改代码（while循环前面添加 sleep(3) 休眠三秒），让主线程必然在子线程 t1 执行到 wait 阻塞操作后 才执行 share 的自加操作并唤醒。\n\n![条件变量2.png](/images/2024/08/16/06806ff0-5b95-11ef-922f-4335b82b6d11.png)\n\n尽管已经解决这个问题，但是这种处理方式相当愚蠢，因为不可能在我们的代码中随意加入 sleep 这样的睡眠函数，如何设置恰当的时间？这个地方如果频繁执行，效率影响是否严重？最恰当的还是能够在合适的时候通知并必然能够接受到通知。\n\n这就是前面所讲通常条件变量被唤醒，需要配合一个判断条件。\n\n```c++\ncondition_variable cond_;\nmutex mtx_;\nbool isSuccess = false; // 让 条件变量合理地被正常唤醒\nint share = 0;\n\nvoid func(){\n  std::cout<<\"--start--\"<<std::endl;\n  unique_lock<mutex> um(mtx_);\n  cond_.wait(um,[](){\t\t\t// 添加等待条件\n    return isSuccess;\n  });\n  std::cout<<\"share = \"<<share<<std::endl;\n  std::cout<<\"--end--\"<<std::endl;\n}\n\nint main() {\n\n  thread t1(func);\n\n  while (true){\n    lock_guard<mutex> mtt(mtx_);\n    share++;\n    if (share == 18){\n      std::cout<<\"notify\"<<std::endl;\n      isSuccess = true;\t\t\t// 表明 share 满足要求\n      cond_.notify_all();\n      break;\n    }\n  }\n\n  t1.join();\n  return 0;\n}\n```\n\n先看现象是否合理：\n\n![条件变量3.png](/images/2024/08/16/0f43c8d0-5b95-11ef-922f-4335b82b6d11.png)\n\n我们有 t1.join 操作保证主线程不会先于子线程退出，所以子线程有**可能**会接收到主线程的唤醒。但如果我们继续添加一个变量来让 子线程中的 wait 操作不断检测 条件是否满足（isSuccess 是否为 true），并且主线程唤醒之前 提前把 isSuccess 设置为true 再进行唤醒。哪怕最后这个唤醒失效，也必然能保证线程 1 能正常获取 share 的值并安全退出。因为你从图中可以看到 主线程提前唤醒，我的子线程都还没有准备好，即子线程还没有执行到 wait 阻塞等待。可即便如此，由于在唤醒之前，isSuccess必然已经被 设置为 true。等到子线程真的执行到 wait 阻塞等待时，发现 阻塞条件居然已经满足（isSuccess 检测到为true），子线程就知道主线程已经通知过，只不过这边没有收到而已，share明显已经可以被获取（因为子线程希望share = 18的时候被接收）。\n\n到这个时候我们终于弄明白，条件变量被唤醒，需要配合一个判断条件（往往是bool值）是为了避免唤醒被错过而加的一层保护机制。\n\n最后有个条件变量中的虚假唤醒没有讲，这已经在我的另一篇文章中讨论，感兴趣的可以去阅读：[多线程中的虚假唤醒](https://xiaoyangst.github.io/post/duo-xian-cheng-zhong-de-xu-jia-huan-xing/)\n\n结合前面的讨论和另一篇虚假唤醒的讨论，我们对使用条件变量的人提出如下要求，即你必须谨记下面的这两句：\n\n- 判断条件是否满足使用while，不可以用if\n- 务必添加变量来保证等待线程不会错过其他线程发送的唤醒信号\n\n## 锁的选择\n\nC++11提供四种语义的互斥量：独占互斥量`std::mutex`，带超时的独占互斥量`std::timed_mutex`，递归互斥量`std::recursive_mutex`，带超时的递归互斥量`std::recursive_timed_mutex`。应该优先选择std::mutex，因为它满足我们所有的需要使用互斥的场景。\n\n对于 mutex 的关键两个操作是 lock 和 unlock，将需要保护的临界区用这两个方法包裹即可。C++11为了方便锁的使用，提供 std::lock_guard 和 unique_lock 给我们使用：\n\n`std::lock_guard`：只是对操作系统锁的API进行RAII的封装，构造时获得锁（加锁），析构时释放锁（解锁），并不提供额外的方法，也不提供 lock 和 unlock 方法。\n\n`unique_lock`：它除了对操作系统锁的API进行RAII的封装，还提供手动控制锁的方法，即 lock 和 unlock 方法。并且提供给多的 lock 策略，比如 try_lock，try_lock_until等。\n\n## 生产者-消费者队列\n\n### 生产者-消费者队列简介\n\n它是实现线程间协作，交互的一种重要手段。从一端放数据（生产者），从另一端取数据（消费者）。生产者和消费者可以有一个或多个。\n\n![生产者消费者队列.png](/images/2024/08/16/16a8ca30-5b95-11ef-922f-4335b82b6d11.png)\n\n- 队列作为临界区需要被保护，消费者与生产者间要互斥\n- 当有多个生产者或多个消费者时，生产者之间，消费者之间需要互斥\n- 生产者在队列满的时候，不能再往队列中放入数据\n- 消费者在队列空的时候，不能再从队列中取数据\n\n在用途这个方向的划分，对于队列的实现，没有太大区别。只是队列中放的数据类型不一样。一种是业务的数据，一种是可调用的对象。但是有界队列和无界队列恰恰相反，在队列的实现方式上是有很大的不同，也是后面会用代码实现的内容。\n\n（一）按用途将队列分为两类\n\n**数据分发的队列**\n\n队列中存放的业务数据，可以有一个或多个生产者，消费者线程。生产者线程产生不同类型的数据，通过队列分发给不同消费者线程。\n\n**任务队列**\n\n队列中存放的是可调用对象，可以有一个或多个生产者，消费者线程\n\n- 在调用**要求时序**的情况下，应该只有一个生产者和一个消费者线程，一个队列。时序的要求由队列的先进先出的特性保证\n- 在调用**不要求时序**的情况下，则可以有多个生产者，消费者线程\n\n通过任务队列，来实现异步调用。**发起业务操作的线程不会被阻塞，业务执行函数被放到另外一个线程执行**，比如释放过程耗时高的资源且释放操作不能并发进行时。可以将释放操作专门放到一个线程中去做，此时可以有多个生产者线程，一个消费者线程，生产者将需要释放的资源对象放入队列，消费者线程依次取出后进行释放操作。此时就需要队列来实现异步操作。\n\n（二）根据队列的容量划分\n\n**有界队列**\n\n容量有大小限制，当满了后，生产者线程需要等待，为空的时候，消费者线程需要等待。这种队列可以用于数据分发的场景，但不能用于异步调用(异步调用的特性是生产者调用能马上返回，所以如果生产者阻塞在等待容器空闲显然是不满足要求的)。\n\n**无界队列**\n\n容量大小无限制，生产者线程可以一直放数据，队列为空的时候，消费者线程需要等待。这种队列即可以用于数据分发，也可以用于异步操作。这种情况下，消费者线程数量要大于生产者线程，是让数据或任务及时被处理，避免堆积。\n\n### 生产者-消费者队列（有界队列）\n\n```c++\ntemplate<class T>\nclass BoundQueue {\n private:\n  int maxSize_{1024}; // 最大容量\n  int size{0};  // 当前队列容量\n  mutex mutex_;\n  condition_variable full_;     // 每次生产每次唤醒消费者\n  condition_variable empty_;    // 每次消费每次唤醒生产者\n  queue<T> boundQueue_;\n\n public:\n  explicit BoundQueue(int maxSize) : maxSize_(maxSize) {}\n  ~BoundQueue() = default;\n\n  T get() { // 消费\n    unique_lock<mutex> um(mutex_);\n    full_.wait(um, [this](){\n      return !isEmpty();\n    });\n    T re = boundQueue_.front();\n    boundQueue_.pop();\n    size--;\n    empty_.notify_all();\n    return re;\n  }\n\n  void post(const T &data) {  // 生产\n    unique_lock<mutex> um(mutex_);\n    empty_.wait(um, [this](){\n      return !isFull();\n    });\n    boundQueue_.push(data);\n    size++;\n    full_.notify_all();\n  }\n\n private:\n  bool isEmpty(){\n    return boundQueue_.empty();\n  }\n\n  bool isFull(){\n    return size >= maxSize_;\n  }\n};\n```\n\n### 生产者-消费者队列（无界队列）\n\n```c++\ntemplate<class T>\nclass UnBoundQueue{\n private:\n  mutex mutex_;\n  condition_variable full_;     // 每次生产每次唤醒消费者\n  queue<T> unboundQueue_;\n public:\n  explicit UnBoundQueue() {};\n  ~UnBoundQueue() = default;\n  T get() { // 消费\n    unique_lock<mutex> um(mutex_);\n    full_.wait(um, [this](){\n      return !isEmpty();\n    });\n    T re = unboundQueue_.front();\n    unboundQueue_.pop();\n    return re;\n  }\n\n  void post(const T &data) {  // 生产\n    {\n      lock_guard<mutex> lock_guard(mutex_);\n      unboundQueue_.push(data);\n    }\n\n    full_.notify_all();\n  }\n private:\n  bool isEmpty(){\n    return unboundQueue_.empty();\n  }\n};\n```\n\n## 异步操作\n\n### future 与 promise\n\n它提供了一种机制可以获取异步操作的结果，因为一个异步操作的结果不能马上获取，只能在未来某个时候从某个地方获取。这个异步操作的结果是一个未来的期待值，所有称为 future，可以称它为未来量。\n\nstd::future 通常结合 std::promise，std::package_task，std::async使用。因为 future 本身只是用来存储某个结果，所以实际代码的执行还是需要借助其它函数。获取 future  存储结果的方法是 get()，并且只能获取一次，再次获取会异常。\n\n```c++\n//std::future 是一个类模板，模板参数需要传入一个类型\ntemplate <class T>\nfuture;template <class R&> future<R&>;\n```\n\nstd::promise 是一个协助线程赋值的类，它能够将数据和 future 对象绑定起来，为获取线程函数中的某个值提供便利。std::future 通常结合 std::promise 就相当于给线程间**建立一个通道**，分为以下几步：\n\n1. 在主线程中创建一个 std::promise 对象，promise<int> count_value\n2. 将 count_value 传给线程 t1\n3. 线程 t1 使用 std::promise 对象 count_value 的 get_future 方法获得一个 std::future对象，因为前面说过 std::future对象 可以存储异步操作的结果。截止到这个时候，通道已经建立，就可以使用通道了\n4. 在主线程中调用调用std::promise 对象 count_value 的 get 方法，如果 count_value 没有被设置只，主线程就会一直阻塞\n5. 在子线程中调用 set_value 方法给 count_value 设置一个值\n\n```c++\n#include <iostream>\n#include <future>\n\nusing namespace std;\n\nvoid thr_func(int num,promise<int> &p){\n    int count = 0;\n    for (int i = 0; i < num; ++i) {\n        count += i;\n    }\n    p.set_value(count);\t//将需要的结果存储起来\n}\n\nint main(){\n\n    promise<int> count_value;\n\n    thread t1(thr_func,10, ref(count_value));\n    \n    \n    t1.join();\n\n    cout<<\"0~10之间数字的总和：\"<<count_value.get_future().get()<<endl;\t//获取返回值\n\n    return 0;\n}\n```\n\n### future 与 package_task\n\n`packaged_task` 包装了一个可调用对象，并允许其结果以异步方式获取。它类似于 `std::function`，但会将结果**自动传递**给一个 `future` 对象。它的内部包含两个元素：\n\n1. 存储的任务（用户传递），这是某种可调用对象（如函数指针、成员函数指针或函数对象）\n2. 共享状态（自动传递），能够存储调用存储任务的结果（类型为 `Ret`），并通过 `future` 异步访问\n\n通过调用成员函数 `get_future`，共享状态与 `future` 对象关联。调用后，这两个对象共享相同的共享状态。\n\n比方说下面的代码中，先把普通函数 thr_func 包装成 packaged_task 类型的对象（返回值类型和参数列表要一直） task，最终的得到的这个 task 需要通过**引用的方式传递到子线程内部**，这样才能在主线程的最后通过任务对象的 get_future 方法得到 future 对象，打包的 task 代码中 return 的返回值就存储在 future 对象里。前面我们讲过 future 对象 获取存储结果的方式就是 get 方法。\n\n```c++\n#include <iostream>\n#include <future>\n\nusing namespace std;\n\nint thr_func(int num){      //  普通函数\n    int count = 0;\n    for (int i = 0; i < num; ++i) {\n        count += i;\n    }\n    return count;\n}\n\nint main(){\n\n    packaged_task<int(int)> task(thr_func);     //将函数thr_func 打包为 task函数\n\n    future<int> result = task.get_future();     //返回值存储在future中\n\n    thread t1(ref(task),10);        //将打包的函数task传递进去，包括这个函数所需要的参数\n\n    t1.join();\n\n    cout<<\"0~10之间数字的总和：\"<<result.get()<<endl;       //拿到返回值\n\n    return 0;\n}\n```\n\n### future 与 async\n\n可以直接启动一个子线程并在这个子线程中执行对应的任务函数，异步任务执行完成返回的结果也是存储到一个future对象中。也就是说调用 async 的返回值是一个 future 对象，里面存储返回值。这么看要比 package_task 方便很多，因为不需要取打包可调用对象，直接传递进去即可。\n\n```c++\ntemplate< class Function, class... Args>\nstd::future<std::result_of_t<std::decay_t<Function>(std::decay_t<Args>...)>>\n    async( Function&& f, Args&&... args );\n\n\ntemplate< class Function, class... Args >\nstd::future<std::result_of_t<std::decay_t<Function>(std::decay_t<Args>...)>>\n    async( std::launch policy, Function&& f, Args&&... args );\n```\n\n函数参数:\n\n- f：可调用对象，这个对象在子线程中被作为任务函数使用\n- Args：传递给 f 的参数（实参）\n- policy：可调用对象f的执行策略（std::launch::async 创建新线程启动函数，std::launch::deferred 在主线程中启动函数）\n\n```c++\n#include <iostream>\n#include <future>\n\nusing namespace std;\n\nint thr_func(int num){      //  普通函数\n    int count = 0;\n    for (int i = 0; i < num; ++i) {\n        count += i;\n    }\n    return count;\n}\n\nint main(){\n\n\n    future<int> result = async(launch::async,thr_func,10);      //自动创建线程，并返回thr_func的返回值\n\n    cout<<\"0~10之间数字的总和：\"<<result.get()<<endl;       //拿到返回值\n\n    return 0;\n}\n```\n\n### future 与 shared_future\n\n`std::funture` 只支持移动语义，它要求类型参数也支持移动语义。它的get方法只能调用 1 次，调用get相当于将结果移走(移动语义的通俗意义)。再次调用会抛异常。\n\n`std:shared_future` 可以共享结果，可以多次调用get方法，它要求类型参数支持复制语义。\n\n### 总结\n\n1. future 是异步函数存储结果的所在\n2. promise 异步函数相当于创建一个变量给到线程，然后在线程中把值存储到变量中之后，主线程再进行获取\n3. packaged_task 异步函数对函数进行封装，这样线程函数可以有 return 返回值，不像 promise 是将在线程函数中把值存储起来，但是 packaged_task 却可以有 return 返回值\n4. async 异步函数更加高级，前面需要的两个线程函数需要创建子线程，但是它自动创建并且返回传递可调用对象的返回值\n\nfuture 存储结果，其它三个异步函数中 async 要更灵活且简单，能够真正做到异步（可以自启动一个线程去执行函数）","tags":["C++11新特性"],"categories":["technology"]},{"title":"chrono库","url":"/2024/08/16/chrono库/","content":"\n> 之前浅学这块内容，C++11封装的如此冗长，于是“重学”加深影响，方便后续查阅\n\n在`std::chrono`命名空间下定义。\n\nC语言虽然也有时间处理方法，但是精度只到秒。Linux 和 Windows 都有提供相应的方法精确到微秒，但是用法不同，显然不支持跨平台。**chrono 库精度更高，同时支持跨平台**，因此C++11之后使用chrono 库处理时间和日期是有必要的，至于到后面的C++版本是否会继续加强，那是以后的事情。\n\n对于时间、日期的处理，它引入了三个基本概念：\n\n- 时间（时钟）：时间点的同上概念，包含时间点、时间间隔、日期\n- 时间间隔（时间段）：两个时间点的差值\n- 时间点：比如 12:05:00 表示一个时间点，比如 2021-01-01 13:00:00 也表示一个时间点\n\n![时间库.png](/images/2024/08/16/cdf3a940-5b94-11ef-922f-4335b82b6d11.png)\n\n## 时间段duration\n\n```c++\ntemplate <class Rep, class Period = ratio<1> >\nclass duration;\n\nRep: 表示时间的数量（例如，整数或浮点数）\nPeriod: 表示时间单位（例如，秒、毫秒、微秒等）\n```\n\n提供 count方法 获得计数值，还能进行运算符运算（加减乘除）\n\n```c++\n#include <iostream>\n#include <chrono>\n\nint main() {\n    using namespace std::chrono;\n    \n    // 创建两个时间段\n    seconds five_seconds(5);\n    seconds three_seconds(3);\n    \n    // 加法运算\n    seconds total = five_seconds + three_seconds;\n    \n    // 减法运算\n    seconds difference = five_seconds - three_seconds;\n    \n    // 乘法运算\n    seconds double_time = five_seconds * 2;\n    \n    // 除法运算\n    seconds half_time = five_seconds / 2;\n    \n    std::cout << \"Total time: \" << total.count() << \" seconds\" << std::endl;\n    std::cout << \"Difference in time: \" << difference.count() << \" seconds\" << std::endl;\n    std::cout << \"Double time: \" << double_time.count() << \" seconds\" << std::endl;\n    std::cout << \"Half time: \" << half_time.count() << \" seconds\" << std::endl;\n\n    return 0;\n}\n\n/*\n\nTotal time: 8 seconds\nDifference in time: 2 seconds\nDouble time: 10 seconds\nHalf time: 2 seconds\n\n*/\n```\n\n时间段可以应用于 wait_until 这种等到某个时间段的语句，下面介绍的时间点可以应用于 wait_for 这种等到某个时间点的语句\n\n## 时间点time_point\n\n用于表示时间点的类模板，和下面要介绍的clocks结合使用\n\n创建对象不填写参数，代表构造一个以纪元为值的对象\n\n```c++\n#include <iostream>\n#include <chrono>\n\nint main(){\n\n  std::chrono::system_clock::time_point time_point1;\n  time_t  tt1 = std::chrono::system_clock::to_time_t(time_point1);\n  std::cout<<ctime(&tt1);\n\n  return 0;\n}\n\n/*\n\tThu Jan  1 08:00:00 1970\n*/\n```\n\n有两个成员方法：min和max代表time_point的最小值和最大值\n\n测试最小值为空，最大值为Sat Apr 12 07:47:16 2262\n\n前面介绍无参构造函数，还有两个构造函数没有介绍\n\n```c++\n// 使用一个时间段 d 来初始化时间点，从时钟的时间零点开始计算\nexplicit time_point(const duration& d);\n\n/*\n\n    // 创建一个时间段\n    std::chrono::seconds duration(10);\n    \n    // 使用时间段构造 time_point\n    std::chrono::system_clock::time_point tp_with_duration(duration);\n    \n    auto duration_since_epoch = tp_with_duration.time_since_epoch();\n    \n    std::cout << \"Constructed time_point with duration: \"\n              << duration_since_epoch.count() << \" seconds since epoch\\n\";\n             \n     输出结果：\n     Constructed time_point with duration: 10000000000 seconds since epoch\n\n*/\n\n```\n\n```c++\n// 使用另一个时间点来拷贝构造新的时间点\ntime_point(const time_point& other) = default;\n\n/*\n\n    // 获取当前时间点\n    std::chrono::system_clock::time_point tp_now = std::chrono::system_clock::now();\n    \n    // 使用拷贝构造函数\n    std::chrono::system_clock::time_point tp_copy(tp_now);\n    \n    auto duration_since_epoch_now = tp_now.time_since_epoch();\n    auto duration_since_epoch_copy = tp_copy.time_since_epoch();\n    \n    std::cout << \"Original time_point: \"\n              << duration_since_epoch_now.count() << \" ticks since epoch\\n\";\n    std::cout << \"Copied time_point: \"\n              << duration_since_epoch_copy.count() << \" ticks since epoch\\n\";\n              \n     输出结果：\n     Original time_point: 1719716264027922800 ticks since epoch\n     Copied time_point: 1719716264027922800 ticks since epoch\n*/\n```\n\n## 系统时钟clocks\n\n（一）std::chrono::system_clock\n\nnow：可以用于获取当前时间\n\nto_time_t：转换为 time_t \n\nfrom_time_t：从time_t 转换\n\n```c++\n#include <iostream>\n#include <chrono>\n\nint main(){\n\n  std::chrono::system_clock::time_point curTime = std::chrono::system_clock::now(); // 获取当前时间\n  time_t showTime = std::chrono::system_clock::to_time_t(curTime);  // 转换为 time_t 类型\n  std::cout<<\"当前时间: \"<<std::ctime(&showTime)<<std::endl;\n\n  return 0;\n}\n\n/*\n\t当前时间: Sun Jun 30 10:29:03 2024\n*/\n```\n\ntime_t 类型是C语言的时间类型，这就是实现C++和C语言时间类型的转换的\n\n（二）std::chrono::steady_clock\n\n不会被系统时间的调整所影响，且它的滴答频率是稳定的，适合用于**测量时间间隔**\n\n只提供 now方法用于获取当前时间，测量时间间隔只需要调用两次now方法求差即可\n\n（三）std::chrono::high_resolution_clock\n\n提供了最高可能的时间分辨率。通常，它是 `system_clock` 或 `steady_clock` 的别名，但具体实现依赖于系统和标准库实现\n\n同样只提供 now 方法用于获取当前时间\n\n---\n\n看来，测试时间间隔采用std::chrono::steady_clock（稳定，不受系统时间影响，因为原点是计算机启动的时刻），希望将时间转换为日历显示效果或者转换为C语言风格的时间类当采用std::chrono::system_clock（不稳定，如果被恶意修改系统时间，这里跟着受影响，通过 is_steady 判断是否稳定）\n\n##  表示不同的时间单位\n\n通过在构造函数中传递值，表示不同的时间类型，比方说你在 hours(1)代表一个小时，seconds(1)代表一秒\n\n`std::chrono::hours`：表示小时的持续时间\n\n`std::chrono::minutes`：表示分钟的持续时间\n\n`std::chrono::seconds`：表示秒的持续时间\n\n`std::chrono::milliseconds`：表示毫秒的持续时间\n\n`std::chrono::microseconds`：表示微秒的持续时间\n\n`std::chrono::nanoseconds`：表示纳秒的持续时间\n\n## 转换为duration或time_point\n\n（一）duration_cast\n\n用于将时间段从一种单位转换为另一种单位\n\n```c++\ntemplate <class ToDuration, class Rep, class Period>\nconstexpr ToDuration duration_cast(const duration<Rep, Period>& d);\n```\n\n把 秒 转换为 分钟，把 秒 转换为毫秒 \n\n```c++\n#include <iostream>\n#include <chrono>\n\nint main() {\n    std::chrono::seconds sec(120); // 120 seconds\n\n    // 将秒转换为分钟\n    std::chrono::minutes min = std::chrono::duration_cast<std::chrono::minutes>(sec);\n    std::cout << sec.count() << \" seconds is \" << min.count() << \" minutes.\" << std::endl;\n\n    // 将秒转换为毫秒\n    std::chrono::milliseconds millisec = std::chrono::duration_cast<std::chrono::milliseconds>(sec);\n    std::cout << sec.count() << \" seconds is \" << millisec.count() << \" milliseconds.\" << std::endl;\n\n    return 0;\n}\n```\n\n（二）time_point_cast\n\n用于将时间点从一种单位转换为另一种单位\n\n```c++\ntemplate <class ToDuration, class Clock, class Duration>\nconstexpr time_point<Clock, ToDuration> time_point_cast(const time_point<Clock, Duration>& tp);\n```\n\n将当前时间点 转换为 毫秒精度，将当前时间点转换为秒精度\n\n```c++\n#include <iostream>\n#include <chrono>\n\nint main() {\n    auto now = std::chrono::system_clock::now(); // 获取当前时间点\n\n    // 将当前时间点转换为毫秒精度\n    auto now_ms = std::chrono::time_point_cast<std::chrono::milliseconds>(now);\n    auto epoch = now_ms.time_since_epoch();\n    auto value = std::chrono::duration_cast<std::chrono::milliseconds>(epoch);\n\n    std::cout << \"Current time in milliseconds since epoch: \" << value.count() << \"ms\" << std::endl;\n\n    // 将当前时间点转换为秒精度\n    auto now_sec = std::chrono::time_point_cast<std::chrono::seconds>(now);\n    epoch = now_sec.time_since_epoch();\n    auto value_sec = std::chrono::duration_cast<std::chrono::seconds>(epoch);\n\n    std::cout << \"Current time in seconds since epoch: \" << value_sec.count() << \"s\" << std::endl;\n\n    return 0;\n}\n```","tags":["C++11新特性"],"categories":["technology"]},{"title":"移动语义","url":"/2024/08/16/移动语义/","content":"\n## 复制语义和移动语义\n\nC++11 之前只有复制（拷贝）语义，定义了**析构函数，复制构造函数，赋值函数**就称为有了拷贝控制。对对象的非指针，非引用的行为都会使用复制语义。在拥有内存资源对象中，都会定义这三个函数以实现**深拷贝**。\n\n复制语义不会销毁用来复制的对象，同时还得到一个和其一模一样的对象。但是在某些场景中，我们希望对象拷贝后立即被销毁，这种情况我们就是移动语义，即只是移动而非拷贝对象以大幅度提升性能。\n\n![copymove.png](/images/2024/08/16/94175820-5b94-11ef-922f-4335b82b6d11.png)\n\n我们的重点还是集中在移动语义上，谈及复制语义是为了更清楚地知道移动语义出现的意义。移动语义就是从给定对象“窃取”资源而不是拷贝资源，源对象不再拥有资源，资源的所有权已经归属于新创建的对象。那么实现移动语义有哪些要求呢？\n\n1. 移动语义可以将一个对象中的资源移走，而不是赋值，所以它们**并不分配内存**\n2. 移动后的源对象会被销毁（形参是右值引用），所以内部资源会被置为无效（比如指针会被置为 nullptr ）\n3. 它们都需要声明为noexcept（不能抛异常）\n\n如果需要移动语义，建议自己定义，不要编译器合成。因为编译器会优先考虑使用复制语义，而不是移动语义，除非对象明确的定义了移动语义。\n\n## 代码实现复制语义和移动语义\n\n复制语义：拷贝构造函数，拷贝赋值函数\n\n移动语义：移动构造函数，移动赋值函数\n\n```c++\n#include <iostream>\n#include <cstring>\n\nclass MyString {\n private:\n  char* str_;\n  int size_;\n public:\n  MyString(char* str, int size) : size_(size) {\n    str_ = new char[size_ + 1]; // 分配内存，并加1用于终止符\n    std::memset(str_, 0, size_ + 1); // 使用size_ + 1，确保包含终止符\n    std::strncpy(str_, str, size_);\n    str_[size_] = '\\0'; // 确保字符串以终止符结束\n  }\n\n  ~MyString() {\n    delete[] str_;\n  }\n\n  // 拷贝构造函数\n  MyString(const MyString& other) : size_(other.size_) {\n    std::cout << \"拷贝（复制）构造函数\" << std::endl;\n    str_ = new char[size_ + 1];\n    std::memset(str_, 0, size_ + 1);\n    std::strncpy(str_, other.str_, size_);\n    str_[size_] = '\\0';\n  }\n\n  // 拷贝赋值操作符\n  MyString& operator=(const MyString& other) {\n    std::cout << \"拷贝（复制）赋值函数\" << std::endl;\n    if (this != &other) {\n      delete[] str_;\n      size_ = other.size_;\n      str_ = new char[size_ + 1];\n      std::memset(str_, 0, size_ + 1);\n      std::strncpy(str_, other.str_, size_);\n      str_[size_] = '\\0';\n    }\n    return *this;\n  }\n\n  // 移动构造函数\n  MyString(MyString&& other) noexcept : str_(other.str_), size_(other.size_) {\n    std::cout << \"移动构造函数\" << std::endl;\n    other.str_ = nullptr;\n    other.size_ = 0;\n  }\n\n  // 移动赋值操作符\n  MyString& operator=(MyString&& other) noexcept {\n    std::cout << \"移动赋值函数\" << std::endl;\n    if (this != &other) {\n      delete[] str_;\n      str_ = other.str_;\n      size_ = other.size_;\n      other.str_ = nullptr;\n      other.size_ = 0;\n    }\n    return *this;\n  }\n};\n```\n\n这些代码实现并不难，只有弄清楚实际的语义就好，说明如下：\n\n- 构造函数是没有返回值的，不管是哪种构造函数（普通构造函数，拷贝构造函数和移动构造函数）\n- 赋值函数 就是对赋值运算符 = 的重载\n- 赋值操作要考虑不能自我赋值的情况，所以要判断是否为自我赋值，false 的情况下再进行赋值操作，true 的情况下直接返回 当前对象即可\n- 移动语义（移动构造函数和移动赋值函数）下需要移动的对象必须是右值引用\n- 类中的成员变量需要分配内存的务必分配内存之后再进行操作\n- 复制语义只是把传递进来的对象中的成员变量拷贝到当前对象中，并不会销毁对象，代码中仅涉及拷贝操作。移动语义需要把传递进来的对象中的成员变量拷贝到当前对象中，同时需要销毁传递进来的对象，代码中不仅涉及拷贝操作，还涉及清理内存操作（传递进来的对象）\n- 复制语义每次都为当前对象分配内存，然后把传递进来的对象拷贝到当前对象。移动语义是把一个对象的资源移交给另一个对象，无需为当前对象分配内存，所以移动语义发生在两个已经存在的对象之间。\n\n测试代码：\n\n```c++\nint main() {\n  // 测试构造函数\n  char text[] = \"Hello, World!\";\n  MyString str1(text, strlen(text));\n\n  // 测试拷贝构造函数\n  MyString str2 = str1;\n\n  // 测试拷贝赋值操作符\n  MyString str3(text, strlen(text));\n  str3 = str1;\n\n  // 测试移动构造函数\n  MyString str4 = std::move(str1);\n\n  // 测试移动赋值操作符\n  MyString str5(text, strlen(text));\n  str5 = std::move(str2);\n\n  return 0;\n}\n```\n\n输出结果：\n\n```tex\n拷贝（复制）构造函数\n拷贝（复制）赋值函数\n移动构造函数\n移动赋值函数\n```\n\n## move函数\n\nstd::move 的功能仅是**将左值转换成右值引用**。它本身不会产生移动操作，只是产生一个右值引用，真正的移动操作是在移动构造函数和移动赋值函数中完成的。总的来说，如果你没有实现移动语义，std::move 产生一个右值引用是无法触发移动语义的，从而去调用复制语义了。\n\n## 移动语义的合理使用\n\n似乎 移动语义带来的性能提升让我们觉得可以无处不在，实际情况也非如此：\n\n1. 编译器为自定义类型自动生成移动语义的是有要求的，必须没有声明复制操作，移动操作以及析构函数\n2. 即使在标准库中都已经支持移动操作，但是也可能不会像希望的那样带来那么大利好。这样取决于具体的实现\n   - 比如list，它的实现通常是会在堆上分配内存，将容器元素放在这个堆内存上，内部只是会维护指向堆内存的指针。那么对list的移动，只算交换指针，那么效率自然会有提升\n   - 比如array，它是C++ 11引入的新的容器类型，就是数组。它的内存就是对象内部的一个缓存区(比如是在栈上分配的一段顺序的空间)，所以对它的移动操作，还是要将元素进行复制\n\n## 补充：编译器自动生成移动操作的要求\n\n如果我们在类中没有定义拷贝操作，那么编译器会自动为我们生成默认的拷贝操作，但是对移动操作，编译器是有条件满足才会生成的：\n\n1. 类中没有自定义拷贝控制成员（拷贝构造函数、赋值操作、析构函数）\n2. 它的所有数据成员都能够移动构造或移动赋值\n\n如果需要移动语义，我们还是自己定义，免得去计较它需要的条件。\n\n## 补充：为什么用右值引用实现移动语义，而不是左值引用？\n\n在有拥有内存资源的对象中，通过复制语义(深拷贝)来转移内存，将源对象赋值给目标对象，源对象中资源很可能是不需要再保留的，这时直接将源对象中的资源转移给目标对象(浅拷贝，只移动指针)，就更贴切。但是使用左值引用来实现有两个限制:\n\n- 为了满足所有的表示移动的场景，它必须是一个构造函数，并且形参需为const &(为了能引用临时对象这样的右值)，为了与其它构造函数作区分，形参个数需不同(显然是没有这样的语法的)\n- 对 const 引用的形参，在函数中并不能改变的它\n\n引入右值引用就是来实现移动语义的，解决实现上的限制。","tags":["C++11新特性"],"categories":["technology"]},{"title":"Lambda 表达式","url":"/2024/08/16/Lambda-表达式/","content":"\n任何需要可调用对象的接口，都可以传入一个lambda表达式\n\n![lambda.png](/images/2024/08/16/5a9cfd20-5b94-11ef-922f-4335b82b6d11.png)\n\n`捕获`：捕获 lambda 表达式以外的参数，可以按值捕获（不可修改外部捕获的变量或对象）或按引用捕获（可修改外部捕获的变量或对象）\n\n`形参 和 ret`：lambda表达式又名匿名函数，函数当然可以有形参和返回值，这里的形参有类型并且支持默认参数\n\n`函数体`：函数的功能，即实际的逻辑代码\n\n一个普通函数不仅可以没有实参，也可以无需具体的返回值类型，但是必须要有函数体。lambda表达式又名匿名函数，即没有函数名的函数，形参和返回值也可以不必有，但是函数体不能丢。至于捕获也可以不进行任何捕获，但是却必须标识它的存在。\n\n1. `[]` ：不捕捉任何变量\n2. `[&]` ：按引用捕获\n3. `[=]`： 按值捕获\n4. `[=, &foo]` ： 按值捕获外部作用域中所有变量, 并按照引用捕获外部变量 foo\n5. `[bar]`： 按值捕获 bar 变量, 同时不捕获其他变量\n6. `[&bar]`： 按引用捕获 bar 变量, 同时不捕获其他变量\n7. `[this]`： 捕获当前类中的this指针\n   1. 让lambda表达式拥有和当前类成员函数同样的访问权限\n   2. 如果已经使用了 & 或者 =，默认添加此选项\n\n\n关于 lambda 表达式捕获 this 需要注意的一个问题，即操作 this对象的时候，需要确保对象没有被销毁。如下由于我们已经提前把对象 e 删除，在此之前尽管已经保存其返回的lambda，但由于这个函数操作对象的成员变量，再调用就是不合法的。\n\n```c++\n#include <iostream>\n#include <vector>\n#include <functional>\n\nclass Example {\n public:\n  Example() {}\n\n  std::function<void()> getShowLambda() {\n    // 捕获 this 指针并返回 lambda\n    return [this]() {\n      // 访问类成员\n      for (auto i : data) {\n        std::cout << i << \" \";\n      }\n      std::cout << std::endl;\n    };\n  }\n\n private:\n  std::vector<int> data = {1, 2, 3, 4};\n};\n\nint main() {\n  Example* e = new Example();\n  auto f = e->getShowLambda(); // 获取 lambda\n\n  delete e; // 销毁对象\n  e = nullptr;\n\n  f(); \n\n  return 0;\n}\n```\n\nlambda表达式是可调用对象，因此当你按照前面所讲的格式写出来之后，你有两种方式进行调用：原地调用和后续调用。\n\n```c++\n  // 原地调用\n  [](int num1,int num2) -> int {\n    return num1 + num2;\n  }(10,20);\n\n  // 后续调用\n  auto f1 =   [](int num1,int num2) -> int {\n    return num1 + num2;\n  };\n  f1(10,20);\n```","tags":["C++11新特性"],"categories":["technology"]},{"title":"function 和 bind","url":"/2024/08/16/function-和-bind/","content":"\n## 可调用对象的类型和调用形式\n\n在 C++ 中函数、函数指针、指向类的成员函数指针、函数对象（重载了调用运算符的类）、lambda 表达式都属于**可调用对象**。可调用对象都是有类型的，比方说函数对象，它本质就是一个重载了调用运算符的类，不同的类当然类型也不相同。还有函数和函数指针，它们的类型是有其返回值类型和实参类型决定，`int func(int a,int b)` 和 `void func()` 就不是同一个类型。它们对应的指针也是不同的类型，不能相互赋值。\n\n虽然它们的类型不尽相同，但是它们的调用形式却有相同之处。调用形式指明了调用返回的类型和传递给调用的实参类型。如下面的代码所示，尽管 函数 和 lambda表达式 类型不同（不能相互赋值），但是调用形式一样。\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint addA(int num1,int num2){  // 函数\n  return num1 + num2;\n}\n\nauto addB = [](int num1,int num2)->int {  // lambda表达式\n  return num1 + num2;\n};\n\nint main() {\n  \n  // 调用形式一样\n  addA(1,2);\n  addB(1,2);\n\n  return 0;\n}\n```\n\n## function的用法\n\n同一种调用形式的可调用对象的类型可能不同，可以通过 function 将其**统一**起来，function 是一个模板，当创建一个具体的 function 类型时必须提供该 function 类型能够表示的对象的调用信息。\n\n```c++\nfunction<int(int,int)>\n```\n\n声明了一个 function 类型，它表示接受两个 int 实参，返回一个 int 结果的可调用对象。\n\n注：当你知道 function 是一个模板，就理解为什么外层是一对尖括号<>\n\n---\n\n既然 function 是把不同的可调用对象的类型统一起来，那就把之前的例子拿过来统一看看。\n\n```c++\n#include <iostream>\n#include <vector>\n#include <functional>\nusing namespace std;\n\nint addA(int num1,int num2){  // 函数\n  return num1 + num2;\n}\n\nauto addB = [](int num1,int num2)->int {  // lambda表达式\n  return num1 + num2;\n};\n\nint main() {\n\n  using  funCallback = function<int(int,int)>;\n\n  funCallback f1 = addA;\n  funCallback f2 = addB;\n\n  f1(1,2);\n  f2(1,2);\n  return 0;\n}\n```\n\n我们可以看到在赋值给 function 类型时，我们没有传递任何参数（实际上也不支持），而是把可调用对象的名称传递过去。还有 function 把不同的可调用对象的类型统一起来，这在上面这个例子中已经证明，即f1、f2接受不同类型的可调用对象了。\n\nfunction 类型的对象（如上面的f1、f2）只是把可调用对象存储起来，需要的时候调用，就像调用普通函数那样，传递所需的实参即可。如果声明的 function 类型的对象没有存储可调用对象，我们去执行是没有任何效果的，为了避免这种情况，可以在调用之前检查是否为空。\n\n```c++\nif(!f1){\t\n\tstd::cout<<\"f1 is nullptr\"<<std::endl;\n}\n```\n\n难道我们的 function 就没有不足吗？有个可调用对象 function 无法存储，即类成员（函数）指针。这是因为成员函数指针和普通函数指针有一些重要的区别。成员函数指针需要一个对象实例来调用，而普通函数指针不需要。\n\n```c++\nclass Test{\n public:\n  Test() = default;\n  ~Test() = default;\n  int AddC(int num1,int num2){\n    return num1 + num2;\n  }\n};\n\nint main() {\n\n  using  funCallback = function<int(int,int)>;\n  funCallback f1 = &Test::AddC;\t// 报错，这是不允许的\n\n  return 0;\n}\n```\n\n## bind的用法\n\n接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表。即用来将可调用对象与其参数一起进行绑定，绑定后的结果可以使用 function 进行保存。\n\nbind 必须把函数所需的参数进行绑定，如果不填写默认参数进行绑定，就用占位符placeholders::_N（1、2、3...N）填充，等后续调用时再自行填写。\n\n```c++\n// 绑定非类成员函数/变量\nauto f = std::bind(可调用对象地址, 绑定的参数/占位符);\n// 绑定类成员函/变量\nauto f = std::bind(类函数/成员地址, 类实例对象地址, 绑定的参数/占位符);\n```\n\n前面讲 function的时候，讲到两个问题。首先 function 存储可调用对象，只有在实际调用的情况下才允许传递实参。其次，function 无法存储 类成员（函数）指针。这两个问题 bind 都可以解决。\n\n为什么这里通常用 auto 来推断类型？因为 bind 绑定占位符之后，类型就会发生改变，如果手动去指定会比较麻烦，看下面这个例子：\n\n```c++\nusing  funCallback = function<int(int,int)>;\nTest t1;\nfunction<int(int)> f1 = bind(&Test::AddC,t1,placeholders::_1,2);\nf1(1);\n```\n\n我们明显可以看到填写具体的参数之后，类型就从 `function<int(int,int)>` 变成 `function<int(int)>`。所以，当我们想对 function 对象的参数列表进行操作（填写默认参数，以减少后续调用所需填写的参数）可以想到用 bind来辅助。但是 bind 是不可以对 function 对象的返回值进行操作的，除非是隐式转换，比方说原 function 对象 是 int 返回值，你这边的新 function 对象返回值是 float 是可以编译通过的。\n\n```c++\nusing  funCallback = function<int(int,int)>;\nTest t1;\nfunction<float(int)> f1 = bind(&Test::AddC,t1,placeholders::_1,2);  // 返回值存在隐式转换可以编译通过\nfunction<int*(int)> f1 = bind(&Test::AddC,t1,placeholders::_1,2);   // 返回值不存在隐式转换无法编译通过\n```\n\n## 回调机制的实现\n\nfunction 可以存储任意类型的可调用对象，bind 可以将一个可调用对象转换成新的可调用对象，那么我们可以通过 bind 将一个可调用对象转换成指定的 funtcion 类型。function 和 bind 是 C++11 中实现回调机制的常用组合。\n\n从网上借鉴一句话来阐述：**回调函数是你写一个函数，让预先写好的系统来调用。你调用系统的函数，是直调。让系统调用你的函数，就是回调**。比方说网络库中，你传递一个回调函数，这个回调函数的功能是处理连接上客户端发送的消息，那么这个回调函数究竟什么时候调用并不用你管，这是由系统（网络库）来选择合适的时机进行调用的，毕竟网络库要管理很多的连接。\n\n```c++\n#include <iostream>\n#include <functional>\n#include <vector>\n\n// 定义回调类型\nusing Callback = std::function<void(int)>;\n\nclass EventSystem {\npublic:\n    // 注册回调函数\n    void registerCallback(Callback cb) {\n        callbacks.push_back(cb);\n    }\n\n    // 触发事件，调用所有注册的回调函数\n    void triggerEvent(int value) {\n        for (const auto& cb : callbacks) {\n            cb(value);\n        }\n    }\n\nprivate:\n    std::vector<Callback> callbacks;\n};\n```\n\n这个系统可以注册回调函数（即存储回调函数），还支持执行回调函数。作为用户如果想要系统执行某个功能，你只需要把功能函数（可调用对象）传递给系统即可，系统会自行安排调用时机（即调用 triggerEvent 方法）。\n\n```c++\nvoid myCallbackFunction(int value) {\n    std::cout << \"Callback function called with value: \" << value << std::endl;\n}\n\nint main() {\n    EventSystem eventSystem;\n\n    // 注册普通函数回调\n    eventSystem.registerCallback(myCallbackFunction);\n\n    // 触发事件（系统执行回调）\n    eventSystem.triggerEvent(42);\n\n    return 0;\n}\n```\n\n","tags":["C++11新特性"],"categories":["technology"]},{"title":"智能指针","url":"/2024/08/16/智能指针/","content":"\n程序员可以自由分配堆内存，而栈内存由编译器申请和释放。内存管理针对的就是堆内存，在C++11的智能指针没有出现之前，为了保证内存合理的申请释放，需要配对操作，即new和delete，malloc和free，来避免内存泄漏。\n\n![智能指针所有权.png](/images/2024/08/16/996afb20-5b93-11ef-922f-4335b82b6d11.png)\n\n## 内存管理及C++ RAII手法\n\nRAII 是 C++ 所特有的资源管理方式，它**依托栈和析构函数**，来对所有的资源(包括堆内存在内)进行管理。它提供了一种**异常安全的资源管理方式**，对RAII的使用，使C++不需要类似于 Java 那样的垃圾收集方法，也能有效的内存进行管理。\n\n```c++\ntemplate<class T>\nclass manageMemory{\n public:\n  explicit manageMemory(T *data):data_(data){\n    std::cout<<\" manageMemory \"<<std::endl;\n  }\n  ~manageMemory(){\n    std::cout<<\" ~manageMemory \"<<std::endl;\n    delete data_;\n    data_ = nullptr;\n  }\n private:\n  T* data_;\n};\n\nclass Test{\n public:\n  explicit Test(int num):num_(num){\n    std::cout<<\" Test \"<<std::endl;\n  }\n  ~Test(){\n    std::cout<<\" ~Test \"<<std::endl;\n  }\n private:\n  int num_ = 0;\n};\n\nint main() {\n\n  {\n    Test* t = new Test(10);\n    manageMemory<Test> mt(t);\n  }\n\n  system(\"pause\");\n\n  return 0;\n}\n```\n\n前面讲 RAII 这种内存管理方法是依托 栈和析构函数，从上面的代码中可以看到 manageMemory 类中的析构函数将传递进来的对象进行 delete（清理类对象的成员变量），并且明显是在 函数中完成对内存进行管理的（这里是在 main 函数中），即栈中（退出栈，清理类对象本身）。\n\n那么还提到异常安全的资源管理方式又是那里体现的呢？假定现在没有采用RAII 这种内存管理方法，而是用之前 delete 裸指针进行内存管理，看如下简略代码：\n\n```c++\nvoid func(){\n  Test* t = new Test(10);\n  \n  // 出现异常\n\n  delete t;\n}\n```\n\n按理我们也写出已申请内存对应的 delete，可如果在 delete 之前出现异常，那么内存泄漏还是出现了。但是我们的 RAII 这种内存管理方法就不会，因为内部不会出现异常。\n\n## 共享智能指针 shared_ptr\n\n| 构造函数                              | 说明                     |\n| ------------------------------------- | ------------------------ |\n| `shared_ptr()`                        | 默认构造函数，指针为空   |\n| `shared_ptr(T* ptr)`                  | 用裸指针构造，拥有对象   |\n| `shared_ptr(const shared_ptr& other)` | 拷贝构造函数，共享所有权 |\n| `shared_ptr(shared_ptr&& other)`      | 移动构造函数，转移所有权 |\n\n| 方法                      | 说明                         |\n| ------------------------- | ---------------------------- |\n| `reset()`                 | 释放当前持有对象，指针为空   |\n| `reset(T* ptr)`           | 释放当前持有对象并拥有新对象 |\n| `get()`                   | 返回原始指针（裸指针）       |\n| `use_count()`             | 返回引用计数                 |\n| `unique()`                | 判断是否是唯一所有者         |\n| `swap(shared_ptr& other)` | 交换两个 `shared_ptr` 的内容 |\n\n共享所有权，具有复制语义，多个 shared_ptr 指向同一个对象时，每个 shared_ptr 的引用计数都会记录指向该对象的 shared_ptr 的数量，当最后一个指向对象（和共享计数）的 shared_ptr 析构时，它会删除对象和共享计数，通过 use_count 方法可以获取 shared_ptr 对象的共享计数值。正以为是共享所有权，那么在多线程中要注意数据竞争问题，当操作同一个对象时记得加锁。\n\n![共享智能.png](/images/2024/08/16/a0b54890-5b93-11ef-922f-4335b82b6d11.png)\n\n### 智能指针的大小\n\nstd::shared_ptr 的尺寸大于裸指针，一般是裸指针的两倍，因为它内部既包含一个指向到资源的裸指针，也包含一个指向该资源的引用计数的裸指针。其中引用计数的内存是动态分配的，且递增和递减是原子操作。\n\n![shared_ptr计数细节.png](/images/2024/08/16/a5c25030-5b93-11ef-922f-4335b82b6d11.png)\n\n下面通过 sizeof 看看是否如此：\n\n```c++\nclass Test{\n public:\n  explicit Test(int num):num_(num){\n    std::cout<<\" Test \"<<std::endl;\n  }\n  ~Test(){\n    std::cout<<\" ~Test \"<<std::endl;\n  }\n private:\n  int num_ = 0;\n};\n\nint main() {\n\n  Test* t1 = new Test(10);\n  std::shared_ptr<Test> s1(t1);\n\n  std::cout<<\"单独的对象 t1 = \"<<sizeof(t1)<<std::endl;\n  std::cout<<\"共享智能指针管理的对象 s1 = \"<<sizeof(s1)<<std::endl;\n\n  return 0;\n}\n```\n\n输出结果：\n\n![智能指针大小.png](/images/2024/08/16/abf9ce10-5b93-11ef-922f-4335b82b6d11.png)\n\n### 避免通过同一个裸指针创建多个 shared_ptr 对象 \n\n:star: shared_ptr 对象**只能通过复制其值来共享所有权**：如果两个 shared_ptr 是从同一个（非 shared_ptr）指针构造（或创建）的，它们将各自拥有该指针而不共享它，这可能导致访问问题，因为当其中一个释放它（删除其管理的对象）时，另一个将指向一个无效的位置。\n\n```c++\nvoid func(){\n  Test* t1 = new Test(10);\n\n  // 两个指针指针分别指向 t1对象\n  std::shared_ptr<Test> s1(t1);\n  std::shared_ptr<Test> s2(t1);\n\n  std::cout<<\"s1 use_count = \"<<s1.use_count()<<std::endl;\n  std::cout<<\"s2 use_count = \"<<s2.use_count()<<std::endl;\n\n  // 其中一个智能指针 释放管理的对象\n  s1.reset();\n  std::cout<<\"s1 use_count = \"<<s1.use_count()<<std::endl;\n  std::cout<<\"s2 use_count = \"<<s2.use_count()<<std::endl;\n}\n```\n\n输出结果：\n\n![重复析构.png](/images/2024/08/16/b46717b0-5b93-11ef-922f-4335b82b6d11.png)\n\n这边有提示重复析构的错误，这是错误使用智能指针出现的问题。 shared_ptr 对象只能通过复制其值来共享所有权，否则会导致计数错误，而 shared_ptr  恰恰是通过 计数来决定管理对象是否析构的，如果计数出现错误，那么管理对象也就会出现错误。在上面的代码中创建两个智能指针 s1 和 s2，直接管理 同一个对象 t1，但是这种错误示范导致无法跟踪真实的计数，导致两个智能指针 s1 和 s2都自以为最开始就管理这个对象。由于接管的这个对象计数是0，它们各自加 1，所以打印智能指针 s1 和 s2的计数情况都是 1，这位后面埋下隐患，即多重析构。我们通过 reset 方法重置 智能指针 s1 的计数为0，那么就会析构管理的对象，但是 s2 却始终以为管理的对象还存在（从输出情况中可以看出，智能指针 s1 的计数已经为 0，但是 s2 的计数还为 1 ），等到退出函数作用域，智能指针 s2 查看计数为 1 并去执行析构函数，导致出现重复析构的错误。\n\n下面修正代码的错误，再看看是否管理内存正确\n\n```c++\nvoid func(){\n  Test* t1 = new Test(10);\n\n  // 两个指针指针分别指向 t1对象\n  std::shared_ptr<Test> s1(t1);\n  std::shared_ptr<Test> s2(s1);\n\n  std::cout<<\"s1 use_count = \"<<s1.use_count()<<std::endl;\n  std::cout<<\"s2 use_count = \"<<s2.use_count()<<std::endl;\n\n  // 其中一个智能指针 释放管理的对象\n  s1.reset();\n  std::cout<<\"s1 use_count = \"<<s1.use_count()<<std::endl;\n  std::cout<<\"s2 use_count = \"<<s2.use_count()<<std::endl;\n}\n```\n\n输出结果：\n\n![正确析构.png](/images/2024/08/16/ba198710-5b93-11ef-922f-4335b82b6d11.png)\n\n### 避免通过 this 指针创建 shared_ptr 对象\n\n```c++\nclass Test{\n public:\n  explicit Test(int num){\n    std::cout<<\" Test \"<<std::endl;\n  }\n  ~Test(){\n    std::cout<<\" ~Test \"<<std::endl;\n  }\n  void process(){\n    data.emplace_back(this);\n    std::cout<<\" data[0] count = \" << data[0].use_count() <<std::endl;\n  }\n private:\n  using pTest = std::shared_ptr<Test>;\n  std::vector<pTest> data;\n};\n\nvoid func(){\n  Test* t1 = new Test(10);\n\n  std::shared_ptr<Test> s1(t1);\n  std::cout<<\" before count = \" << s1.use_count() <<std::endl;\n  s1->process();\n  std::cout<<\" end count = \" << s1.use_count() <<std::endl;\n}\n```\n\n输出结果：\n\n![避免this.png](/images/2024/08/16/c1fa2110-5b93-11ef-922f-4335b82b6d11.png)\n\n创建一个 shared_ptr 对象 s1，并用 t1 初始化它，引用计数加 1，当前引用计数为 1。然后调用 `process` 方法，将 shared_ptr 对象 s1 传递给 shared_ptr 对象 管理，并将其添加到 data 容器中，按理来说引用计数加 1，当前引用计数为 2，但是输出显示当前引用计数为 1，说明 this 不是返回的shared_ptr 对象 s1，而返回的裸指针 t1。\n\nC++11 提供这个问题的解决方案，即 enable_shared_from_this 和 shared_from_this。\n\n如果一个类继承自 std::enable_shared_from_this，那么这个类的实例对象可以通过调用 shared_from_this() 成员函数，**获得一个指向自己的 std::shared_ptr 智能指针**。这个指针可以和其他 std::shared_ptr 共享控制块，从而安全地管理对象的生命周期。\n\n```c++\n#include <iostream>\n#include <vector>\n#include <memory>\n\nclass Test : public std::enable_shared_from_this<Test> {\npublic:\n    explicit Test(int num) {\n        std::cout << \" Test \" << std::endl;\n    }\n    ~Test() {\n        std::cout << \" ~Test \" << std::endl;\n    }\n    void process() {\n        data.emplace_back(shared_from_this());\n        std::cout << \" data[0] count = \" << data[0].use_count() << std::endl;\n    }\nprivate:\n    using pTest = std::shared_ptr<Test>;\n    std::vector<pTest> data;\n};\n\nvoid func() {\n     Test* t1 = new Test(10);\n     std::shared_ptr<Test> s1(t1);\n    std::cout << \" before count = \" << s1.use_count() << std::endl;\n    s1->process();\n    std::cout << \" end count = \" << s1.use_count() << std::endl;\n}\n\nint main() {\n    func();\n    return 0;\n}\n```\n\n输出结果：\n\n![保活.png](/images/2024/08/16/c9cb03a0-5b93-11ef-922f-4335b82b6d11.png)\n\n从输出结果可以看出，没有出现前面的重复析构，并且计数得到正确的增加，因为确实是被两个智能指针指向，计算就应该为 2。但同时我们也看到析构没有被执行，表明 Test 没有被正确管理，这是因为 s1 销毁之后，裸指针 t1 的成员变量 data中还存储着 t1的 shared_ptr 对象，导致引用计数没有归 0。如果你在 Test 的析构函数中对其进行清理是无效的，计数不为 0 的情况下析构函数不会被执行，下面通过一个公共方法来清理内部成员。\n\n```c++\nclass Test : public std::enable_shared_from_this<Test> {\n public:\n  explicit Test(int num) {\n    std::cout << \" Test \" << std::endl;\n  }\n  ~Test() {\n    std::cout << \" ~Test \" << std::endl;\n  }\n  void process() {\n    data.emplace_back(shared_from_this());\n    std::cout << \" data[0] count = \" << data[0].use_count() << std::endl;\n  }\n  void clearData(){\n    data.clear();\n  }\n  int getCount(){\n    if (!data.empty()){\n      return data[0].use_count();\n    }\n    return 0;\n  }\n private:\n  using pTest = std::shared_ptr<Test>;\n  std::vector<pTest> data;\n};\n\nvoid func() {\n  Test* t1 = new Test(10);\n  {\n    std::shared_ptr<Test> s1(t1);\n    std::cout << \" s1 count = \" << s1.use_count() << std::endl;\n    s1->process();\n  }\n\n  std::cout << \" clearData before count = \" << t1->getCount() << std::endl;\n\n  t1->clearData();\n  std::cout << \" clearData end count = \" << t1->getCount() << std::endl;\n}\n\nint main() {\n  func();\n  return 0;\n}\n```\n\n输出结果：\n\n![正确析构2.png](/images/2024/08/16/d2d21c40-5b93-11ef-922f-4335b82b6d11.png)\n\nTest类对象 t1 被创建，执行构造函数。被 shared_ptr对象 s1 管理，引用计数加 1，当前引用计数为 1。调用 process 方法，把对象 t1 加入到 data容器中被 shared_ptr 管理，引用计数加 1，当前引用计数为 2。s1 离开作用域之后被销毁，引用计数减 1，当前引用计数为 1。调用 clearData 方法，清理 data 中的一个 shared_ptr 对象，引用计数减 1，当前引用计数为 0，调用管理的对象 t1 的析构函数。shared_ptr 就是等到管理对象的引用计数为 0 就调用管理对象的析构函数，析构函数本身就是对对象的成员变量的清理，至于对象本身要等到离开作用域之后才会被栈清理。\n\n### 优先使用 make_shared 创建 shared_ptr 对象\n\n- make_shared 会在一个连续的内存块中同时分配控制块和对象本身，即只会产生一次内存分配，对象与计数对象共用一块区域。而使用 new 则需要两次内存分配，一次是对象本身，另一次是为 shared_ptr 的控制块\n- 异常安全的构造 shared_ptr\n\n```c++\nvoid func(std::shared_ptr<Test> t1,int Ret){\n  std::cout<<\"func\"<<std::endl;\n}\n\nint process(){\n  // 可能发生异常\n  return 0;\n}\n\nint main() {\n  func(std::shared_ptr<Test>(new Test(10)), process());\n  return 0;\n}\n```\n\n这种创建 shared_ptr 对象的方式可能出现问题，可能的执行顺序如下：\n\n1. new Test(10)\n2. process()\n3. 构造一个 shared_ptr 对象\n\n但如果 process 出现异常，那么 构造一个 shared_ptr 对象 失败，导致内存泄漏，因为 new Test(10) 已经创建成功。我们现在推荐 make_shared 来创建 shared_ptr 对象。\n\n```c++\nfunc(std::make_shared<Test>(10), process());\n```\n\n## 弱引用指针 weak_ptr\n\n| 构造函数                            | 说明                                 |\n| ----------------------------------- | ------------------------------------ |\n| `weak_ptr()`                        | 默认构造函数，指针为空               |\n| `weak_ptr(const weak_ptr& other)`   | 拷贝构造函数，共享被管理对象的弱引用 |\n| `weak_ptr(const shared_ptr<T>& sp)` | 从 `shared_ptr` 构造，创建弱引用     |\n\n| 方法                    | 说明                                                         |\n| ----------------------- | ------------------------------------------------------------ |\n| `reset()`               | 释放当前持有对象的弱引用                                     |\n| `use_count()`           | 返回被管理对象的引用计数                                     |\n| `expired()`             | 判断被管理对象是否已被销毁（非线程安全）                     |\n| `lock()`                | 返回 `shared_ptr`，如果被管理对象已被销毁则返回空 `shared_ptr` |\n| `swap(weak_ptr& other)` | 交换两个 `weak_ptr` 的内容                                   |\n\nweak_ptr 用来表示临时所有权(弱引用，不会增加引用计数)，它需要配合 shared_ptr 使用，追踪 shared_ptr 所管理的对象是否有效。当需要临时所有权时，则将其转换为 shared_ptr，这样对象的引用计数会加 1，来保证正在访问的对象有效性。也就是说，你如果用 weak_ptr 是无法调用监视对象的成员方法的，需要提升为 shared_ptr 对象才可以。\n\nweak_ptr 具有复制语义，可以通过一个 weak_ptr 对象构造另一个 weak_ptr 对象，通过一个 shared_ptr 构造一个 weak_ptr 对象。\n\n### expired 和 lock \n\n可以利用 expired 先检查管理的对象是否已被销毁，然后选择把 weak_ptr 转换为 shared_ptr 对象。就像下面这样：\n\n```c++\nstd::shared_ptr<Test> t1 = std::make_shared<Test>(10);\nstd::weak_ptr<Test> w1(t1);\nstd::cout<<\"w1 use_count = \"<<w1.use_count()<<std::endl;\nif (!w1.expired()){ // false 意味着没有被销毁\n  std::shared_ptr<Test> t2(w1);\n  std::cout<<\"w1 use_count = \"<<t2.use_count()<<std::endl;\n}\n```\n\n但是这里有个问题，如果`!w1.expired()`通过，但是正准备创建 shared_ptr 对象t2，发现被其它线程已经把 t1销毁，就会出现未定义错误，这不是线程安全的写法。\n\nlock 方法可以很好的解决这个问题，因为如果 t1 没有被销毁，就会 lock 成功，否则失败。\n\n```c++\nstd::shared_ptr<Test> t1 = std::make_shared<Test>(10);\nstd::weak_ptr<Test> w1(t1);\nstd::cout<<\"w1 use_count = \"<<w1.use_count()<<std::endl;\nif (w1.lock ()){ //  true 意味着 还没有被销毁\n  std::shared_ptr<Test> t2(w1);\n  std::cout<<\"w1 use_count = \"<<t2.use_count()<<std::endl;\n}\n```\n\n### weak_ptr 与 shared_ptr 避免循环引用\n\n```c++\n#include <iostream>\n#include <memory>\n\nclass B; // 前向声明\n\nclass A {\n public:\n  std::shared_ptr<B> b_ptr;\n  A(){std::cout << \"A\\n\";}\n  ~A() { std::cout << \"~A\\n\"; }\n};\n\nclass B {\n public:\n  std::shared_ptr<A> a_ptr;\n  B(){std::cout << \"B\\n\";}\n  ~B() { std::cout << \"~B\\n\"; }\n};\n\nint main() {\n  {\n    // 创建循环引用\n    std::shared_ptr<A> a = std::make_shared<A>();\n    std::shared_ptr<B> b = std::make_shared<B>();\n    a->b_ptr = b;\n    b->a_ptr = a;\n  }\n  // 循环引用导致 A 和 B 没有被销毁\n\n\n  return 0;\n}\n```\n\n输出结果：\n\n![循环引用.png](/images/2024/08/16/dc0c79e0-5b93-11ef-922f-4335b82b6d11.png)\n\n从结果上可以看到，没有执行所创对象的析构函数，这明显是 shared_ptr 管理的对象引用计数没有 归 0。\n\n创建 shared_ptr 对象 a 管理类 A 对象，a 的引用计数加 1，当前引用计数为 1。创建 shared_ptr 对象 b 管理类 B 对象，b 的引用计数加 1，当前引用计数为 1。接下来将类对象 A 的 成员变量 b_ptr 赋值为前面创建的 b，b 的引用计数加 1，当前引用计数为 2。接下来将类对象 B 的 成员变量 a_ptr 赋值为前面创建的 a，a 的引用计数加 1，当前引用计数为 2。离开作用域之后，a 和 b 都被销毁，各自对应的引用计数减 1，且当前引用计数为 1。也就是说引用计数都没有归 0，这是没有析构的原因。\n\n只需要把其中任意一方从 shared_ptr 用 weak_ptr 替代即可，因为 weak_ptr 不增加引用计数。\n\n```c++\nclass B; // 前向声明\n\nclass A {\n public:\n  std::shared_ptr<B> b_ptr;\n  A(){std::cout << \"A\\n\";}\n  ~A() { std::cout << \"~A\\n\"; }\n};\n\nclass B {\n public:\n  std::weak_ptr<A> a_ptr;\n  B(){std::cout << \"B\\n\";}\n  ~B() { std::cout << \"~B\\n\"; }\n};\n```\n\n输出结果：\n\n![解决循环引用.png](/images/2024/08/16/e2174270-5b93-11ef-922f-4335b82b6d11.png)\n\n## 独占智能指针 unique_ptr\n\n| 构造函数                     | 说明                     |\n| ---------------------------- | ------------------------ |\n| `unique_ptr()`               | 默认构造函数，指针为空   |\n| `unique_ptr(T* ptr)`         | 用裸指针构造，拥有对象   |\n| `unique_ptr(unique_ptr&& u)` | 移动构造函数，转移所有权 |\n| `operator=(unique_ptr&& u)`  | 移动赋值，转移所有权     |\n\n| 方法                      | 说明                             |\n| ------------------------- | -------------------------------- |\n| `reset()`                 | 释放当前持有对象，指针为空       |\n| `reset(T* ptr)`           | 释放当前持有对象并拥有新对象     |\n| `release()`               | 释放所有权并返回裸指针           |\n| `get()`                   | 返回裸指针                       |\n| `swap(unique_ptr& other)` | 交换两个 `unique_ptr` 的内容     |\n| `make_unique<T>(...)`     | 创建并返回一个 `std::unique_ptr` |\n\nunique_ptr 代表的是独占私有权，它没有拷贝语义（没有赋值构造函数和赋值函数），只可以通过移动操作move来转移所有权。\n\n注：make_unique 是C++14 才补充的\n\n### move 转移所有权\n\n```c++\n#include <iostream>\n#include <memory>\n#include <unistd.h>\n\nclass Test{\n public:\n  Test(const std::string &str):str_(str){\n    std::cout<<\"Test \"<<str_<<std::endl;\n  }\n  ~Test(){\n    std::cout<<\"~Test \"<<str_<<std::endl;\n  }\n private:\n  std::string str_;\n};\n\nint main() {\n\n  std::unique_ptr<Test> t1 = std::make_unique<Test>(\"t1\");\n  std::unique_ptr<Test> t2 = std::make_unique<Test>(\"t2\");\n  t1 = std::move(t2);   // t2 所有权转移给 t1\n\n  pause();\n  return 0;\n}\n```\n\n输出结果：\n\n![独占.png](/images/2024/08/16/e8987380-5b93-11ef-922f-4335b82b6d11.png)\n\n把 unique_ptr 对象 t2 的所有权转移给 unique_ptr 对象 t1，执行 t1 的析构函数。也就是说接受所有权的 t1 会把之前管理的对象进行析构，然后接受最新对象的所有权。\n\n### release 和 get 的区别\n\n release 释放所有权并返回裸指针，并不会销毁管理的对象，即不会调用其析构函数。只是单纯的不再用 unique_ptr 管理这个对象而已，所以要必须在某个时候负责删除该对象，避免内存泄漏。\n\nget 不会释放所有权并返回裸指针，它仍负责在某个时间点删除托管数据。因此，此函数返回的值不得用于构造新的托管指针。\n\n```c++\n#include <iostream>\n#include <memory>\n\nclass MyClass {\npublic:\n    MyClass() { std::cout << \"MyClass Constructor\\n\"; }\n    ~MyClass() { std::cout << \"MyClass Destructor\\n\"; }\n};\n\nint main() {\n    // 创建一个 unique_ptr，管理一个 MyClass 实例\n    std::unique_ptr<MyClass> up1(new MyClass());\n\n    // 使用 get() 方法获取裸指针\n    MyClass* rawPtr = up1.get();\n\n    // 尝试用裸指针构造新的 unique_ptr\n    // 这是错误的，因为两个 unique_ptr 都会尝试管理同一个指针\n    std::unique_ptr<MyClass> up2(rawPtr);\n\n    // 当 up1 和 up2 作用域结束时，都会尝试删除同一个 MyClass 实例，导致未定义行为\n    return 0;\n}\n```\n\n### unique 的实际应用\n\n1. 配合 shared_ptr 实现工厂模式\n2. unique_ptr 不支持拷贝语义，直接将一个 unique_ptr 对象存入容器是不行的，必须通过 std::move 将 unique_ptr 对象\"移动\"到容器\n3. unique_ptr 有个数组版本，支持动态数组（shared_ptr 就不可以）\n\n## shared_ptr 与 uinque_ptr 的删除器\n\n删除器决定了智能指针在销毁时如何释放所管理的资源。shared_ptr 不能删除数组，但是 unique_ptr 可以删除数组。\n\n```c++\n#include <iostream>\n#include <memory>\n\nvoid customDeleter(int* ptr) {\n    std::cout << \"Custom deleter called\\n\";\n    delete ptr;\n}\n\nint main() {\n    std::shared_ptr<int> sp(new int(42), customDeleter);\n\n    std::cout << \"Value: \" << *sp << std::endl;\n\n    // 当 sp 超出作用域时，customDeleter 会被调用\n    return 0;\n}\n```\n\n```c++\n#include <iostream>\n#include <memory>\n\nint main() {\n    std::unique_ptr<int[]> up(new int[5]);\n\n    for (int i = 0; i < 5; ++i) {\n        up[i] = i * 10;\n    }\n\n    for (int i = 0; i < 5; ++i) {\n        std::cout << up[i] << \" \";\n    }\n    std::cout << std::endl;\n\n    // 当 up 超出作用域时，delete[] 会被调用\n    return 0;\n}\n```","tags":["C++11新特性"],"categories":["technology"]},{"title":"第二章：函数式编程之旅","url":"/2024/08/16/第二章：函数式编程之旅/","content":"\n## 函数使用函数\n\n所有函数式编程语言的主要特色就是函数可被看作一个普通的值。它们可被存储于变量中，放到集合或结构中，作为参数传递给其他函数，并可以作为其他函数的返回结果中。能够接收函数作为参数或返回函数作为结果的函数称为**高阶函数**。\n\n我们来看一个实例：假设有一组人，需要写出组内所有女性的名字。如下图所示。\n\n![一个实例.png](/images/2024/08/16/0b7c66c0-5b78-11ef-ad1f-31ad8bab6002.png)\n\n也就是说组内由男性和女性组成，先要把男性过滤掉而剩下女性（过滤），然后获取这些女生的名字（转换）。\n\n这里使用的首个高阶结构是集合过滤。通俗地讲，过滤是一个简单的算法，它主要检查原集合中的每个条目是否满足一定的条件。如果满足，则该条件被放入结果集中。**过滤算法并不能事先知道用户对他们的集合使用什么样的谓词函数进行过滤**。过滤可以针对一个特定的属性（如本例中的性别属性的值），也可以同时针对多个属性（如找到所有黑头发的女性），或更复杂的过滤条件（获取最近购买新车的所有女性）。因此，这种结构必须提供一种方法，可以让用户指定所需的谓词。在这个例子中，这个结构需要提供一个接收人的谓词，并返回这个人是不是女性。因为过滤允许传递一个谓词函数，按照定义，它是一个高阶函数。如果想从 STL 中找到具体的例子，常用的 sort 的第三个参数接受谓词，用户可以自实现谓词来筛选集合中的元素满足条件的情况下返回，比方说集合中所有元素从小到大进行排序。\n\n过滤任务完成后，还有获取姓名的任务。需要一个结构，它接收一组人并可返回他们的名字。与过滤类似，这个结构也不能事先知道要从原集合中选取哪些值。用户可能想获取一个特定的属性(如这个例子中的姓名)、多个属性组合(可能需要找到姓和名并把它们拼接起来)，或更复杂的操作(获取一个人的所有孩子)。同样，这个结构也需要允许用户指定一个函数，从集合中获取一个条目，对条目进行某些操作，并返回一个值，把这个值放在结果集中。请注意，输出集合没必要与输入集合包含相同的类型（这一点与过滤不同）。这种结构称为映射（map）或转换（transform）。\n\n## STL实例\n\nSTL 中有很多高阶函数，这里简单介绍几个，后续有可能会单独写一篇实践常用的 STL 中提供的高阶函数\n\n### 求平均值\n\nstd::accumulate 用来求和，其中：\n\n- first 和 fast 代表容器的起始迭代器和结尾迭代器\n- init 指定累加器的初始值\n- 二元运算符，用于指定累加操作的类型。如果不指定，默认为加法（二进制操作将类型为T的元素（即 init）作为第一个参数，将范围内的元素作为第二个参数，并返回可以分配给类型T的值）\n\n```c++\ntemplate <class InputIterator, class T>  \nT accumulate (InputIterator first, InputIterator last, T init);\n\ntemplate <class InputIterator, class T, class BinaryOperation>   \nT accumulate (InputIterator first, InputIterator last, T init,BinaryOperation binary_op);\n\n\n// 等价于\n\n{\n  while (first!=last) {\n    init = init + *first;  // or: init=binary_op(init,*first) for the binary_op version\n    ++first;\n  }\n  return init;\n}\n```\n\n不指定函数对象的实践代码。\n\n```c++\n#include <iostream>\n#include <vector>\n#include <numeric>\nusing namespace std;\nint main() {\n\n  vector<int> s = {2,1,0,25,-32,78,-21,-10,21};\n  int result = 0;\n  result = std::accumulate(s.begin(),s.end(),0);\n\n  std::cout<<\"result = \"<<result<<std::endl;\n\n  return 0;\n}\n/*\n\tresult = 64\n*/\n```\n\n指定函数对象的实践代码，使用了乘法运算符 `std::multiplies<int>()`，计算了所有元素的乘积。\n\n本质上是将 init 和 容器中每一个元素逐一相乘，如下代码含义为 2 * 1 * 2 * 3 * 4 * 5。\n\n```c++\n#include <iostream>\n#include <vector>\n#include <numeric>\nusing namespace std;\nint main() {\n\n  vector<int> s = {1,2,3,4,5};\n  int result = 0;\n  result = std::accumulate(s.begin(),s.end(),2,std::multiplies<int>());\n    \n   /*\n   \t等价于\n   \t  result = std::accumulate(s.begin(),s.end(),2,[](int a,int b){\n    \treturn a * b;\n \t });\n   */\n\n  std::cout<<\"result = \"<<result<<std::endl;\n\n  return 0;\n}\n\n/*\n\tresult = 240\n*/\n```\n\n### 折叠\n\nstd::accumulate 算法是折叠的一种实现。这是一个高阶函数，它提供了对递归结构，如向量、列表和树等的遍历处理，并允许逐步构建自己需要的结果。\n\n![折叠计算.png](/images/2024/08/16/01cfbf50-5b78-11ef-ad1f-31ad8bab6002.png)\n\n上面关于 std::accumulate 的实践代码，会让大家决定 init 的类型 要和 容器中元素的类型相同，实际上并没有这个要求，类型可以不同。下面的代码中，我们统计字符串 data 中字母的个数。\n\n```c++\n#include <iostream>\n#include <vector>\n#include <numeric>\nusing namespace std;\nint main() {\n\n  std::string data = \"www.baidu.com\";\n  auto result = std::accumulate(data.begin(),data.end(),0,[](int count,char c){\n    if (isalpha(c)){\n      count++;\n    }\n    return count;\n  });\n\n  std::cout<<\"result = \"<<result<<std::endl;\n\n  return 0;\n}\n\n/*\n\tresult = 11\n*/\n```\n\n折叠中有两种类型，一种是左折叠（从左往右开始遍历元素），一种是右折叠（从右往左开始遍历元素）。前面都是左折叠，C++ 也没有也没有提供独立的右折叠算法，但是我们可以通过传递反向迭代器来实现右折叠算法（crbegin 和 crend）。\n\n### 删除字符串空白符\n\nstd::find_if：查找集合中第一个满足指定谓词的元素。\n\n```c++\ntemplate <class InputIterator, class UnaryPredicate>   \nInputIterator find_if (InputIterator first, InputIterator last, UnaryPredicate pred);\n\n//等价于\n\n{\n  while (first!=last) {\n    if (pred(*first)) return first;\n    ++first;\n  }\n  return last;\n}\n```\n\n下面演示删除一个字符串左右两边的空白。\n\n```c++\n#include <iostream>\n#include <vector>\n#include <numeric>\nusing namespace std;\n\nstd::string trim_left(std::string str){\n  str.erase(str.begin(),std::find_if(str.begin(),str.end(),[](char c){\n    return !isspace(c);\n  }));\n  return str;\n}\n\nstd::string trim_right(std::string str){\n  str.erase(std::find_if(str.rbegin(),str.rend(),[](char c){\n    return !isspace(c);\n  }).base(),str.end());\n  return str;\n}\n\nint main() {\n\n  std::string data = \"   www.baidu.com   \";\n\n  std::cout<<trim_right(trim_left(data));\n\n  return 0;\n}\n\n/*\n\twww.baidu.com\n*/\n```\n\nstd::find_if 返回值为满足条件的所处位置的迭代器。trim_right 有用到 反向迭代器，`.base()` 返回的是反向迭代器的正向迭代器，指向找到的非空白字符的下一个位置。\n\n### 基于谓词分割集合\n\n在学习更多知识之前，假设有一个人的集合，需要把所有女性移到集合的前面。为了实现这一功能，可以使用 std::partition 和它的变体 std::stable_partition（相较于std::partition，可以保持集合中原来的顺序）。\n\n```c++\ntemplate <class ForwardIterator, class UnaryPredicate>  \nForwardIterator partition (ForwardIterator first,ForwardIterator last, UnaryPredicate pred);\n\n\ntemplate <class BidirectionalIterator, class UnaryPredicate>  \nBidirectionalIterator stable_partition (BidirectionalIterator first,BidirectionalIterator last,UnaryPredicate pred);\n```\n\n两个算法都接收一个集合和一个谓词。它们对原集合中的元素进行重排，把符合条件的与不符合条件的分开。符合谓词条件的元素移动到集合的前面，不符合条件的元素移动到集合的后面。算法返回一个迭代器，指向第二部分的第一个元素(不符合谓词条件的第一个元素)。返回的迭代器和原集合开头的迭代器配合，获取集合中满足谓词条件的元素(构成的集合)，与原集合尾端迭代器配合，可获得原集合中不符合谓词条件的元素(构成的合)。即使这些集合中存在空集合也是正确的。\n\n```c++\nint main() {\n\n  vector<int> data = {1,7,-2,10,-10,43,55,-99,-89};\n  auto its = std::partition(data.begin(),data.end(),[](int num){\n    return num > 0;\n  });\n\n  std::cout<<\"正数集合 = \";\n  auto itBegin = data.begin();\n  for (; itBegin != its ; itBegin++) {\n    std::cout<< *itBegin << \" \";\n  }\n\n  std::cout << std::endl;\n\n  std::cout<<\"负数集合 = \";\n  for (; its != data.end(); its++) {    \n    std::cout<< *its << \" \";\n  }\n  \n  return 0;\n}\n\n/*\n\t正数集合 = 1 7 55 10 43 \n\t负数集合 = -10 -2 -99 -89 \n*/\n```\n\n可以看到 std::partition 返回的迭代器 its 就是一个分界线，data.begin() ~ its 是符合条件的元素，its ~ data.end() 是不符合条件以外的元素。\n\n还有明显看到输出没有保持顺序性，只需要把 std::partition 替换成 std::stable_partition 即可。\n\n```c++\n正数集合 = 1 7 10 43 55 \n负数集合 = -2 -10 -99 -89\n```\n\n### 过滤和转换\n\n```c++\ntemplate <class ForwardIterator, class UnaryPredicate>  \nForwardIterator remove_if (ForwardIterator first, ForwardIterator last, UnaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator, class UnaryPredicate>  \nOutputIterator copy_if (InputIterator first, InputIterator last, OutputIterator result, UnaryPredicate pred);\n```\n\nremove_if 删除指定范围内满足条件的元素，对容器会有改动。\n\ncopy_if 复制指定范围内满足条件的元素到另一个容器中，对容器不会有改动。\n\n```c++\nint main() {\n  std::vector<int> data = {1,7,-2,10,-10,43,55,-99,-89};\n\n  // 复制负数到 Fdata\n  std::vector<int> Fdata;\n  std::copy_if(data.begin(), data.end(), std::back_inserter(Fdata), [](int num) {\n    return num < 0;\n  });\n\n  std::cout << \"复制负数到指定容器中 = \";\n  for (int i : Fdata) {\n    std::cout << i << \" \";\n  }\n  std::cout << std::endl;\n\n  // 移除 data 中的负数\n  auto it = std::remove_if(data.begin(), data.end(), [](int num) {\n    return num < 0;\n  });\n  data.erase(it, data.end());\n\n  std::cout << \"移除容器中负数后 = \";\n  for (int i : data) {\n    std::cout << i << \" \";\n  }\n  std::cout << std::endl;\n\n  return 0;\n}\n/*\n\t复制负数到指定容器中 = -2 -10 -99 -89 \n\t移除容器中负数后 = 1 7 10 43 55 \n*/\n```\n\nstd::copy_if  和 std::back_inserter ：使用 std::back_inserter 可以直接将元素追加到 Fdata 中，因此不需要手动调整容器大小。\n\nstd::remove_if 和 erase：在 std::remove_if 后，通过 erase 函数真正删除负数元素，因为 std::remove_if 是把移除的元素放到后面并没有真正移除。\n\n## STL算法的可组合性\n\n基于 STL 的实现会生成不必要的 people 集合的副本（这是一个耗时的操作，甚至可能在拷贝构造函数被删除或私有时被禁用），并且会创建一个实际上并不需要的附加向量。为了解决这些问题，可使用引用或指针而不是副本，或者创建一个智能的迭代器，它可跳过所有不是女性的人员等。但这些额外的工作表明STL在这场战斗中已经输了，手写循环更好、更省力。\n\n![STL可组合性.png](/images/2024/08/16/f7765d20-5b77-11ef-ad1f-31ad8bab6002.png)\n\n虽然标准的算法提供了一种编写函数式风格代码的方式，而没必要手动编写循环和分支，但它们并没有设计成其他函数式编程库或语言一样的可组合的。后续使用 range 可以有所改观，到时候再谈。\n\n## 编写自己的高阶函数\n\n### 接收函数作为参数\n\n在 C++ 中，许多东西的行为类似于函数，但没有通用的类型用于存放类似函数的东西，而不损害程序的性能。可以把函数类型用作模板参数，让编译器在编译时确定具体的类型，而不是猜测哪种类型更好：\n\n```c++\ntemplate <typename FilterFun>\nstd::vector<std::string> names_for(\n\tconst std::vector<person_t> & people,\n\tFilterFun filter);\n```\n\n这将允许用户传递任何类似函数的东西作为参数，可以向普通的函数一样调用它。\n\n### 用循环实现\n\n几乎所有的STL算法都是由循环实现的，当你决定自己实现某个算法需要考量这样做的必要性，否则应该使用STL算法。这有几个原因。首先是简单。使用别人的代码节省时间。这也就引出了第二个好处：正确性。如果同样的东西写了一遍又一遍，一时疏忽产生错误也理所当然。STL经过了严格的测试，对于任何输入都能正常工作。基于同样的原因，使用硬编码循环实现的常用函数（我们自己实现的），也必须通过测试。\n\n虽然很多STL算法不是纯的，但它们被设计成高阶函数，这样它们就更通用，适用于更多的场合。如果某些东西被经常使用，它也不太可能包含前面不可见的缺陷。\n\n### 递归和尾调用优化\n\n前面的解决方案从外面看是“纯”的，但具体的实现却不是。当发现一个新的符合条件的人员时，它就要修改结果向量。在纯函数式编程语言中是不存在循环的，遍历集合的函数通常是由递归实现的。本书并不深入研究递归，因为读者并不常用到它，但需要说明一些重要的东西。\n\n对于一个非空向量，可以递归地处理它的头（第一个元素）和尾（所有其他元素），这又可以被看作一个向量。如果头满足谓词，则把它包含在结果中。如果接收到一个空向量，则什么也不需要处理，也就返回一个空向量。\n\n![相互递归实现.png](/images/2024/08/16/eebc7a20-5b77-11ef-ad1f-31ad8bab6002.png)\n\n这种实现是低效的。首先，由于某种原因导致向量的 tail 函数不存在：它需要创建一个新向量并将旧向量中的所有数据复制到其中（第一个元素除外）。tail 函数的问题可用一对迭代器代替向量作为输入来解决。在这种情况下，获取向量尾变得很简单--只需要移动迭代器，使它指向第一个元素即可如下图所示。\n\n![递归实现.png](/images/2024/08/16/e8d69eb0-5b77-11ef-ad1f-31ad8bab6002.png)\n\n这种实现的第二个问题是，把元素插入在向量的前端。这种情况并不多。在硬编码的循环中使用添加，在向量连接时，比前置(插入)更高效。最后也可能是最重要的问题是如果集合大量调用这个函数，可能会出现问题。每次递归都要占用堆栈中的内存，如果堆栈溢出则程序崩溃。即使集合不够大，不会导致堆溢出，但函数调用也要付出代价，简单的循环比它更高效。\n\n虽然前面的问题容易解决，但这个不同。这里需要**依赖编译器把递归转换成循环**。**为了让编译器进行转换，必须实现称为尾递归的形式**。在尾递归中，递归调用是函数的最后一件事情：递归后不能做任何事情。\n\n**尾递归函数**是一种递归函数，其中递归调用发生在函数的最后一步。在尾递归中，递归调用之后不再需要执行任何其他操作，因此可以直接返回递归调用的结果。尾递归函数的一个重要特性是，它可以被编译器或解释器优化为迭代形式，从而节省栈空间，避免递归调用过深导致的栈溢出。\n\n```c++\n普通递归\n\nint factorial(int n) {\n    if (n == 0) {\n        return 1;\n    } else {\n        return n * factorial(n - 1);\n    }\n}\n\n尾递归\n\nint factorial_tail(int n, int acc = 1) {\n    if (n == 0) {\n        return acc;\n    } else {\n        return factorial_tail(n - 1, n * acc);\n    }\n}\n```\n\n普通递归的实现中，`factorial(n - 1)` 的结果需要与 `n` 相乘，然后才返回给上层调用，因此这不是尾递归。\n\n在尾递归的实现中，递归调用 `factorial_tail(n - 1, n * acc)` 是函数的最后一步操作，并且将累积的结果通过 `acc` 参数传递下去。这里没有其他操作依赖于递归调用的返回值，因此这是尾递归。\n\n递归是一种强大的机制，可以让用户在不支持循环的语言中实现循环。但递归仍然属于低水平的结构。可以通过递归实现内部的“纯洁”性，但在许多情况下这样做没有意义。递归，就像手写循环，有它的一席之地。但在C++中，代码评审时就会出现问题。需要C++函数式编程检查它的正确性，并且保证在所有情况下都不会堆栈溢出。\n\n### 使用折叠实现\n\n前面已经见过折叠，但还没有从根本上理解它。折叠（Folding）一次取得一个元素，并对以前积累的值（是一个集合）和当前元素施加指定的函数，产生一个新的累积值。实质上，折叠只不过是编写尾递归函数遍历集合的一种更好的方式。共同的部分被抽取出来，用户只需要指定集合、初始值和必需的累加处理过程，而没必要编写递归函数。\n\n![折叠实现.png](/images/2024/08/16/e30e5d60-5b77-11ef-ad1f-31ad8bab6002.png)\n\n---\n\n⭐️内容取自译者程继洪、孙玉梅、娄山佑《函数式编程》，仅从中取出个人以为需要纪录的内容。不追求内容的完整性，却也不会丢失所记内容的逻辑性。如果需要了解细致，建议读原书。","tags":["函数式编程"],"categories":["technology"]},{"title":"第一章：前言","url":"/2024/08/15/第一章：前言/","content":"\n## 无处不在的分工\n\n### 分工\n\n如果他们各自独立工作，不专习一种特殊业务，那么他们不论是谁，绝对不能一日制造二十枚针，说不定一天连一枚也制造不出来。\n\n社会的发展需要分工，专门的人干专门的事，才能提高社会的生成效率，有了分工就必须要有合作，分工越是精细，那么合作的方式就越复杂，合作的这种模式就是我们说的架构。而计算机和互联网的发展，也出现了分工的现象。\n\n### 为什么分工\n\n首先是人的精力有限，不可能把所有需要的知识学完再去制作，效率极低。再者就是分工和分工可以组合，比方说电脑由多个组件构成，可以根据用户的需求进行定制。有些人用电脑只是办公，也就不需要性能很强的CPU；有些人用电脑需要打3A游戏大作，就需要性能很强的CPU，可以说越强越好。我们只要把电脑拆分成一个一个组件，才会有组合的可能，同样的商品却可以有极大的区别。况且独立出来，如果出问题也不至于导致整体失效，比方说键盘坏掉，可以单独修理键盘（希望你不是把水倒进电脑里面了，那就不只是键盘了）。\n\n### 分工带来的问题\n\n分工越细，各组件的关系可能会越复杂，协调成本也逐渐增高，而且由于建立联系了，彼此之间还会相互影响，如果某个组件损坏，可能导致整个系统不可用，尽管这也是架构师应该未雨绸缪的地方。\n\n1. 关系复杂\n2. 协调成本\n3. 相互影响\n\n### 解决方式\n\n设计规则和协议用以协调各个分工的组件，让整个系统按照逻辑正常运行。\n\n1. 制定规则\n2. 遵守协议\n3. 协调关系\n\n## 软件行业里面的分工\n\n### 软件的分工\n\n就简单用通信协议举例，TCP适用于尽可能保证信息不丢失的场景，UDP适用于快速响应且允许丢失小部分数据的场景。各有各的应用场景，确定场景选择合适的组合。\n\n存储特性：MYSQL、HBase、TiDB、Elastic、Redis、ETCD、Zookeeper、Druid\n\n语言特性：C、C++、Java、Python、Go、JavaScript\n\n通信特性：TCP、UDP、HTTP、HTTPS、MQTT\n\n协议特性：protobuffer、brpc、dubbo、RMI、Hessian、Thrift\n\n场景特性：To C、物联网、金融、电商、网游、社交、门户、AI\n\n### 架构设计的目的\n\n软件系统由于分工带来的复杂问题，需要通过架构进行组合协调，架构就是为了解决这些复杂问题而生的。\n\n## 什么是架构\n\n为了满足特定需求，根据各个部件的特性进行组合一种方式，就是架构。\n\n建房子需要架构，钢筋混凝土如何搭配、承重墙放在哪、圈梁怎么设计、顶梁柱放到哪？\n\n一个企业需要架构，部门划分、职责划分、决策组成、协调规则。\n\n一个国家需要结构，是联邦政府、还是中央集权（《盐铁论》，桑弘羊，析骨而炊）、分封制（商周，石器）。\n\n## 架构师的职责\n\n### 架构设计\n\n需求挖掘（发现问题）、整理方案（技术选型、演进方向、权衡取舍）、多方评审。\n\n### 落地推动\n\n制定计划、安排人力、协调资源、处理意外、质量保证、按期交付、汇报结果。\n\n### 管理\n\n这恐怕要单独出一个教程。","tags":["架构设计入门"],"categories":["technology"]},{"title":"946.验证栈序列","url":"/2024/08/15/946-验证栈序列/","content":"\n```c++\nclass Solution {\npublic:\n    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {\n        stack<int> data;\n        int len = pushed.size();\n        int pushLine = 0;\n        int popLine = 0;\n\n        for(pushLine; pushLine < len;){\n            if(pushed[pushLine] == popped[popLine]){\n                popLine++;\n                pushLine++;\n            }else{\n                if(!data.empty() && (popped[popLine] == data.top())){\n                    data.pop();\n                    popLine++;\n                }else{\n                    data.push(pushed[pushLine]);\n                    pushLine++;\n                }\n            }\n        }\n\n        for(popLine; popLine < len; popLine++){\n            if(popped[popLine] != data.top()){\n                return false;\n            }\n            data.pop();\n        }\n\n        return true;\n    }\n};\n```\n\n上面这份代码较为原始，明显感受出是按照正常思维去解题，就让我想起《最小栈》那道题，在简单思考可行性之后就开始写代码，也没想过有些地方可以被优化。优化的代码如下：\n\n```c++\nclass Solution {\npublic:\n    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {\n        stack<int> data;\n        int len = pushed.size(); \n        int popLine = 0; \n\n        for (int pushLine = 0; pushLine < len; ++pushLine) {\n            data.push(pushed[pushLine]);\n\n            while (!data.empty() && data.top() == popped[popLine]) {\t// 核心优化\n                data.pop(); \n                ++popLine;  \n            }\n        }\n        \n        return data.empty();\n    }\n};\n```\n\n其实就相当于把我源代码中的最后一个 for 循环的操作放到第一个 for 循环中用 while 循环处理了。","tags":["栈"],"categories":["leetcode"]},{"title":"844.比较含退格的字符串","url":"/2024/08/15/844-比较含退格的字符串/","content":"\n```c++\nclass Solution {\npublic:\n    string clearBK(string &str){\n        string data;\n        for(auto s : str){\n            if(s != '#'){\n                data.push_back(s);\n            }else{\n                if(!data.empty()){\n                    data.pop_back();\n                }\n            }\n        }\n        return data;\n    }\n    bool backspaceCompare(string s, string t) {\n        return clearBK(s) == clearBK(t);\n    }\n};\n```\n\n这道题我要提及的点是，当我们企图利用栈的对称性解决问题，如果这个返回值为字符串，那我们可以直接利用字符串作为栈来使用，因为它支持向后插入和向后弹出，这样我们就处理完就可以直接返回结果，也是相当方便了。\n\n也许我不该强调这道题的对称性，而应该表述为 利用栈实现消消乐。","tags":["栈"],"categories":["leetcode"]},{"title":"739.每日温度","url":"/2024/08/15/739-每日温度/","content":"\n```c++\nclass Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& temperatures) {\n        vector<int> result(temperatures.size(), 0);\n        stack<int> data; // 存储下标\n\n        for (int i = 0; i < temperatures.size(); i++) {\n            while (!data.empty() && temperatures[i] > temperatures[data.top()]) {   // 单调递减栈\n                result[data.top()] = i - data.top();\n                data.pop();\n            }\n            data.push(i);\n        }\n        return result;\n    }\n};\n```\n\n前面做的一些关于栈的题目，通常只涉及两类：\n\n- 一类是利用栈的对称性（20.有效的括号）\n- 另一类是利用栈的接口，这本质上是在熟悉使用栈接口的基础上再加上一些与题目相关的思路解题（155.最小栈和232.用栈实现队列）\n\n然而，此题并不在上面之中，也是极容易被忘记的题型，即[单调栈](https://www.yuque.com/xiaoyang-wyxle/gfavbr/tgfk50tuyw1dalb6)。这也是我为何给单独给此类题型一个标签，这本身属于栈这个范围，因为单调栈就是在栈的基础上保留顺序的特性，但是又因为这种题的技巧容易被遗忘（反正我是这样），必须单独拎出来强调一番。\n\n当我们想要维持顺序，且有如下要求：\n\n1. 寻找数组中每个数左边第一个比它小的数，使用单调递增栈\n2. 寻找数组中每个数左边第一个比它大的数，使用单调递减栈\n3. 寻找数组中每个数右边第一个比它小的数，使用单调递增栈\n4. 寻找数组中每个数右边第一个比它大的数，使用单调递减栈\n\n在此题中，我们要寻找数组中每个数右边第一个比它大的数，使用单调递减栈。","tags":["栈","单调栈"],"categories":["leetcode"]},{"title":"232.用栈实现队列","url":"/2024/08/15/232-用栈实现队列/","content":"\n```c++\nclass MyQueue {  \npublic:  \n    MyQueue() {}  \n      \n    void push(int x) {   // 将元素 x 推到队列的末尾  \n        dataSrc.push(x);  \n    }  \n      \n    int pop() { // 从队列的开头移除并返回元素  \n        int val = peek();  \n        dataTop.pop();  \n        return val;  \n    }  \n      \n    int peek() {    // 返回队首元素  \n  \n        if(dataTop.empty()){  \n            while(!dataSrc.empty()){  \n                dataTop.push(dataSrc.top());  \n                dataSrc.pop();  \n            }  \n        }  \n  \n        return dataTop.top();  \n    }  \n      \n    bool empty() {  \n        if(dataTop.empty() && dataSrc.empty()) return true;  \n        return false;  \n    }  \nprivate:  \n    stack<int> dataSrc;  \n    stack<int> dataTop;  \n}; \n```\n\n这里面巧妙的地方在于，返回队首元素时：\n\n- 如果 dataTop 不为空就返回对应的 top 即可\n- 如果 dataTop 为空，就把 dataSrc 全部转移到 dataTop  中即可，返回对应的 top 之后，并不需要把 dataTop 中的元素返回到 dataSrc 中（我记得第一次做这道题是这么搞的，其实可以被这样优化）","tags":["栈"],"categories":["leetcode"]},{"title":"225.用队列实现栈","url":"/2024/08/15/225-用队列实现栈/","content":"\n```c++\nclass MyStack {\nprivate:\n    queue<int> storage; //数据往此处存储\n    queue<int> hub; //中转站\npublic:\n    MyStack() {\n\n    }\n    \n    //\n    void push(int x) {\n        storage.push(x);\n    }\n    \n    //即弹出队尾元素\n    int pop() {\n        if(storage.empty()) return -1;\n        int len = storage.size();\n        for(int i = 0; i < len - 1; i++){\n            hub.push(storage.front());  \n            storage.pop();\n        }\n        int val = storage.back();    //把最后一个元素弹出并得到\n        storage.pop();\n        int len1 = hub.size();\n\n        for(int j = 0; j <len1; j++){\n            storage.push(hub.front());\n            hub.pop();\n        }\n\n        return val;\n\n    }\n    \n    //即返回队尾元素\n    int top() {\n        return storage.back();\n    }\n    \n    bool empty() {\n        return storage.empty();\n    }\n};\n```\n\n因为队列只能从队头移除元素，必然单个队列也就无法实现栈了，所以核心实现就在移除最后的元素。我们利用一个队列作为中转队列，即待移除最后一个元素的时候，先把 storage 中全部元素转移到中转队列中，然后取得中转队列的队头元素并移除（就是要获取的 storage 中的队头元素），然后在转移回 storage 队列中去即可。","tags":["队列"],"categories":["leetcode"]},{"title":"155.最小栈","url":"/2024/08/15/155-最小栈/","content":"\n```c++\nclass MinStack{  \n private:  \n  stack<pair<int,int>> minStack_;  \n  vector<int> data_;  \n private:  \n public:  \n  MinStack(){  \n  \n  }  \n  void push(int val){  \n    data_.push_back(val);  \n    sort(data_.begin(),data_.end(), [](int a,int b){    // 从小到大排序  \n      return a < b;  \n    });  \n    pair<int,int> result(val,data_.front());  \n    minStack_.push(result);  \n  }  \n  void pop(){  \n    int delData = minStack_.top().first;  \n    minStack_.pop();  \n    auto its = std::find(data_.begin(), data_.end(),delData); // 找到 待删除元素的迭代器  \n    if (its != data_.end()){  // 找到了 就删除它  \n      data_.erase(its);  \n    }  \n  }  \n  int top(){  \n    return minStack_.top().first;  \n  }  \n  int getMin(){  \n    return minStack_.top().second;  \n  }  \n};  \n```\n\n早先做这道题的时候，采用的是双栈，想法简单，却也要在两个栈中来回移动，极其愚蠢。后面看别人的题解的时候看到利用 pair<int,int> 的应用，甚是美妙，可我还是走错了（data_ 的使用是画蛇添足）。直到再次看到另一个人的题解，我才明白我的思想究竟错误在哪里，也回忆起之前感叹美妙的原由，即采用 pair<int,int> 只需一个栈；加入元素就与 top 元素 进行 min 求值，就能保证当前 元素记录着对应 栈的最小元素。\n\n```c++\nclass MinStack{\n private:\n  stack<pair<int,int>> minStack_;\n public:\n  MinStack(){\n\n  }\n  void push(int val){\n    pair<int,int> result;\n    if (minStack_.empty()){\n      result = pair<int,int>(val,min(val,val));\n    }else{\n      result = pair<int,int>(val,min(val,minStack_.top().second));\n    }\n    minStack_.push(result);\n  }\n  void pop(){\n    minStack_.pop();\n  }\n  int top(){\n    return minStack_.top().first;\n  }\n  int getMin(){\n    return minStack_.top().second;\n  }\n};\n```","tags":["栈"],"categories":["leetcode"]},{"title":"20.有效的括号","url":"/2024/08/15/20-有效的括号/","content":"\n```c++\nclass Solution {  \npublic:  \n    bool isValid(string s) {  \n        stack<char> data;  \n        int len = s.size();  \n  \n        for(int i = 0; i < len; i++){  \n            if(data.empty()){  \n                data.push(s[i]);  \n                continue;  \n            }  \n  \n            if((data.top() != s[i]) && ((data.top() == '(' && s[i] == ')') || (data.top() == '[' && s[i] == ']') || (data.top() == '{' && s[i] == '}'))){ // 有希望  \n                data.pop();  \n            }else{  \n                data.push(s[i]);  \n            }  \n        }  \n  \n        if(data.empty()) return true;  \n  \n        return false;  \n    }  \n};  \n```\n\n逐一从字符串 s 中取字符：\n\n1. 如果 data 栈为空，直接加入其中\n2. 如果 data 栈不为空，即将加入的字符 s[i] 与 栈中的顶部元素比较\n   1. 如果不相等【data.top() != s[i]】，表明**有希望**匹配\n   2. 如果相等，必然不可能匹配，将其加入栈中即可\n\n栈 适合解决对称性问题，这也是栈的一个特点","tags":["栈"],"categories":["leetcode"]},{"title":"第一章：函数式编程简介","url":"/2024/08/12/第一章：函数式编程简介/","content":"\n## 什么是函数式编程？\n\n我们常用的是命令式编程，它关心“怎么做”，而函数式编程关心“做什么”。通俗来讲，函数式编程更关注结果的定义，而命令式编程更关注实现的步骤。\n\n### 命令式编程\n\n在命令式编程中，我们会明确地告诉计算机每一个步骤应该怎么做。在如下这个代码中，我们使用了一个循环，逐个元素地累加到 `sum` 变量上。我们需要明确地描述每一步操作。\n\n```c++\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> numbers = {1, 2, 3, 4, 5};\n    int sum = 0;\n\n    for(int i = 0; i < numbers.size(); ++i) {\n        sum += numbers[i];\n    }\n\n    std::cout << \"Sum: \" << sum << std::endl;\n\n    return 0;\n}\n```\n\n### 函数式编程\n\n在声明式编程中，我们更关注的是“做什么”，而不是“怎么做”。使用函数式编程的风格，我们可以使用递归或者标准库的算法来实现这一点。在如下这个代码中，`std::accumulate` 函数定义了如何计算数列的和，而不需要手动地进行循环和累加。这里编程语言提供的库函数实现了所有细节，程序员只需要指定“想要什么”，而不需要关心“如何去做”。\n\n```c++\n#include <iostream>\n#include <vector>\n#include <numeric>\n\nint main() {\n    std::vector<int> numbers = {1, 2, 3, 4, 5};\n    int sum = std::accumulate(numbers.begin(), numbers.end(), 0);\n\n    std::cout << \"Sum: \" << sum << std::endl;\n\n    return 0;\n}\n```\n\n## 纯函数\n\n函数式编程的核心思想是纯函数，即函数只使用（而不修改）传递给它们的实际参数计算结果。如果使用相同的实参多次调用纯函数，将得到相同的结果，并不会留下调用痕迹（无副作用）。这都意味着纯函数不能修改程序的状态。\n\n但是这样的要求未必过于苛刻，意味着纯函数不能从标准输入读取内容，不能向标准输出写入内容，不能创建或删除文件，也不能像数据库插入记录等。如果要追求彻底的“不变性”，甚至要禁止纯函数改变处理器的寄存器、内存或其它硬件的状态。这样的纯函数的定义就没意义了。\n\nCPU 一条一条地执行指令，他需要跟踪下一条要执行的指令。如果连 CPU 的内部状态都不可修改，那么在计算机上将无法执行任何操作。另外，如果不能与用户或其它软件系统交互，程序就毫无作用。\n\n正是因为如此，我们降低一下纯函数的要求，重新定义如下：**任何没有可见副作用的函数称为纯函数**。纯函数的调用者除了接受它的返回结果外，看不到任何它执行的痕迹。本书不提倡只使用纯函数，而只是限制非纯函数的数量。\n\n---\n\n下面通过命令式实现的统计文件集合中每个文件的行数的例子额，引入函数式编程的风格。\n\n![命令式编程.png](/images/2024/08/12/1b6afab0-58b7-11ef-b8eb-03ab487c67e2.png)\n\n上面的这份代码 count_lines_in_files 就是常见的命令式编程方式，里面包含多个可变状态，相当“不纯”。\n\n1. get 方法每次都会更改字符的值\n2. 如果遇到换行，line_count 会自加更改值\n3. 退出 while 循环之后，results 容器会加入新的元素\n\n但要考虑的不仅仅是这些，另一个很重要的方面是这个函数的“不纯”性是不是外部可见的。**这个函数的所有可变变量都是局部的--计时函数的并发调用也不会共享--不会被调用者或其它实体看到。虽然它的实现不是纯函数，但它的使用者可以认为这是一个“纯函数”**。这对它的调用者是有利的，因为不需要修改它们的状态，而只需要管理自己的（状态）。这样做的话，**必须保证不能更改不属于自己的任何东西**。如果限制修改属于自己的状态，以纯函数的方式实现，那就再好不过了。如果能够保证以纯函数实现，那就没必要考虑是否漏掉了任何状态改变，因为没有修改任何东西。\n\n第二种解决方案把统计功能分离到另一个函数 count_lines 函数中，这个函数也是外表上看起来像个纯函数，虽然它的内部声明了一个输入流并且修改它。\n\n![命令式编程改进.png](/images/2024/08/12/1730d370-58b7-11ef-b8eb-03ab487c67e2.png)\n\n实际上这份代码并没有对之前的程序 count_lines_in_files 没有什么实质性的提高。它只是把“不纯”的部分转移到其它地方，但依旧保留了两个可变的变量。与此不同的是，count_lines_in_files 不需要 I/O，但还是用它（count_lines 函数）的思想实现的，所以作为调用者，可以认为它是纯函数，而不论是不是含有“不纯”的部分。\n\n下面的代码使用了范围操作符实现 count_lines_in_files 函数，没有局部状态--没有可变状态也没有不可变状态。它的实现只是对给定的输入调用了其它的函数：\n\n![函数式编程.png](/images/2024/08/12/120dd2d0-58b7-11ef-b8eb-03ab487c67e2.png)\n\n这个解决方案就是函数式编程很好的例子。它简明扼要，浅显易懂。更重要的是，其他的事情（除统计行数外）它一概没做--没有任何可见的副作用。它只是对给定的输入给出期望的结果。\n\n## 以函数方式思考问题\n\n先写出命令式编程的代码，再去转换为函数式编程的代码是低效的，应该在拿到任务之前思考输入是什么，输出是什么，输入到输出需要怎样的转换，而不是去思考算法的步骤（命令式编程）。\n\n给定一个文件名字的列表（集合），需要计算出每一个文件中的行数。首先想到的应该是简化这个问题，即一次只处理一个文件。虽然给定了一个文件名的集合，但可以一次一个地处理它们。如果能找出解决统计一个文件行数的办法，就可以很容易地解决这个问题。\n\n![函数方式思考.png](/images/2024/08/12/0bd23640-58b7-11ef-b8eb-03ab487c67e2.png)\n\n现在问题转化为，定义一个函数，接收一个文件名并计算该文件中行数的问题。从这个角度分析，很明显给定了一个东西（文件名），但需要的却是另一个东西（文件的内容，这样才可以统计出文件的行数）。因此，需要一个函数，它可以接收一个文件名，并给出它的内容。至于内容是字符串、文件流、或其他形式由用户决定。它只需要每次提供一个字符，用户把这个字符传递给统计行数的函数就可以了。\n\n当有了给出文件内容的函数（std::string → std::ifstream），就可以用它的结果调用统计行数的函数（std::ifstream -> int）。把第一个函数返回的 ifstream 类型的结果传递给第二个统计行数的函数，就可以得到想要的结果。\n\n![拆解.png](/images/2024/08/12/044b2df0-58b7-11ef-b8eb-03ab487c67e2.png)\n\n这样问题就解决了。现在需要提升这两个函数用于处理一个文件的集合，而不再是单一的一个文件了。从概念上讲，std::transform 就是这样实现的（还有很多复杂的 API）：它需要一个可以应用于单个值的函数，并创建一个可以处理整个值集合的转换，如下图所示。把处理单个值的函数提升为处理该类型复杂数据结构的函数，是一种通用技术。\n\n![提升.png](/images/2024/08/12/00575e80-58b7-11ef-b8eb-03ab487c67e2.png)\n\n通过这个例子，读者已经学会了利用函数式的方法，把一个大的问题分解成小的问题、独立的任务，并且方便地把它们组合起来。与函数组合和提升比较类似的例子是动态流水线，如下图所示。最初是制作产品的原料。这些原料通过机器的转换，最后得到最终产品。在流水线中，关心的是产品经过哪些转换，而不是机器加工产品的具体步骤。\n\n![流水线.png](/images/2024/08/12/faa3b6a0-58b6-11ef-b8eb-03ab487c67e2.png)\n\n在这个例子中，原料是输入，机器是施加于输入的函数。每个函数只做自己的工作而不关心其他的函数。每个函数只需要一个有效的输入，而不论这个输入来自何处。输入条目逐个放在流水线中（或有多个流水线，那就可以并行处理多个条目了）。每个条目经过转换，最终得到想要的东西。\n\n## 函数式编程的优点\n\n### 代码简洁易读\n\n有许多情况下，循环和分支也过于原始。就好像 GOTO 一样，循环和分支使程序难以编写和理解，可以使用层次更高的函数式编程结构替代。程序员在多处编写相同的代码，却没有发现它们是相同的，因为它们用于不同的类型或有不同的行为，但可以很容易地把它们重构出来。\n\n通过使用STL或第三方库提供的抽象，并通过创建自己的抽象，可以使代码更安全更简短。同时，更易于暴露这些抽象中的缺陷，因为这些相同的代码将被用于不同的场合。\n\n### 并发和同步\n\n开发并发系统的主要难点在于共享可变的状态。必须保证组件不能相互干扰。使用纯函数编写并行程序就很简单，因为这些函数并不修改任何东西。不需要原子或信号量进行显式同步，可以把用于单线程的代码，几乎不加修改地用于多线程系统。\n\n### 持续优化\n\n使用抽象层次更高的 STL 或其他可信的库函数还有另一个优点：即使不修改任何一行代码，程序也在不断地提高。编程语言、编译器实现或正在使用的库的实现的每一个改进都将改进程序。虽然函数式或非函数式的高层次抽象都会得到改进，但函数式编程概念显著增加了可以用这些抽象来覆盖的代码量。\n\n这看起来有点简单，但很多程序员倾向于手动编写低层次的关键性能代码，有时甚至用汇编语言。这种做法有一定的好处，但这种优化只针对特定的平台，而且阻碍了编译器对其他平台代码的优化。\n\n再来看一下 sum 函数。针对预取指令的系统进行优化，可以在内部循环中一次取两个（或更多）条目，而不是一次只取一个。这可以减少代码中的跳转次数，因此 CPU 一般会预取到正确的指令，而且在目标系统中可大幅提高性能。但如果在另一不同的平台上运行这个程序会怎样呢？对于某些平台来说，其原始的循环可能已经是优化了的；对于其他平台，有可能每次循环能对更多的条目进行累加。有些系统甚至可以提供CPU级的指来实现这个函数的功能。\n\n通过这种方式手动优化代码，针对的只有一个平台，而失去了其他所有平台的优化。如果使用高层次抽象，就可以依赖其他的人对代码进行优化。绝大多数STL实现都对目标平台和编译器进行了特定的优化。\n\n---\n\n⭐️内容取自译者程继洪、孙玉梅、娄山佑《函数式编程》，仅从中取出个人以为需要纪录的内容。不追求内容的完整性，却也不会丢失所记内容的逻辑性。如果需要了解细致，建议读原书。","tags":["函数式编程"],"categories":["technology"]},{"title":"不要用 TIME-WAIT暗杀来关闭一条连接","url":"/2024/08/10/不要用-TIME-WAIT暗杀来关闭一条连接/","content":"\n## 认识 TIME-WAIT\n\n主机 2 关闭连接并释放资源。从主机 2 的角度来看，连接不再存在了。但主机 1 还没有关闭连接，而是会进入 TIME_WAIT状态，并在这个状态停留 2MSL，等待 2MSL智慧，主机 1 也将连接关闭，并释放其资源。\n\n![time_wait.png](/images/2024/08/10/1f7d2ce0-571d-11ef-a7b6-1b323923df30.png)\n\n关于 TIME-WAIT 状态，还要弄清楚三点：\n\n1. 主动关闭的那一端才会进入 TIME-WAIT 状态\n2. RFC 将 MSL 定义为 2 分钟\n3. 如果连接处于 TIME-WAIT 状态时有分组到达，就重启 2MSL 的定时器\n\n## 为什么要使用它\n\n1. 维护连接状态，以防主动关闭连接的那端发送的最后一条 ACK 丢失后照成另一端重新发送 FIN 信号\n2. 为耗尽网络中所有此连接的“走失段”提供时间（确保在原有连接的所有分段从网络中消失之前，不会再次使用原来用过的套接字对，以此来防止这类问题的产生）\n\n## TIME-WAIT 暗杀\n\n不幸的时，TIME-WAIT 状态可以被提前终止，这被称为 TIME-WAIT 暗杀。它可能时“碰巧”产生的，也可能是故意造成的。不管是哪种情况，提前终止 TIME-WAIT 状态 都是不明智的。\n\n### 碰巧发生的情况\n\n首先来看看怎么会碰巧发生这种情况。当一条连接处于 TIME-WAIT 状态并收到一个 RST 时，应该立即将连接关闭。假设有一条处于 TIME-WAIT 状态的连接，并有一个原有的重复分段到达，而这个分段是 TCP 无法接受的（比如，序列号在当前接收窗口之外）。TCP 会以一个 ACK 响应，说明它所期待的序列号（就是对等实体的 FIN 之后的序列号）。但对等实体中已经没有这个连接的记录了，所以会以一个 RST 来进行 ACK。当这个 RST 回到连接处于 TIME-WAIT 状态的主机时，会使连接立即关闭--TIME-WAIT 状态被暗杀了。\n\n可能会影响到原有连接的再生，还包含了对原有数据的错误接收，造成无线 ACK 循环的连接不同步现象，以及新连接的错误行终止。\n\n### 故意造成的\n\n另一种 TIME-WAIT 暗杀方式是故意造成的。如下所述，即使应用程序正在主动关闭连接，程序员也可以用套接字选项 SO_LINGER 迫使连接立即关闭。有时会推荐用这种可疑的方式使服务器跳出 TIME-WAIT状态，这样就可以在崩溃或终止之后重启服务器了。\n\n---\n\n⭐️内容取自译者陈涓、赵振平《TCP/IP高效编程：改善网络程序的44个技巧》，仅从中取出个人以为需要纪录的内容。不追求内容的完整性，却也不会丢失所记内容的逻辑性。如果需要了解细致，建议读原书。","tags":["网络编程"],"categories":["technology"]},{"title":"使用前将结构sockaddr_in清零","url":"/2024/08/10/使用前将结构sockaddr-in清零/","content":"\n我们看到下面两种实现中确实都有另外一个字段 sin_zero。尽管很少用到这个字段（用于将sockaddr_in结构补足 16 字节长），但还是必须将其设置为 0。\n\n因为必须要将 sin_zero 清零，所以在使用之前，将整个地址结构清零就成了一种惯常的做法。通过这种方式，可以清除所有其它字段，而且还可以避免于未正式说明的字段及用法发送可能的冲突。\n\n![sockaddrin.png](/images/2024/08/10/58b102a0-5715-11ef-a7b6-1b323923df30.png)\n\n---\n\n⭐️内容取自译者陈涓、赵振平《TCP/IP高效编程：改善网络程序的44个技巧》，仅从中取出个人以为需要纪录的内容。不追求内容的完整性，却也不会丢失所记内容的逻辑性。如果需要了解细致，建议读原书。","tags":["网络编程"],"categories":["technology"]},{"title":"不要低估 TCP 的性能","url":"/2024/08/10/不要低估-TCP-的性能/","content":"\nTCP 是一个复杂的协议，在基本数据报服务的基础上添加了可靠性和流量控制功能，而 UDP 只添加了一个校验和,所以看起来 UDP 可能要比 TCP 快一个数量级或更多。基于这种假设很多应用程序的程序员都认为只有使用 UDP 才能获得可接受的性能。在某些情况下，UDP 运行的是比 TCP 快得多，但并不总是这样的。我们会看到，**有时 TCP 比 UDP 运行的好得多**。\n\n1. 两种协议的 CPU 处理主要都是在进行数据复制和校验，因此，这部分看不出太大的差别\n2. 为了提供可靠性，接收端 TCP 必须发送 ACK，这就增加了两端程序必须处理的内容，但是工作量可能不会有我们预想的那么多。首先，接受端可用通过它要发回给对等实体的数据来捎带给ACK。实际上，很多 TCP 实现都会将 ACK 延迟几个毫秒发送，以防止本端应用程序有对输入分段的应答要发送。第二，TCP 没必要为每个段产生一个 ACK。正常情况下，大部分 TCP 实现都是隔一段发送一次 ACK 的\n3. TCP 和 UDP 之间另一个主要区别在于 TCP 是个面向连接的协议，必须进行连接的建立和拆除，即三次握手和四次挥手。我们假设拆除连接（四次挥手）的时间基本上可用并入数据交换的时间之中，将注意力集中在连接建立阶段发生的事情上。如下图所示，分组从一台主机发送到其对等实体再发送回来所需的时间。正如我们看到的那样，连接建立要花费一又二分之一个往返时间。如果客户端和服务器之间的连接维持的时间足够长(比如,有大量数据在客户端和服务器之间传送)，这一个半 RTT会由所有的数据传输分摊，不会对性能产生很严重的影响。但如果有个简单事务，客户端发送一条请求，服务器对其进行应答，那么连接建立时间在整个事务所用时就会占据很大一部分\n\n![TCP性能.png](/images/2024/08/10/13151a80-5713-11ef-a7b6-1b323923df30.png)\n\n我们预计，应用程序中仅包含简单的请求/应答会话时，UDP 的性能会比 TCP 好，当连接持续的时间很长，并且传输了大量数据时，TCP 的性能会比 UDP 好得多。实际情况中，还需要各写一份代码进行测试。\n\n---\n\n⭐️内容取自译者陈涓、赵振平《TCP/IP高效编程：改善网络程序的44个技巧》，仅从中取出个人以为需要纪录的内容。不追求内容的完整性，却也不会丢失所记内容的逻辑性。如果需要了解细致，建议读原书。","tags":["网络编程"],"categories":["technology"]},{"title":"高并发、高可用和高性能","url":"/2024/08/10/高并发、高可用和高性能/","content":"\n## 概述\n\n（一）高并发\n\n用QPS/TPS来衡量系统对任务的处理能力：\n\n- **QPS**（Queries Per Second）：每秒**查询**数，指一台服务器每秒能够响应的查询次数\n- **TPS**（Transactions Per Second）：每秒事务（**增删改**）数，可以是一个接口、多个接口、一个业务流程\n\nQPS只是一个简单查询的统计，不能描述增删改等操作（TPS来描述）。如果只有查询操作，我们认为TPS = QPS\n\n（二）高可用\n\n**SLA**衡量一个系统可用性有多高，目标系统7 x 24不间断服务\n\n大云厂商在宣传自己产品SLA时是多少个9\n\n![高可用.png](/images/2024/08/10/69949cc0-56f8-11ef-a7b6-1b323923df30.png)\n\n9 越多代表全年服务可用时间越长服务更可靠，停机时间越短\n\n大厂多数业务 4个9是刚需，5个9是目标，6个9是理想\n\n（三）高性能\n\n**RT**来衡量系统的响应速度，程序处理速度非常快、延迟低、所占内存少、CPU占用率低\n\n比如系统处理一个HTTP请求需要100ms，这100ms就是系统的响应时间\n\n## 技术方案\n\n（一）高并发和高性能\n\n1. 负载均衡：常用的Nginx中间件就有实现\n2. 缓存：有本地缓存和分布式缓存\n3. 池化复用：线程池、连接池、内存池等\n4. 异步：异步日志等\n5. 预处理：你刷的视频即便后面有部分还没有看也会被提前获取\n6. 分而治之：Master-Worker工作架构，可参考主从Reactor模型\n\n（二）高可用\n\n1. 集群架构：有节点故障会有其它节点顶替\n2. 熔断降级：为了防止整个系统故障，抛弃一些非核心的接口和数据，返回兜底数据\n3. 限流：访问频率或者并发请求超过承受范围，考虑限流来保证接口的可用性\n4. 隔离：服务和资源相互隔离，比如网络资源、机器资源、线程资源等，不会因为某个服务的资源不足而抢占其它服务的资源\n5. 多活架构：同城双活-双机房和异地多活-两地三中心\n\n![高可用方案.png](/images/2024/08/10/62a5b5c0-56f8-11ef-a7b6-1b323923df30.png)","tags":["网络编程"],"categories":["technology"]},{"title":"水平触发和边缘触发","url":"/2024/08/10/水平触发和边缘触发/","content":"\n## 水平触发\n\n- 读事件：如果 epoll_wait 触发了读事件，表示有数据可读，如果程序没有把数据读完，再次调用 epoll_wait 的时候，将立即再次触发读事件。\n- 写事件：如果发生缓冲区没有满，表示可以写入数据，只要缓冲区没有被写满，再次调用epoll_wait的时候，将立即再次触发写事件。\n\n## 边缘触发\n\n- 读事件：如果 epoll_wait 触发了读事件，不管程序有没有处理读事件，epoll_wait 都不会再触发读事件，只有当新的数据到达时，才再次触发读事件。\n- 写事件：epoll_wait 触发写事件之后，如果发送缓冲区任可以写（发送缓冲区没有满），epoll_wait 不会再次触发写事件，只有当发送缓冲区由 满 变成 不满 时，才再次触发写事件。\n\n## 实例说明\n\n这里就以读事件举例，客户端发生长度为 6 的字符串sssbbb，服务器这边一次读只能读取长度为 3 的字符串。下面看看水平触发和边缘触发的现象：\n\n水平触发：epoll_wait触发读事件，读取字符串sss，epoll_wait再次触发读事件，读取字符串bbb\n\n边缘触发：epoll_wait触发读事件，读取字符串sss\n\n客户端再次发送长度为6的字符串sssbbb：\n\n水平触发：epoll_wait触发读事件，读取字符串sss，epoll_wait再次触发读事件，读取字符串bbb\n\n边缘触发：epoll_wait触发读事件，读取字符串bbb（把之前没读完的字符串读完）\n\n实践效果图如下：\n\n![水平触发.png](/images/2024/08/10/0ab7cab0-56f8-11ef-a7b6-1b323923df30.png)\n\n![边缘触发.png](/images/2024/08/10/10951aa0-56f8-11ef-a7b6-1b323923df30.png)","tags":["网络编程"],"categories":["technology"]},{"title":"网络编程中结构体的区分","url":"/2024/08/10/网络编程中结构体的区分/","content":"\n## sockaddr结构体和sockaddr_in结构体\n\n```c++\nstruct sockaddr {\n    unsigned short sa_family;    // 协议族 (AF_INET, AF_INET6, etc.)\n    char sa_data[14];            // 地址数据 (协议相关)\n};\n```\n\n存放协议族、端口和地址信息。客户端的 connect 函数和服务端的 bind 函数需要这个结构体。\n\nsockaddr 结构体是为了统一地址结构的表示方法，统一接口函数，但是这个结构体并不方便使用，因此定义了等价的 sockaddr_in 结构体，它的大小和 sockaddr 结构体相同，可以强制转换成 sockaddr。\n\n```c++\nstruct sockaddr_in {\n    short int sin_family;         // 协议族 (AF_INET)\n    unsigned short int sin_port;  // 16位端口号 ，大端序。用htons(整数的端口)转换。\n    struct in_addr sin_addr;      // IP地址\n    unsigned char sin_zero[8];    // 填充，使得结构体大小与sockaddr一致（不用管）\n};\n\nstruct in_addr {\n    unsigned long s_addr;         // 32位的IP地址，大端序 (使用网络字节序)\n};\n```\n\n因此，在实际的网络编程中，先定义 sockaddr_in结构体把相关信息存储之后，再强制转换成 sockaddr，毕竟提供的API接受的类型是 sockaddr。\n\n## gethostbyname函数\n\n```c++\n#include <netdb.h>\n\nstruct hostent *gethostbyname(const char *name);\n\nstruct hostent {\n    char  *h_name;       \t   // 主机的正式名称\n    char **h_aliases;   \t // 主机的别名列表\n    int    h_addrtype;   \t // 地址类型，通常为 AF_INET\n    int    h_length;     \t   // 地址长度，通常为 4（对于 IPv4）\n    char **h_addr_list;  \t//地址列表，可能包含多个 IP 地址（网络字节序）\n};\n\n#define h_addr h_addr_list[0] // For backward compatibility.\n```\n\n这个函数的优点就是不仅可以直接传递IP地址（字符串类型或字符数组类型），还支持传递域名。根据返回的hostent结构体中的成员，添加到所需的其它结构体中。\n\n如下是部分应用核心代码：\n\n```c++\n    // 定义主机名\n    const char* hostname = \"www.example.com\";\n    \n    // 获取主机信息\n    struct hostent* host_info = gethostbyname(hostname);\n\n    // 设置服务器地址结构\n    struct sockaddr_in server_addr;\n    std::memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(80); // HTTP 端口号\n    std::memcpy(&server_addr.sin_addr, host_info->h_addr_list[0], host_info->h_length);\n```\n\n## 字符串IP与大端序IP地址的转换\n\nC语言提供几个库函数，用于字符串格式的IP和大端序IP的相互转换，用于网络通讯的服务端程序中。\n\n`inet_addr`：将字符串形式的 IP 地址转换为 `in_addr_t`\n\n```c++\nin_addr_t inet_addr(const char *cp);\n\n/*\n    const char *ip = \"127.0.0.1\";\n    in_addr_t addr = inet_addr(ip);\n*/\n```\n\n`inet_aton`：将字符串形式的 IP 地址转换为 `in_addr` 结构体\n\n```c++\nint inet_aton(const char *cp, struct in_addr *inp);\n\ncp: 指向一个以点分十进制表示的IPv4地址的字符串\ninp: 指向一个 in_addr 结构体，用于存储转换后的IP地址\n    \n/*\n    const char *ip = \"127.0.0.1\";\n    struct in_addr addr;\n\n    if (inet_aton(ip, &addr) == 0) {\n        std::cerr << \"Invalid IP address\" << std::endl;\n    } else {\n        std::cout << \"inet_aton: \" << addr.s_addr << std::endl;\n    }\n*/\n```\n\n`inet_ntoa`：将 `in_addr` 结构体中的 IP 地址转换为字符串形式\n\n```c++\nchar *inet_ntoa(struct in_addr in);\n\n/*\n    struct in_addr addr;\n    addr.s_addr = inet_addr(\"127.0.0.1\");\n\n    char *ip = inet_ntoa(addr);\n    if (ip == nullptr) {\n        std::cerr << \"Error converting address\" << std::endl;\n    } else {\n        std::cout << \"inet_ntoa: \" << ip << std::endl;\n    }\n*/\n```\n\n注：typedef unsigned int in_addr_t\t代表32位大端序的IP地址。\n\n\n\n","tags":["网络编程"],"categories":["technology"]},{"title":"主机字节序和网络字节序","url":"/2024/08/10/主机字节序和网络字节序/","content":"\n## 主机字节序\n\n主机字节序是指在特定计算机系统中数据的存储顺序。常见的字节序有两种：\n\n- **大端字节序（Big-endian）：** 数据的高字节存储在低地址端。例如，数值 0x12345678 将按顺序存储为 0x12 0x34 0x56 0x78\n- **小端字节序（Little-endian）：** 数据的低字节存储在低地址端。例如，数值 0x12345678 将按顺序存储为 0x78 0x56 0x34 0x12\n\n## 网络字节序\n\n网络字节序是一种标准化的数据表示方式，用于在不同计算机系统之间传输数据。为了确保数据在网络传输中保持一致，**网络协议（如 TCP/IP）规定采用大端字节序**。\n\n## 主机字节序和网络字节序的转换\n\n`htons`（Host to Network Short）：将 16 位主机字节序转换为网络字节序\n\n`htonl`（Host to Network Long）：将 32 位主机字节序转换为网络字节序\n\n`ntohs`（Network to Host Short）：将 16 位网络字节序转换为主机字节序\n\n`ntohl`（Network to Host Long）：将 32 位网络字节序转换为主机字节序\n\n在网络编程中，数据收发的过程中有自动转换机制，不需要程序员手动转换，**只有向 sockadd_in 结构体成员变量填充数据时，才需要考虑字节序的问题**。\n\n```c++\nstruct sockaddr_in server_addr;\nmemset(&server_addr, 0, sizeof(server_addr));\nserver_addr.sin_family = AF_INET;\nserver_addr.sin_port = htons(port);\t\t// 端口号转换为网络字节序\nserver_addr.sin_addr.s_addr = inet_addr(ip.c_str());  \n```\n\nsockaddr_in 结构体成员 sin_port 接受 16位的大端序，因此用 htons 处理端口 port\n\ninet_addr 函数已经返回了网络字节序（big-endian）的地址，也就用不着 htonl 处理网络地址 ip","tags":["网络编程"],"categories":["technology"]},{"title":"服务器应该设置SO_REUSEADDR选项","url":"/2024/08/10/服务器应该设置SO-REUSEADDR选项/","content":"\n你可能看到过这个错误提示：Address already in use（地址已经被使用了）。往往要几分钟后才能重启，那我们如何立即重启服务器呢？在此之前，先理解如下两件事情：\n\n1. TCP 的 TIME-WAIT状态\n2. TCP 连接的四元组（本地地址、本地端口、远端地址、远端端口）\n\nTCP 连接中进行主动关闭（发送第一个FIN）的那一端会进入 TIME-WAIT 状态，并在此状态停留 2MSL，在此期间，该套接字的地址和端口仍然被占用，无法立即重新绑定到同样的地址和端口。这为我们在看到的行为提供了第一条线索：客户端主动关闭时，可以重启连接的任意一端，不会有什么问题，但当服务器主动关闭时，就无法重启，这是由于前一个连接仍然处于 TIME-WAIT 状态。\n\n如果服务器重启，并且有客户端连接上来，就会有一条新的连接，这条连接可能都不是连接到同一台远端主机上的。如前所述，一条 TCP 连接可以由本地和远程地址以及端口号完全指定，所以，即使来自同一台远程主机的客户端连接到服务器上，只要它使用的端口号和前一个连接不同，就不会有什么问题。这是因为 `TIME_WAIT` 状态仅影响特定的四元组（`<源IP, 源端口, 目标IP, 目标端口>`），而不是整个服务器或客户端。\n\n基于这些事实，重启服务器时 TCP 返回的错误就会让我们感到很疑惑。实际上问题并不在于 TCP，而是出在套接字API 上，TCP 只要求四元组是唯一的，而套接字 API 则需要两个调用才能完整地指定四元组。当 API 调用 bind 时，并不知道接下来是否会调用 connect，如果调用还需要在指定一个唯一的连接，还是尝试重用已经存在的那个连接之间作出选择。\n\n幸运的是，这个问题有一种很简单的解决方案。可以先设置套接字选项 SO_REUSEADDR，允许一个套接字在 TIME_WAIT 状态下立即重新绑定到相同的地址和端口。\n\n如果不设置 `SO_REUSEADDR`，当你尝试重新启动一个服务器程序（特别是在调试时），由于旧连接仍在 TIME_WAIT 状态，尝试绑定到相同的端口会导致 \"Address already in use\" 错误。这时服务器无法重新绑定到原有端口，可能会导致服务不可用。\n\n在某些情况下，多个进程可能希望绑定到相同的地址和端口进行监听。这种情况通常出现在使用 UDP 协议或多个服务进程间共享一个监听端口时。在这种情况下，`SO_REUSEADDR` 允许多个套接字绑定到相同的地址和端口（只要每个套接字的协议不同，或者每个套接字是加入了不同的多播组的 UDP 套接字）。\n\n---\n\n⭐️内容取自译者陈涓、赵振平《TCP/IP高效编程：改善网络程序的44个技巧》，仅从中取出个人以为需要纪录的内容。不追求内容的完整性，却也不会丢失所记内容的逻辑性。如果需要了解细致，建议读原书。","tags":["网络编程"],"categories":["technology"]},{"title":"理解TCP的有序释放操作","url":"/2024/08/10/理解TCP的有序释放操作/","content":"\n## shutdown调用\n\nclose 函数会关闭读写，但如果你想控制关闭读端、关闭写端或者全部关闭，那么 shutdown 可以做到。\n\n```c++\nint shutdown(int sockfd, int how);\n\n/*\nsockfd: 套接字描述符，表示要操作的连接\n\nhow: 指定如何关闭连接，可以取以下三个值：\n\tSHUT_RD (0): 关闭读取功能。该套接字不再接收数据，任何到达的数据包将被丢弃。如果有未处理的接收数据，会继续保留，直到被读取完毕\n\tSHUT_WR (1): 关闭写入功能。该套接字不再允许发送数据。此时，TCP 会发送一个 FIN 包，告诉对端本地已完成数据发送，但仍可以接收数据\n\tSHUT_RDWR (2): 关闭读写功能。相当于同时执行 SHUT_RD 和 SHUT_WR，既不能发送数据，也不能接收数据\n*/\n```\n\n关闭套接字和调用 shutdown 之间有很大的区别。首先，即使将 how 设置为 2 来调用 shutdown，实际上也并没有“关闭”套接字。也就是说，并没有释放套接字及其资源（how 被设置为 0 或 2 时可能会将接收缓冲区释放掉）。\n\n同时还要注意，调用 shutdow 时，会影响到所有打开了那个套接字的进程。比如，将 how 设置为 1 调用 shutdow 会使套接字的所有持有者都无法对其进行写操作。相反，如果调用 close 或 closesocket，套接字的其他持有者仍然能够像什么事情都没有发生一样使用它。\n\n最后这一点通常可以为我们提供一些便利。用 how = 1 来调用shutdow 时，不管其他进程是否打开了这个套接字，都可以保证对等实体会收到一个EOF。调用 close 或 closesocket 就无法确保这一点，因为在套接字的引用计数减少到 0 之前，它都不会将 FIN 发送给对等实体。也就是说，所有进程关闭套接字后，它才将 FIN 发送给对等实体。\n\n## 有序释放\n\n有序释放的目的是确保两端都能在连接拆除之前收到所有来自其对等实体的数据。\n\n在需要通知对端自己已经完成发送但仍希望接收对端的数据时，可以使用 `shutdown(sockfd, SHUT_WR)`，这种方式可以实现连接的有序释放，而不是突然中断连接。因为立即关闭连接是非常粗暴的，对于想要关闭连接的一方，可以选择仅关闭当前套接字的写入功能，读取功能依旧还在，这是为了防止对等实体发送的数据丢失。\n\n对等实体收到 EOF，会关闭连接。在知道我这边已经关闭写入功能，就明白我后续不会发送任何数据了，这是要断开连接的意思，而我这边读取功能还没有关闭，所以对等实体会把所有消息和一个FIN一起发给我。我这边把对等实体发送过来的数据处理之后，收到 EOF，就知道我已经收到对等实体所有的数据，也就关闭连接了。\n\n---\n\n⭐️内容取自译者陈涓、赵振平《TCP/IP高效编程：改善网络程序的44个技巧》，仅从中取出个人以为需要纪录的内容。不追求内容的完整性，却也不会丢失所记内容的逻辑性。如果需要了解细致，建议读原书。","tags":["网络编程"],"categories":["technology"]},{"title":"理解TCP的写操作","url":"/2024/08/10/理解TCP的写操作/","content":"\n## 从应用程序角度看写操作\n\n用户程序对一条 TCP 连接进行写调用时，首先会将数据从用户缓冲区复制到内核中去。从此之后，可能发生的情况就与连接的状态有关了。TCP 可能发送全部、部分或者不发送数据。稍后会对 TCP 的这个决定做进一步的研究，但首先要从用户应用程序的角度来看看这个写操作的动作。\n\n![write.png](/images/2024/08/10/ae7fcf20-56d1-11ef-9064-ddcfd7bb5524.png)\n\n假设一个 n 字节的写操作返回值 n 时，这 n 字节已经被发送给对等实体，甚至已经被确认了，这是很有诱惑力的一种想法。但事情并不是这样的。TCP 会尽可能地将它所能发送的数据都发送出去（有可能一个也没有），然后立即返回值 n。应用程序无法判定发送了多少数据，也无法判断对等实体是否对其进行了确认。\n\n总的来说，除非 TCP 发送缓冲区满了，否则写操作是不会被阻塞的。也就是说，写操作基本上总是能立即返回的，但它们返回时并不能保证对所写数据进行了哪些处理。\n\n从应用程序的角度来看，数据已经写入，因此 TCP 的“可靠传输”要保证它抵达对等实体。实际上，写操作返回时，写操作写出的部分或全部数据可能还在排队等待传输，所以，此时不管是主机还是对等应用程序崩溃了，数据都会丢失。\n\n通过对这些情况进行总结，我们认为，对 TCP 连接使用写操作时，最好将写操作理解成将数据复制到发生队列，并通知 TCP 此队列中有新数据的一种操作。可以将 TCP 的行为作为收到这种通知后的结果，但要把它看作本质上异步于写操作的一种行为。\n\n## 从TCP角度看写操作\n\n如前所述，写操作负责将数据从应用程序的写缓冲区搬移到内核中去，并通知 TCP 有来自应用程序的新数据需要处理。现在来看看 TCP 使用的一些标准，这些标准决定了 TCP 能否将刚到达的数据立即发送出去，如果可以，发送多少。\n\n满足下列一项就会发送：\n\n![满足一项就发送.png](/images/2024/08/10/a8fd2250-56d1-11ef-9064-ddcfd7bb5524.png)","tags":["网络编程"],"categories":["technology"]},{"title":"要认识到TCP是一个可靠的，但并不绝对可靠的协议","url":"/2024/08/10/要认识到TCP是一个可靠的，但并不绝对可靠的协议/","content":"\n我们会误以为只要基于 TCP 编程，那么通信的数据必然能够到达对端主机，毕竟 TCP 是可靠的传输协议。然而， TCP 是处在传输层的协议，其可靠性只针对传输层，但是消息最终要达到应用层才算有价值。从传输层到应用层的消息会不会出现问题，可不由 TCP 来保证。\n\n数据流从应用程序 A 通过它所在主机的 TCP/IP 栈向下传输，经过几台中间路由器，通过应用程序 B 所在主机的TCP/IP 栈向上传输，最后抵达应用程序 B。一个 TCP 段离开应用程序 A 所在主机的 TCP 层时，会被封装到一个数据报中，传送给其对等实体主机。它所走的路由可能要经过很多路由器，但如下图所示，这些路由器都没有TCP层，它们只是转发了IP数据报。\n\n![TCP可靠之处.png](/images/2024/08/10/ba1a28b0-56c4-11ef-a3e6-51327ae276c7.png)\n\n当一个段抵达应用程序 B 所在主机的 TCP 层时，唯一可以确定的就是这个段已经到达了，但它可能损坏了，可能是重复的数据，可能是错序的，或者是由于其他一些原因无法接受的。注意，发送端 TCP 无法对这些抵达接收端 TCP的段做出任何保证。但接收端 TCP 要向发送端 TCP 确认，也就是说它 ACK 的数据以及在此数据之前到达的所有数据在 TCP 层都已经正确收到了，发送端 TCP 可以安全地删除这些数据的副本了。这并不意味着已经将数据传送，或者总是可以将数据传送给应用程序。比如，接收端主机可能在刚刚对数据进行了 ACK，但应用程序还没有将其读走之前，就崩溃了。\n\n## 故障模式\n\nTCP 是一个端对端协议，也就是说它自己要在对等实体之间提供可靠的传输机制。但是，认识到“端点”位于对等的 TCP层，而不是对等的应用程序中是非常重要的。要求进行端到端确认的应用程序必须自身提供此项功能。\n\n看看其他一些“常见的”故障模式。只要两个对等实体仍然连着，TCP 就能保证将数据按序无损坏地传送。只有连接中断时才会出现故障。什么类型的事件会造成这种中断呢?有三种情况可能引发这类问题：\n\n1. 永久或临时的网络中断\n2. 对等的应用程序崩溃\n3. 运行对等应用程序的主机崩溃\n\n## 网络中断\n\n路由器或骨干链路损毁，某人被本地以太网电缆绊倒，踢松了网线……很多原因都会造成网络的中断。在端点之外发生的损坏通常都是临时的，因为路由协议会发现问题，并使路由绕开出问题的节点。\n\n端点出现问题，通常没有备用的路径，所以问题会一直存在，直到端点修复为止。\n\n除非中间路由器发送一条ICMP报文，说明目的网络或主机不可达，否则应用程序及其 TCP/IP 栈都无法立即获知中断的发生。在这种情况下，发送端最终会超时，并重新发送所有未被确认的段。在发送端 TCP 放弃发送、丢弃连接并报告错误之前会一直持续这种操作。\n\n在传统 BSD 栈中，发送端 TCP 会在重传 12 次(大约 9 分钟)之后放弃。如果读操作被挂起，会返回一条错误状况，并将 errno 置为 ETIMEDOUT。如果没有挂起的读操作，接下来的写操作就会失败，根据信号是忽略还是捕获，写操作失败时会携带一个 SIGPIPE 信号，或 EPIPE 错误。\n\n如果某个中间路由器无法转发包含段的 IP 数据报，它会向源端主机发送一个 ICMP 报文，说明目的网络或主机不可达。在这种情况下，有些实现会返回 ENETUNREACH 或 EHOSTUNREACH 作为错误原因。\n\n## 对等实体崩溃\n\n接下来，我们来看看如果对等应用程序崩溃或者终止，会发生什么情况。首先要意识到从应用程序的角度来看，对等实体崩溃与对等实体调用 c1ose 及 exit 是无法区分的。**在这两种情况下，对等实体的 TCP 都会向我们的 TCP 发送一个 FIN**。FIN 作为 EOF 使用，表示发送它的那一端已经没有数据发送了。这并不（一定）表示发送 FIN 的这一端已经退出了，甚至无法说明它不愿意接收更多数据。\n\n## 对等实体的主机崩溃\n\n要研究的最后一种故障模式是对等实体主机的崩溃。这种故障模式与对等实体崩溃不同，因为对等实体的 TCP 无法通过 FIN 来通知我们的应用程序，其对等实体已经不在运行了。\n\n在对等实体主机重启之前，这个错误看起来和网络故障一样：对等实体的TCP不再应答了。和网络故障的情况一样，我们的应用程序 TCP 会持续重传未经确认的段。最终，如果对等实体主机没有重启，它就会放弃并向应用程序返回一条 ETIMEDOUT 错误。\n\n如果在我们的 TCP 放弃并丢弃连接之前，对等实体主机就重启了，会发生什么情况呢？在这种情况下，会有重传的段到达对等实体刚刚重启的主机，而这台主机并没有连接记录。在这种情况下，TCP 技术规范要求接收端主机向发送端主机回送一个 RST。这样发送端主机才会丢弃连接，应用程序才会收到一条 ECONNRESET 错误(如果它有挂起的读操作的话)，或者会在下一条写操作时得到一个 SIGPIPE 信号或 EPIPE 错误。\n\n---\n\n⭐️内容取自译者陈涓、赵振平《TCP/IP高效编程：改善网络程序的44个技巧》，仅从中取出个人以为需要纪录的内容。不追求内容的完整性，却也不会丢失所记内容的逻辑性。如果需要了解细致，建议读原书。","tags":["网络编程"],"categories":["technology"]},{"title":"记住：TCP是一种流协议","url":"/2024/08/10/记住：TCP是一种流协议/","content":"\nTCP 是一种流协议，这就意味着数据是以字节流的形式传递给接收者的，**没有固有的”报文”或”报文边界”的概念**。从这方面来说，读取 TCP 数据就像从串行端口读取数据一样——无法预先得知在一次指定的读调用中会返回多少字节。\n\n## 流协议存在的问题\n\n发送的数据没有边界，接收方可能对接收到的数据存在多读或少读的问题。为了说明这一点，我们假设在主机 A 和主机 B 的应用程序之间有一条 TCP 连接，主机 A 上的应用程序向主机 B 发送一条报文。进一步假设主机 A 有两条报文要发送，并两次调用 send 来发送，每条报文调用一次。很自然就会想到从主机 A 向主机 B 发送的两条报文是作为两个独立实体，在各自的分组中发送的。\n\n![主机A和主机B通信.png](/images/2024/08/10/b584bcb0-56b1-11ef-9b76-6d6092cc6dd4.png)\n\n但不幸的是，实际的数据传输过程很可能不会遵循这个模型。\n\n主机A上的应用程序会调用send，我们假设这条写操作的数据被封装在一个分组中传送给B。**实际上，send通常只是将数据复制到主机A的TCP/IP栈中，就返回了。由TCP来决定（如果有的话）需要立即发送多少数据**。做这种决定的过程很复杂，取决于很多因素，比如发送窗口（当时主机B能够接收的数据量），拥塞窗口（对网络拥塞的估计），路径上的最大传输单元（沿着主机A和B之间的网络路径一次可以传输的最大数据量），以及连接的输出队列中有多少数据。\n\n下图只显示了主机A的TCP封装数据时可能使用的诸多方法中的4种\n\n![数据分割.png](/images/2024/08/10/44a4f210-56b3-11ef-9b76-6d6092cc6dd4.png)\n![注解M1和M2.png](/images/2024/08/10/487b0050-56b3-11ef-9b76-6d6092cc6dd4.png)\n\n现在，我们从主机 B 应用程序的角度来看这种情形。总的来说，主机 B 应用程序任意一次调用 recv 时，都不会对 TCP 发送给它的数据量做任何假设。比如，当主机 B 应用程序读取第一条报文时，可能会出现下列 4 种结果：\n\n1. 没有数据可读，应用程序阻塞，或者 recv 返回一条指示说明没有数据可读。到底会发生什么情况取决于套接字是否标识为阻塞，以及主机B的操作系统为系统调用 recv 指定了什么样的语义\n2. 应用程序获取了报文 M1 中的部分而不是全部数据。比如，发送端TCP像上图 D 那样对数据进行分组就会发生这种情况\n3. 用程序获取了报文 M1 中所有的数据，除此之外没有任何其他内容。如果像上图 A 那样对数据分组就会发生这种情况\n4. 应用程序获取了报文M1的所有数据，以及报文M2的部分或全部数据。如果像上图 B 或上图 C 那样对数据进行分组就会发生这种情况\n\n注：实际可能的结果不止4种，但我们忽略了出错和EOF之类的结果。我们还假设应用程序读取了所有可读的数据。\n\nTCP 是一个流协议（stream protocol），**尽管数据是以 IP 分组的形式传输的，但分组中的数据量与 send 调用中传送给 TCP 多少数据并没有直接关系**。而且，接收程序也没有什么可靠的方法可以判断数据是如何分组的，因为在两次 recv 调用之间可能会有多个分组到来。\n\n**TCP会记录它发送了多少字节，以及确认的字节，但它不会记录这些字节是如何分组的**。实际上，有些实现在重传丢失分组的时候传送的数据可能比原来的多一些或少一些。\n\n## 解决方法\n\n- 固定报文长度\n- 记录结束标记来分割记录，要注意在数据中如果出现结束标记，需要转义以表明此为数据而非结束标记\n- 每条报文前面加一个首部，首部至少记录有实际数据的长度\n\n![自实现协议.png](/images/2024/08/10/baf4a4d0-56b1-11ef-9b76-6d6092cc6dd4.png)\n\n---\n\n⭐️内容取自译者陈涓、赵振平《TCP/IP高效编程：改善网络程序的44个技巧》，仅从中取出个人以为需要纪录的内容。不追求内容的完整性，却也不会丢失所记内容的逻辑性。如果需要了解细致，建议读原书。","tags":["网络编程"],"categories":["technology"]},{"title":"基本套接字 API 的回顾","url":"/2024/08/10/基本套接字-API-的回顾/","content":"\n![客户端和服务端的通信.png](/images/2024/08/10/06fe8b80-56b1-11ef-9b76-6d6092cc6dd4.png)\n\n基本套接字 API 概览\n\n`socket()`: 创建一个套接字\n\n`bind()`: 绑定套接字到一个地址和端口\n\n`listen()`: 监听端口上的连接请求（用于服务器）\n\n`accept()`: 接受连接请求（用于服务器）\n\n`connect()`: 连接到一个远程地址（用于客户端）\n\n`send()`: 发送数据\n\n`recv()`: 接收数据\n\n`close()`: 关闭套接字\n\n注：在 UNIX 中，可以像文件描述符那样，直接用套接字描述符来调用 read 和 write。但正如我们曾经提到的那样，Windows 并没有用套接字语法重载这些系统调用，因此，只能用 recv 和 send 来代替。除了包含一个额外参数，这些调用与 read 和 write 是一样的。如果你用的UDP的话，那么你应该使用 recvform 和 sendto。\n\n## socket\n\n功能：返回一个文件描述符，它是一个用于标识新创建的套接字的引用\n\n```c++\n#include <sys/types.h>         \n#include <sys/socket.h>\n\nint socket(int domain, int type, int protocol);\n\n/*\n  int socket_fd = socket(AF_INET, SOCK_STREAM, 0);\n  if (socket_fd < 0) {\n    perror(\"socket error\");\n    return -1;\n  }\n  */\n```\n\n`domain`（指定通信的协议族） 核心参数:：\n\n- AF_LOCAL: 本地进程间通信\n- AF_INET（常用）: 远端基于IPV4进程间通信\n- AF_INET6: 远端基于IPV6进程间通信\n\n`type`（指定套接字的类型） 核心参数：\n\n- SOCK_STREA（常用）: 流套接字，提供面向连接的稳定数据传输（TCP）\n- SOCK_DGRAM: 数据报套接字，提供无连接的数据传输（UDP）\n- SOCK_RAW: 原始套接字，提供对底层协议的直接访问\n\n`protocol`（指定要使用的协议） 核心参数：通常为 0，表示自动选择合适的协议。对于 AF_INET 和 SOCK_STREAM ，0 通常表示 TCP，对于 AF_INET 和 SOCK_DGRA，0 通常表示 UDP\n\n## bind\n\n功能：绑定套接字到一个地址和端口\n\n```c++\n#include <sys/types.h>         \n#include <sys/socket.h>\n\nint bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);\n\n/*\n  struct sockaddr_in server_addr;\n  memset(&server_addr, 0, sizeof(server_addr));\n  server_addr.sin_family = AF_INET;\n  server_addr.sin_port = htons(port);\n  server_addr.sin_addr.s_addr = inet_addr(ip.c_str());\n  \n  int ret = bind(socket_fd, (struct sockaddr *)&server_addr, sizeof(server_addr));\n  if (ret < 0) {\n    perror(\"bind error\");\n    return -1;\n  }\n*/\n```\n\nsockfd: 就是前面 socket 创建成功的返回值\n\naddr: 结构体 sockaddr，用于**存放服务端的协议族、端口和地址信息**。客户端的 connect 函数和服务端的 bind 函数需要这个结构体\n\naddrlen: 是参数 addr 的长度，用 sizeof 计算 \n\n---\n\n```c++\nstruct sockaddr {\n    unsigned short sa_family;    // 协议族 (AF_INET, AF_INET6, etc.)\n    char sa_data[14];            // 地址数据 (协议相关)\n};\n```\n\n存放协议族、端口和地址信息。客户端的 connect 函数和服务端的 bind 函数需要这个结构体。\n\nsockaddr 结构体是为了统一地址结构的表示方法，统一接口函数，但是这个结构体并不方便使用，因此定义了等价的 sockaddr_in 结构体，它的大小和 sockaddr 结构体相同，可以强制转换成 sockaddr。\n\n```c++\nstruct sockaddr_in {\n    short int sin_family;         // 协议族 (AF_INET)\n    unsigned short int sin_port;  // 16位端口号 ，大端序。用htons(整数的端口)转换。\n    struct in_addr sin_addr;      // IP地址\n    unsigned char sin_zero[8];    // 填充，使得结构体大小与sockaddr一致（不用管）\n};\n \nstruct in_addr {\n    unsigned long s_addr;         // 32位的IP地址，大端序 (使用网络字节序)\n};\n```\n\n因此，在实际的网络编程中，先定义 sockaddr_in结构体把相关信息存储之后，再强制转换成 sockaddr，毕竟提供的API接受的类型是 sockaddr。\n\n## listen\n\n功能：将一个套接字设置为被动模式，以便接收来自远程主机的连接请求\n\n```c++\n#include <sys/types.h>          \n#include <sys/socket.h>\n\nint listen(int sockfd, int backlog);\n\n/*\n  #define LISTEN_NUM 10\n  \n  ret = listen(socket_fd, LISTEN_NUM);\n  if (ret < 0) {\n    perror(\"listen error\");\n    return -1;\n  }\n*/\n```\n\n`sockfd`: 就是前面 socket 创建成功的返回值，而且必须 bind 之后的 sockfd\n\n`backlog`: 会影响到半连接队列和全连接队列的大小\n\n![全连接半连接队列.png](/images/2024/08/10/ff2c2250-56b0-11ef-9b76-6d6092cc6dd4.png)\n\n从上面这种图可以看到，listen 接受到客户端连接请求之后，开始进行三次握手。如果第一次握手成功，连接被加入到半连接队列；如果第三次握手也成功，连接被加入到全连接队列。三次握手成功，加入到全连接队列的连接可以用于后续通信，而 accept 实际上就是去全连接队列里面去取这些连接出来用于通信的。\n\n那么多大的 backlog 是合适的？\n\n- 如果你的接口处理连接的速度要求非常高，或者做压力测试，很有必要调高这个值\n- 如果业务接口本身性能不好，accept 取走已连接的速度较慢，那么把 backlog 调的再大也没有用，只会增加连接失败的可能性\n\n关于 backlog 传递的值究竟会为多少（你传递的值未必就会成为实际的 backlog 最终值），需要去看内核的实现，详细可见此文：[三次握手背后的秘密：半连接队列和全连接队列](https://www.yuque.com/xiaoyang-wyxle/gdb3m3/xntqpx4a75l074qg)\n\n## accept\n\n功能： 系统调用 sockfd 的全连接队列中的第一个连接请求，创建一个新的连接套接字，并返回一个新的文件描述符\n\n```c++\n#include <sys/types.h>  \n#include <sys/socket.h>\n\nint accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);\nint accept4(int sockfd, struct sockaddr *addr, socklen_t *addrlen, int flags);\n\n/*\n  struct sockaddr_in client_addr;\n  socklen_t client_len = sizeof(client_addr);\n  int listen_fd = accept(socket_fd, (struct sockaddr *)&client_addr, &client_len);\n  if (listen_fd < 0) {\n    perror(\"accept error\");\n    return -1;\n  }\n*/\n```\n\n`sockfd`: 就是前面 socket 创建成功的返回值，而且必须 listen 之后的 sockfd\n\n`addr`: 指向 `sockaddr` 结构体的指针，用于**存储客户端的地址信息**（新连接的对等实体地址）。如果不需要客户端地址，可以传递 `NULL`。\n\n`flags` (accept4 专用): 额外的标志，可以是以下值的按位或组合：\n\n- SOCK_NONBLOCK: 使返回的文件描述符变为非阻塞模式\n- SOCK_CLOEXEC: 在执行 exec 系列函数时自动关闭文件描述符\n\n也就是，我们后续服务器和客户端实际通信的套接字是 accept 函数返回的文件描述符。此前的 socket 创建并返回的文件描述符仅仅用于添加相关信息并和客户端成功建立连接，并不用于后续通信，却是后续通信不可或缺的基础。\n\n注：这里的 addr 参数是新建的客户端的结构体，而非之前创建用于 bind 参数的 addr 参数（它属于服务端）。\n\n## recv\n\n功能：用于从套接字接收消息\n\n```c++\n#include <sys/types.h>\n#include <sys/socket.h>\n\nssize_t recv(int sockfd, void *buf, size_t len, int flags);\n\n/*\n  char buf[1024] = {0};\n  ssize_t bytes_read = recv(listen_fd, buf, sizeof(buf) - 1,0);\n  if (bytes_read < 0) {\n    perror(\"read error\");\n  } else if (bytes_read == 0) {\n    std::cout << \"Client disconnected.\" << std::endl;\n  } else {\n    buf[bytes_read] = '\\0'; \n    std::cout << \"Received data: \" << buf << std::endl;\n  }\n*/\n```\n\n`sockfd`: 一个有效的套接字文件描述符，从中接收数据。就是之前调用 accept 之后返回的套接字文件描述符\n\n`buf`: 一个指向接收数据的缓冲区的指针\n\n`len`: 缓冲区的长度，即最多接收的字节数\n\n`flags`: 控制接收操作的标志。常用的标志包括：\n\n- 0: 默认标志，无特殊行为。\n- MSG_DONTWAIT: 使操作非阻塞\n- MSG_PEEK: 查看数据但不将其从缓冲区中移除\n- MSG_WAITALL: 等待所有请求的数据被接收\n\n## send\n\n功能：用于从套接字发送消息\n\n```c++\n#include <sys/types.h>\n#include <sys/socket.h>\n\nssize_t send(int sockfd, const void *buf, size_t len, int flags);\n\n/*\n  const char *message = \"Hello, client!\";\n  ssize_t bytes_sent = send(listen_fd, message, std::strlen(message), 0);\n  if (bytes_sent < 0) {\n    std::cerr << \"Error sending message\" << std::endl;\n  } else {\n    std::cout << \"Sent \" << bytes_sent << \" bytes to client\" << std::endl;\n  }\n*/\n```\n\n`sockfd`: 一个有效的套接字文件描述符，通过该套接字发送数据\n\n`buf`: 指向包含待发送数据的缓冲区的指针\n\n`len`: 缓冲区中待发送数据的长度\n\n`flags`: 控制发送操作的标志。常用的标志包括：\n\n- 0: 默认标志，无特殊行为\n- MSG_DONTWAIT: 使操作非阻塞\n- MSG_OOB: 发送带外数据\n- MSG_NOSIGNAL: 阻止发送 SIGPIPE 信号\n\n## connect\n\n功能：用于连接服务端\n\n```c++\n#include <sys/types.h>          /* See NOTES */\n#include <sys/socket.h>\n\n int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);\n\n/*\n    // 配置服务器地址\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(12345); // 服务器端口号\n    server_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); // 服务器地址\n\n    // 连接到服务器\n    if (connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {\n        perror(\"connect\");\n        close(sockfd);\n        exit(EXIT_FAILURE);\n    }\n*/\n```\n\n## 阻塞与非阻塞\n\n阻塞：在进程/线程中，发起一个调用时，**在调用返回之前，进程/线程会阻塞等待**，等待中的进程/线程会让出CPU\n\n非阻塞：在进程/线程中，发起一个调用时，**会立即返回**\n\n前面介绍的 API 中，会阻塞的四个函数有 connect()、accept()、send()、recv()\n\n阻塞IO与非阻塞IO的应用场景：\n\n- 在穿透的网络服务端程序中（每连接每线程/进程），采用阻塞IO\n- 在IO复用的模型中，事件循环（select、poll、epoll）不能被阻塞在任何环节，应该采用非阻塞IO\n\n## 实战代码\n\n服务端\n\n```c++\n#include <iostream>\n#include <cstring>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <unistd.h>\n\n#define LISTEN_NUM 10\n\nint main(int argc, char *argv[]) {\n  if (argc != 3) {\n    std::cout << \"./server 172.17.32.175 8888\" << std::endl;\n    return -1;\n  }\n\n  std::string ip = argv[1];\n  int port = std::stoi(argv[2]);\n\n  int socket_fd = socket(AF_INET, SOCK_STREAM, 0);\n  if (socket_fd < 0) {\n    perror(\"socket error\");\n    return -1;\n  }\n\n  struct sockaddr_in server_addr;\n  memset(&server_addr, 0, sizeof(server_addr));\n  server_addr.sin_family = AF_INET;\n  server_addr.sin_port = htons(port);\n  server_addr.sin_addr.s_addr = inet_addr(ip.c_str());\n\n  int ret = bind(socket_fd, (struct sockaddr *)&server_addr, sizeof(server_addr));\n  if (ret < 0) {\n    perror(\"bind error\");\n    return -1;\n  }\n\n  ret = listen(socket_fd, LISTEN_NUM);\n  if (ret < 0) {\n    perror(\"listen error\");\n    return -1;\n  }\n\n  struct sockaddr_in client_addr;\n  socklen_t client_len = sizeof(client_addr);\n  int listen_fd = accept(socket_fd, (struct sockaddr *)&client_addr, &client_len);\n  if (listen_fd < 0) {\n    perror(\"accept error\");\n    return -1;\n  }\n\n  char buf[1024] = {0};\n  ssize_t bytes_read = recv(listen_fd, buf, sizeof(buf) - 1,0);\n  if (bytes_read < 0) {\n    perror(\"read error\");\n  } else if (bytes_read == 0) {\n    std::cout << \"Client disconnected.\" << std::endl;\n  } else {\n    buf[bytes_read] = '\\0';\n    std::cout << \"Received data: \" << buf << std::endl;\n  }\n\n  const char *message = \"Hello, client!\";\n  ssize_t bytes_sent = send(listen_fd, message, std::strlen(message), 0);\n  if (bytes_sent < 0) {\n    perror(\"send error\");\n    return -1;\n  } else {\n    std::cout << \"Sent message: \" << message << std::endl;\n  }\n\n\n  close(listen_fd);\n  close(socket_fd);\n\n  return 0;\n}\n```\n\n客户端\n\n```c++\n#include <iostream>\n#include <cstring>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <unistd.h>\n\nint main(int argc, char *argv[]) {\n  if (argc != 3) {\n    std::cout << \"Usage: \" << argv[0] << \" <server_ip> <server_port> <message>\" << std::endl;\n    return -1;\n  }\n\n  std::string server_ip = argv[1];\n  int server_port = std::stoi(argv[2]);\n  std::string message;\n  std::cout<<\"input message : \";\n  std::cin>>message;\n\n  int sock_fd = socket(AF_INET, SOCK_STREAM, 0);\n  if (sock_fd < 0) {\n    perror(\"socket error\");\n    return -1;\n  }\n\n  struct sockaddr_in server_addr;\n  memset(&server_addr, 0, sizeof(server_addr));\n  server_addr.sin_family = AF_INET;\n  server_addr.sin_port = htons(server_port);\n  inet_pton(AF_INET, server_ip.c_str(), &server_addr.sin_addr);\n\n  int ret = connect(sock_fd, (struct sockaddr *)&server_addr, sizeof(server_addr));\n  if (ret < 0) {\n    perror(\"connect error\");\n    return -1;\n  }\n\n  ssize_t bytes_sent = send(sock_fd, message.c_str(), message.size(), 0);\n  if (bytes_sent < 0) {\n    perror(\"send error\");\n    return -1;\n  } else {\n    std::cout << \"Sent message: \" << message << std::endl;\n  }\n\n  char buf[1024] = {0};\n  ssize_t bytes_read = recv(sock_fd, buf, sizeof(buf) - 1,0);\n  if (bytes_read < 0) {\n    perror(\"read error\");\n  } else if (bytes_read == 0) {\n    std::cout << \"Server disconnected.\" << std::endl;\n  } else {\n    buf[bytes_read] = '\\0';\n    std::cout << \"Received data: \" << buf << std::endl;\n  }\n\n  close(sock_fd);\n  return 0;\n}\n```\n\n通信效果：\n\n![实战TCP通信.png](/images/2024/08/10/ef5a9aa0-56b0-11ef-9b76-6d6092cc6dd4.png)\n\n---\n\n⭐️内容取自译者陈涓、赵振平《TCP/IP高效编程：改善网络程序的44个技巧》，仅从中取出个人以为需要纪录的内容。不追求内容的完整性，却也不会丢失所记内容的逻辑性。如果需要了解细致，建议读原书。","tags":["网络编程"],"categories":["technology"]},{"title":"记住：TCP不是轮询的","url":"/2024/08/10/记住：TCP不是轮询的/","content":"\nTCP 无法将连接的丢失立即通知应用程序，我们下面就探讨为什么 TCP 不提供这种通知机制，不这么做的优点和缺点，以及应用程序程序员必须完成哪些工作以检测连接的丢失。\n\n## 为什么不设计连接丢失即时通知机制\n\n显然，对可用网络带宽的耗费是 TCP 不提供连接丢失即时通知的原因之一。大部分应用程序都不需要即时通知，因此**不应该为之付出降低带宽的代价**。如果应用程序确实需要及时获得对等实体不可达的信息，可以像稍后讨论的那样，实现自己的丢失发现机制。比方说 HTTP 只支持客户端向服务端主动通信，服务端却不可以主动给客户端推送消息。如果非要服务端主动和客户端通信，就可以利用轮询机制，即让客户端定时发送消息给服务端，服务端再给客户端回消息来营造服务端主动和客户端通信的假象。尽管轮询机制是常见的思想，但是非常容易被替代，因为对资源有太多不必要的消耗，这就是为什么 WebSocket 有出现的必要。\n\n但 TCP 不提供连接丢失即时通知最重要的原因与其主要设计目标之一有关：出现网络故障时维护通信的能力。国防部赞助的一项研究要提供一种即使在发生战争或自然灾害这种严重网络损坏的情况下，也能维护可靠网络通信的网络协议，TCP就是这种研究的产物。**通常，网络故障只是暂时的，有时路由器会为连接找到另一条路径。TCP允许临时的连接丢失，但通常可以在终端应用程序还没意识到的情况下处理好这些网络中断**。\n\n强制应用程序去监视网络的缺点在于必须将代码构建到每个（需要它的）应用程序中去，如果实现上考虑不周，就会浪费带宽，还可能产生一些对网络及其他用户有不利影响的行为。但也有人持不同的意见，认为应该在应用程序去监视网络，就可以对其进行精细调整以适应应用程序的需要，并尽可能地与应用程序协议无缝结合。\n\n## 如何在应用层实现连接丢失即时通知机制\n\n这里不介绍POSIX套接字提供的保持活跃机制，而是着重介绍心跳信号机制。书里面介绍两种实现方式：\n\n- `规定通信格式`来确定客户端的存活，即只需要为心跳报文增加一个报文类型\n  1. **定义心跳消息类型**：在协议中定义一个特殊的消息类型，例如 `HEARTBEAT`\n  2. **定期发送心跳消息**：客户端和服务器定期发送心跳消息以表示连接仍然活跃\n  3. **接收并处理心跳消息**：接收方收到心跳消息后，更新最后一次接收到心跳消息的时间\n- `没有规定通信格式`，那么通信的数据中就无法找到客户端发送的消息，心跳信号机制也就失效。对于没有规定通信格式的这种，启动一个独立的连接来发送和接受心跳信号\n  1. **建立心跳连接**：客户端和服务器建立一个独立的连接专门用于心跳信号\n  2. **定期发送心跳消息**：在心跳连接上定期发送心跳消息\n  3. **接收并处理心跳消息**：接收方在心跳连接上接收并处理心跳消息\n---\n⭐️内容取自译者陈涓、赵振平《TCP/IP高效编程：改善网络程序的44个技巧》，仅从中取出个人以为需要纪录的内容。不追求内容的完整性，却也不会丢失所记内容的逻辑性。如果需要了解细致，建议读原书。","tags":["网络编程"],"categories":["technology"]},{"title":"理解面向连接和无连接协议之间的区别","url":"/2024/08/10/理解面向连接和无连接协议之间的区别/","content":"\n**面向连接和无连接指的都是协议**。也就是说，这些术语指的**并不是物理介质本身**，而是用来**说明如何在物理介质上传输数据的**。面向连接和无连接协议可以，而且通常也确实会共享同一条物理介质。\n\n如果两者的区别与承载数据的物理介质无关，又和什么有关呢？它们的本质区别在于，对无连接协议来说，每个分组的处理都独立于所有其他分组，而对面向连接的协议来说，协议实现则维护了与后继分组有关的状态信息。\n\n请看如下表格：\n\n| 面向连接/无连接 | 具体协议 | 可靠/不可靠 |\n| --------------- | :------: | ----------- |\n| 面向连接        |   TCP    | 可靠传输    |\n| 面向无连接      |   UDP    | 不可靠传输  |\n\n**无连接协议**中的分组被称为数据报（datagram），每个分组都是独立寻址，并由应用程序发送的。从协议的角度来看，**每个数据报都是一个独立的实体，与在两个相同的对等实体之间传送的任何其他数据报都没有关系**，这就意味着协议很可能是不可靠的。也就是说，网络会尽最大努力传送每一个数据报，但并不保证数据报不丢失、不延迟或者不错序传输。\n\n另一方面，**面向连接的协议**则**维护了分组之间的状态**，使用这种协议的应用程序通常都会进行长期的对话。记住这些状态，协议就可以提供可靠的传输。比如，发送端可以记住哪些数据已经发送出去了但还未被确认，以及数据是什么时候发送的。如果在某段时间间隔内没有收到确认，发送端可以重传数据。接收端可以记住已经收到了哪些数据，并将重复的数据丢弃。如果分组不是按序到达的，接收端可以将其保存下来，直到逻辑上先于它的分组到达为止。\n\n使用无连接协议就像寄信，而使用面向连接的协议就像打电话。前者不管对方是否已经和自己连接成功，直接把数据发送出去，也就不关心数据是否真的到达了。后者和对方发送数据之前务必保证连接已经成功，通过三次握手来确保双方发送和接受能力以及连接成功，后续的数据发送也有相应的防丢失机制，比方说重传机制等。\n\n---\n\n⭐️内容取自译者陈涓、赵振平《TCP/IP高效编程：改善网络程序的44个技巧》，仅从中取出个人以为需要纪录的内容。不追求内容的完整性，却也不会丢失所记内容的逻辑性。如果需要了解细致，建议读原书。","tags":["网络编程"],"categories":["technology"]},{"title":"提防对等实体的不友好动作","url":"/2024/08/10/提防对等实体的不友好动作/","content":"\n亦如在程序中接受用户的输入前，要对用户的输入进行“安全检测”，以防止恶意输入破坏应用程序的正常运行。可见，防御性编程在编码中是必备的意识，网络编程中也要考虑各种概率看似很小的事件，做出相应的处理动作。\n\n## 检测客户端的终止\n\n![检测客户端的终止.png](/images/2024/08/10/ddfaa030-56af-11ef-9b76-6d6092cc6dd4.png)\n\n这段代码中，如果客户端发送字符串\"quit\"代表客户端要退出，服务器这边就可以正常和客户端断开连接。如果客户端发生故障或者异常导致没有发生字符串\"quit\"，那么服务器这边就会频繁执行最后一条分支语句。\n\n可以只在读操作上设置一个定时器，如果客户端在某段时间区间内没有发出请求，服务器就假定客户端已经不存在了。很多 FTP 服务器就是这么做的：如果客户端在某段时间区间内没有发送任何请求，服务器就放弃连接。用一个显式定时器或者像心跳实例那样使用 select 定时器，就可以很方便地解决这个问题。\n\n## 检测无效输入\n\n即客户端恶意输入无效字符，服务器如果没有进行“拦截检测”，可能会造成程序崩溃。崩溃最常见的两种原因是缓冲器溢出和指针丢失。\n\n`缓冲区溢出`是由于写入的数据超过了缓冲区的大小，从而覆盖了相邻的内存区域。为了防止缓冲区溢出，可以采取以下措施：\n\n1. **使用安全函数**：使用库中提供的安全函数，例如 `strncpy` 代替 `strcpy`，`snprintf` 代替 `sprintf` 等\n2. **手动检查长度**：在写入数据之前，手动检查输入数据的长度是否超过了缓冲区的大小\n\n`指针丢失`通常是由于未正确初始化指针或错误释放内存导致的。为了防止指针丢失，可以采取以下措施：\n\n1. **初始化指针**：确保所有指针在使用之前都被初始化\n2. **检查指针有效性**：在使用指针之前，检查指针是否为空（`nullptr`）\n3. **正确管理内存**：C++11 提供的智能指针\n---\n⭐️内容取自译者陈涓、赵振平《TCP/IP高效编程：改善网络程序的44个技巧》，仅从中取出个人以为需要纪录的内容。不追求内容的完整性，却也不会丢失所记内容的逻辑性。如果需要了解细致，建议读原书。","tags":["网络编程"],"categories":["technology"]},{"title":"实践论","url":"/2024/08/09/实践论/","content":"\n再多的想法，还只是停留在认识阶段，而认识终归是要落实的，如果只是认识而不去实践，永远不可能和真理沾边。人类的理性是有限的，没人能够绝对保证自己认识的准确性，一定要把自己的认识投身于实践中去，在实践中证明认识的准确性，在实践中修正认识的不足性。真正长久的智慧不可能来源于一成不变的理论，而是来源于持续迭代并且保持学习的理论。\n\n> 判定认识或理论之是否真理，不是依主观上觉得如何而定，而是依客观上社会实践的结果如何而定。真理的标准只能是社会的实践。\n\n经验可分为直接经验和间接经验，如书本中获取的经验就属于间接经验，结合书本中的知识去实践得到的经验是直接经验。我们不能说间接经验一定是认识的低级阶段，首先间接经验也来源于直接经验，其次历史也不断从直接经验中迭代间接经验，从间接经验中依旧能获取高阶的认识，甚至是绝大部分获取高阶认识的来源，这同样源于间接经验比直接经验更容易获得并掌握。然而，回顾间接经验之所以能作为高阶认识的来源，恰恰就是在历史场合中接受直接经验的更正，如果我们依旧想要后面的人能够从间接经验中获取更高的认识，那么通过实践获得直接经验并丰富或修正间接经验依旧是必不可少的。前面这种为后人考虑的说法确实伟大，但从个体角度来看，这同样是适用的。常言到“尽信书不如无书”，恰恰就是对人类理性的尊重，并且强调要用直接经验检验间接检验。\n\n> 我们的实践证明：感觉到了的东西，我们不能立刻理解它，只有理解了的东西才更深刻地感觉它。感觉只解决现象问题，理论才解决本质问题。这些问题的解决，一点也不能离开实践。无论何人要认识什么事物，除了同那个事物接触，即生活于（实践于）那个事物的环境中，是没有法子解决的。不能在封建社会就预先认识资本主义社会的规律，因为资本主义还未出现，还无这种实践。\n\n拥有足够多大的信息，理性才能充分发挥。这叫好像一堆拼图碎片，如果能够尽可能获取更多的碎片，那么距离得到此拼图的本质模样就更容易。\n\n> 认识的过程，第一步，是开始接触外界事情，属于感觉的阶段。第二步，是综合感觉的材料加以整理和改造，属于概念、判断和推理的阶段。只有感觉的材料十分丰富（不是零碎不全）和合于实际（不是错觉），才能根据这样的材料造出正确的概念和论理来。\n\n通过循环再次回来，但每次回来都拿着进一步地正确认识，就好像注入新的生命力一样。认识、实践、再认识、再实践，如此反复，永无止尽。\n\n> 通过实践而发现真理，又通过实践而证实真理和发展真理。从感性认识而能动地发展到理性认识，又从理性认识而能动地指导革命实践，改造主观世界和客观世界。实践、认识、再实践、再认识，这种形式，循环往复以至无穷，而实践和认识之每一循环的内容，都比较地进到了高一级的程度。这就是辩证唯物论的全部认识论，这就是辩证唯物论的知行统一观。","tags":["毛泽东选集","毛泽东"],"categories":["article"]},{"title":"接受毛泽东的思想批评之没有把握是缺乏认识和实践","url":"/2024/08/09/接受毛泽东的思想批评之没有把握是缺乏认识和实践/","content":"\n常常听到一些同志在不能勇敢接受工作任务时说出来的一句话：没有把握。为什么没有把握呢？因为他对于这项工作的内容和环境没有规律性的了解，或者他从来就没有接触过这类工作，或者接触得不多，因而无从谈到这类工作的规律性。及至把工作的情况和环境给以详细分析之后，他就觉得比较地有了把握，愿意去做这项工作。如果这个人在这项工作中经过了一个时期，他有了这项工作的经验了，而他又是一个肯虚心体察情况的人，不是一个主观地、片面地、表面地看问题的人，他就能够自己做出应该怎样进行工作的结论，他的工作勇气也就可以大大地提高了。只有那些主观地、片面地和表面地看问题的人，跑到一个地方，不问环境的情况，不看事情的全体（事情的历史和全部现状），也不触到事情的本质（事情的性质及此一事情和其他事情的内部联系），就自以为是地发号施令起来，这样的人是没有不跌交子的。","tags":["反省"],"categories":["various"]},{"title":"40.组合总和 II","url":"/2024/08/09/40-组合总和-II/","content":"\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtrace(vector<int>& candidates, int target,int start,bool note) {\n        if (target == 0) {\n            result.push_back(path);\n            return;\n        }\n        if (target < 0) {\n            return;\n        }\n        for (int i = start; i < candidates.size(); i++) {\n            if(!note && i > 0 && candidates[i-1] == candidates[i]) continue; // 应对重复元素\n            path.push_back(candidates[i]);\n            target -= candidates[i];\n            backtrace(candidates, target, i + 1,true);\n            note = false;\n            path.pop_back();\n            target += candidates[i];\n        }\n    }\n\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        sort(candidates.begin(),candidates.end());\n        backtrace(candidates,target,0,false);\n        return result;\n    }\n};\n```\n\n前面做的组合题，不管强调与否，我们都知道数组中的元素是没有重复的，但这道题恰恰相反。看来只要解决重复元素可能带来的问题就可以了。\n\n首先需要对元素进行排序，这样益于跳过重复的元素，可以说必须做这一步。难道我们只需要判断 前后两个数据是否相同就能忽略重复的元素带来的问题吗？\n\n```c++\ni > 0 && candidates[i-1] == candidates[i]\n```\n\n不是，因为进入 backtrace 中导致本来用来满足需求的元素被忽略，仔细看下面这个例子：\n\n```bash\ncandidates = {1，1，1，2，1}，target = 2\n```\n\n第一个元素和第二个元素可以组合，但是由于如上的判断条件导致忽略。造成这个的原因是，我们本意忽略的元素是处于同一层的相同元素，但是进入 backtrace  中的元素属于要和上一层元素进行组合的，不应该忽略。\n\n那么我们就用一个布尔值 note 标记，如果 note 为 false 表明在同一层（同一个栈），否则在不同层（不同栈）。同层的元素相同可被忽略，不同层的元素相同不可被忽略。","tags":["回溯"],"categories":["leetcode"]},{"title":"39.组合总和","url":"/2024/08/09/39-组合总和/","content":"\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtrace(const vector<int>& candidates, int target,int start) {\n        if (target == 0) {\n            result.push_back(path);\n            return;\n        }\n        if (target < 0) {\n            return;\n        }\n        for (int i = start; i < candidates.size(); i++) {\n            path.push_back(candidates[i]);\n            target -= candidates[i];\n            backtrace(candidates, target,i);\n            path.pop_back();\n            target += candidates[i];\n        }\n    }\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        backtrace(candidates, target,0);\n        return result;\n    }\n};\n```\n\n相较于之前的题目，数组中的元素**同一个**数字可以**无限制重复被选取**，我们就得保证当前元素在下一次选择中依旧可以选择自己。要记住这是一道组合题，后续的元素是不能往前看的，即不能再选择之前的元素。要想同时达到前面两个条件，我们的做法是 传递到 backtrace 中的 start 参数 不在 自加，既 传递 i 作为参数，而不是 i + 1 作为参数。\n\n为什么组合中，其后的元素不能往前看，即不能再选择之前的元素？\n\n因为我们的回溯会把当前元素和后面的元素所有可能都尝试一遍，而组合不强调顺序性，这就是为什么组合中其后的元素没有必要往前看。","tags":["回溯"],"categories":["leetcode"]},{"title":"17.电话号码的字母组合","url":"/2024/08/09/17-电话号码的字母组合/","content":"\n```c++\nclass Solution {\npublic:\n    const string list[10] = {\"\",    \"\",    \"abc\",  \"def\", \"ghi\",\n                             \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n\n    vector<string> result;\n    string path;\n    void backtrace(string digits, int size, int note, int start) {\n        if (note == size) {\n            result.push_back(path);\n            return;\n        }\n        for (int i = start; i < size; i++) {\n            int num = digits[i] - '0';\n            for (int j = 0; j < list[num].size(); j++) {\n                path.push_back(list[num][j]);\n                note++;\n                backtrace(digits, size, note, i + 1);\n                path.pop_back();\n                note--;\n            }\n        }\n    }\n\n    vector<string> letterCombinations(string digits) {\n        if (!digits.empty()) {\n            backtrace(digits, digits.size(), 0, 0);\n        }\n        return result;\n    }\n};\n```\n\n在完成《77.组合》基础上，这道题你要会两个技能，分别是建立映射关系（通常是数组）和单个数字字符转换为对应的整数（ch - '0'）。\n\n","tags":["回溯"],"categories":["leetcode"]},{"title":"218.组合III","url":"/2024/08/09/218-组合III/","content":"\n```c++\nclass Solution {\npublic:\n    int SIZE = 9;\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtrace(int k, int n,int start,int note,int sum) {\n        if(k == note && sum == n){\n            result.push_back(path);\n            return;\n        }\n        for(int i = start; i <= SIZE; i++){\n            path.push_back(i);\n            sum += i;\n            note++;\n            backtrace(k,n,i + 1,note,sum);\n            path.pop_back();\n            sum -= i;\n            note--;\n        }\n    }\n\n    vector<vector<int>> combinationSum3(int k, int n) {\n        backtrace(k,n,1,0,0);\n        return result;\n    }\n};\n```\n\n在完成《77.组合》基础上，这道题无外乎增加一个额外的条件，即需要 path 中数的总和为 n，其中限制元素个数为 k。至于题目中明确强调的“每个数字**最多使用一次** ”无需多言，在《77.组合》中就已经没有重复利用已用过的数字，因为我们都是从当前数的下一个数开始遍历，并不会回头看。","tags":["回溯"],"categories":["leetcode"]},{"title":"77.组合","url":"/2024/08/09/77-组合/","content":"\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtrace(int n, int k, int start, int note) {\n        if (note == k) { // 终止条件\n            result.push_back(path);\n            return;\n        }\n        for (int i = start; i <= n; i++) {\n            path.push_back(i);\n            note++;\n            backtrace(n, k, i + 1, note);\n            path.pop_back();\n            note--;\n        }\n    }\n\n    vector<vector<int>> combine(int n, int k) {\n        backtrace(n, k, 1, 0);\n        return result;\n    }\n};\n```\n\nnote 记录已存储路径的长度，用以终止回溯，终止条件是回溯当中不可获取的。\n\n组合不在意顺序，因此 [1,4] 和 [4,1] 属于同一个路径，不能同时加入到总路径中，只能取其一。为了方便，按照有序进行排布会容易做题，在代码中也是通过 i + 1 传递 到 backtrace 中作为 start 参数，表示遍历路径的起始位置。\n\n回溯的体现就在于，你添加的操作在从 backtrace 结束之后对应的删除操作，比方说 `path.push_back(i)` 对应 `path.pop_back()`，`note++` 对应 `note--`。\n\n![组合.png](/images/2024/08/09/bc6fb5b0-55f9-11ef-9ecf-d962743c35c1.png)","tags":["回溯"],"categories":["leetcode"]},{"title":"8. 字符串转换整数 (atoi)","url":"/2024/08/09/8-字符串转换整数-atoi/","content":"\n```c++\nclass Solution {\npublic:\n    void clearSpaces(std::string& str) {\n        size_t i = 0;\n        while (i < str.size() && str[i] == ' ') {\n            ++i;\n        }\n        str.erase(0, i);\n    }\n\n    std::string readNum(const std::string& str) {\n        std::string reStr;\n        for (char s : str) {\n            if (isdigit(s)) {\n                reStr += s;\n            } else {\n                break;\n            }\n        }\n        return reStr;\n    }\n\n    void clearZero(std::string& str){\n        int i;\n        for(i = 0; i < str.size(); i++){\n            if(str[i] != '0'){\n                break;\n            }\n        }\n        str.erase(str.begin(),str.begin() + i);\n    }\n\n    unsigned long long strToNum(string& str, bool note) {\n        if(str.size() > 10){\n            if(note){\n                return INT32_MIN;\n            }\n            return INT32_MAX;\n        }\n        reverse(str.begin(), str.end());\n        unsigned long long chen = 1;\n        unsigned long long renum = 0;\n        for (auto s : str) {\n            int num = s - '0';\n            renum += chen * num;\n            chen *= 10;\n            if (renum >= INT32_MAX) {\n                if(note){\n                    if(renum != INT32_MAX){\n                        return INT32_MIN;\n                    }else{\n                        return -renum;\n                    }\n                }\n                return INT32_MAX;\n            }\n        }\n        if(note){\n            return -renum;\n        }\n        return renum;\n    }\n\n    int myAtoi(std::string s) {\n        if (s.empty()) {\n            return 0;\n        }\n        bool isNegative = false;\n\n        // 去除字符串中无用的空格\n        clearSpaces(s);\n\n        // 如果第一个字符是字母，直接返回0\n        if (s.empty() || isalpha(s[0])) {\n            return 0;\n        }\n\n        // 处理正负号\n        if (s[0] == '-') {\n            isNegative = true;\n            s.erase(s.begin());\n        } else if (s[0] == '+') {\n            s.erase(s.begin());\n        }\n\n        // 读取完整的字符型数字\n        std::string numStr = readNum(s);\n        if (numStr.empty()) {\n            return 0;\n        }\n        // 排除前面的0\n        clearZero(numStr);\n\n        // 一切准备工作完成，开始把 字符串 转换为 数字\n        long long re = strToNum(numStr,isNegative);\n\n        return re;\n    }\n};\n```\n\n这道题在力扣上的通过率非常低，当前是21.3%的通过率。我花费一个早上写的代码，最终还有一个测试用例没有通过，由于有其他事情暂时搁置。直到明天的早上，也就是今天早上，没过多久就把测试用例给过了，因为在搁置之后发现最后一个没有通过的测试用例可以通过判断数字是否过大而直接返回 INT32_MAX 或 INT32_MIN。\n\n我们在进行字符串转换为数字之前，需要做很多预备工作，因为字符串里面有很多混杂的非数字字符：\n\n1. 如果是空字符，直接返回 0\n2. 去除字符串中无用的空格\n3. 如果第一个字符是字母，直接返回 0\n4. 记录正负号\n5. 读取完整的字符型数字\n6. 排除前面的 0\n\n按照这个顺序来，我们的字符串就必然是全部由数字组成，就可以真正的去做字符串转数字的工作了\n\n```c++\nunsigned long long strToNum(string& str, bool note) {\n    if(str.size() > 10){\n        if(note){\n            return INT32_MIN;\n        }\n        return INT32_MAX;\n    }\n    reverse(str.begin(), str.end());\n    unsigned long long chen = 1;\n    unsigned long long renum = 0;\n    for (auto s : str) {\n        int num = s - '0';\n        renum += chen * num;\n        chen *= 10;\n        if (renum >= INT32_MAX) {\n            if(note){\n                if(renum != INT32_MAX){\n                    return INT32_MIN;\n                }else{\n                    return -renum;\n                }\n            }\n            return INT32_MAX;\n        }\n    }\n    if(note){\n        return -renum;\n    }\n    return renum;\n}\n```\n\n按照题目要求，应该返回[INT32_MIN,INT32_MAX]区间内的数字，下面部分说明\n\n1. 如果字符串的长度大于 10，表明必然已经越界。如果这个数为负数，那么返回INT32_MIN，否则返回INT32_MAX\n2. 在循环取值计算的过程中，如果 renum 有 大于等于 INT32_MAX情况就要进行处理，避免后续没有意义的计算\n\n下面这个地方容易让人不理解，但这实际是由 INT32_MIN（2147483648） 和 INT32_MAX（2147483647）不对称导致的。由于 INT32_MIN 绝对值 大于 INT32_MAX 绝对值，所以当 renum >= INT32_MAX 进入判断的时候，我们继续考虑当这个数为负数情况下，如果 renum = INT32_MAX，应该返回 -renum，而不能直接返回 INT32_MIN。\n\n```c++\nif (renum >= INT32_MAX) {\n    if (note) {\n        if (renum != INT32_MAX) {\n            return INT32_MIN;\n        } else {\n            return -renum;\n        }\n    }\n    return INT32_MAX;\n}\n```","tags":["字符串"],"categories":["leetcode"]},{"title":"CPP 中 cctype 库的常用方法","url":"/2024/08/08/CPP-中-cctype-库的常用方法/","content":"\n`std::isalpha`: 判断是否为字母\n\n`std::isdigit`: 判断是否为数字\n\n`std::isalnum`: 判断是否为字母或数字\n\n`std::iscntrl`: 判断是否为控制字符\n\n`std::isgraph`: 判断是否为除空格外的可打印字符\n\n`std::islower`: 判断是否为小写字母\n\n`std::isupper`: 判断是否为大写字母\n\n`std::isprint`: 判断是否为可打印字符（包括空格）\n\n`std::ispunct`: 判断是否为标点符号\n\n`std::isspace`: 判断是否为空白字符（如空格、换行、制表符等）\n\n`std::isxdigit`: 判断是否为十六进制数字\n\n如上这些方法是用来判断是否为某种字符的，如果是返回true，如果不是返回false\n\n通常我们在处理哪种需要判断给定的字符串中有多少数字、多少字母等会非常好用\n\n下面再介绍此头文件中的另外两个方法，即大小写字母转换\n\n`std::tolower`：转换为小写\n\n`std::toupper`：转换为大写","tags":["CPP"],"categories":["technology"]},{"title":"66.加一","url":"/2024/08/08/66-加一/","content":"\n```c++\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        bool flag = true;   // 存在进位\n        vector<int> data;\n        if(digits[digits.size() - 1] + 1 != 10){    // 如果加1不会进位，返回最后一个元素加1的原数组\n            digits[digits.size() - 1]++;\n            return digits;\n        }\n\n        for(int i = digits.size() - 1; i >= 0; i--){\n            if(flag){\n                if(digits[i] + 1 != 10){    // 后续不会有进位，flag = false;\n                    data.push_back(digits[i] + 1);\n                    flag = false;\n                }else{  // 后续还有进位，flag保持不变\n                    data.push_back(0);\n                }\n            }else{  // 没有进位，添加原数组元素即可\n                data.push_back(digits[i]);\n            }\n        }\n        if(flag){   // 如果有进位，代表这个数是 N 个 9组成，所以添加元素 1\n            data.push_back(1);\n        }\n        reverse(data.begin(),data.end());   // 反转\n        return data;\n    }\n};\n```\n\n这道题容易让人误解，应该把题意讲得清楚些。有一个自然数，被拆分成个位数存储在数组中，对这个自然数进行加 1 操作。很明显，如果我们的自然是99，那么加 1 的结果就是 100，显然原数组是存储不下的，因为vector容器不支持头部插入元素。\n\n如果数组中的末尾元素 加 1 之后不存在进位，只需要把原数组的末尾元素加 1 之后返回即可。\n\n如果存在进位，就需要声明一个新的容器 data 来存储元素，避免原数组因为进位操作导致无法存储超过原长度的元素个数。基于存在进位的这种情况开始对原数组进行计算，第一次进入 for 循环中肯定是存在进位的情况。如果当前元素加 1 依旧满足进位，那么 flag 保持不变，添加元素 0 到 data 容器中。如果当前元素 加 1 不满足进位，flag 设置为 false，添加当前元素 加 1 之后的结果到 data容器中。\n\n前面讲，进入 for 循环的第一次必然存在进位，那么此后就会出现两种情况：如果 flag 为 false ，后续的原数组元素添加到 data 容器中即可。如果 flag 依旧为 true，那不过是重复上面的逻辑，直到 flag 为 false 才进入到”原数组元素添加到 data 容器中即可“阶段。\n\n如果 flag 始终为 true ，那么还需要添加元素 1 到 data 容器中。假定自然数为99，那么上面的逻辑执行下来，数组中存储的元素是 0 0。所以，如果 flag 依旧为 true，我们需要继续添加 元素 1 进来，否则不进行新的元素添加。然后就可以 data 容器反转之后进行返回，得到符合题意的结果。","tags":["数组"],"categories":["leetcode"]},{"title":"26.删除有序数组中的重复项","url":"/2024/08/08/26-删除有序数组中的重复项/","content":"\n```c++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if(nums.size() == 1) return 1;\n        int left = 0;       // 用于比较是否重复\n        int right = 1;      // 用于指定更新值的下标\n        for(int i = 1; i < nums.size(); i++){\n            while(nums[left] != nums[i]){\n                nums[right] = nums[i];\n                right++;\n                left = i;\n            }\n        }\n        return right;\n    }\n};\n```\n\n双指针法，right 用于指向更新值的下标，left 用于比较是否重复。\n\n如果nums[left] 和 nums[i] 不相等，表明遇到不是重复的新值，然后把这个新值赋值给 nums[right]，继而把 right 和 left 的下标进行更新。","tags":["数组"],"categories":["leetcode"]},{"title":"关心群众生活，注意工作方法","url":"/2024/08/07/关心群众生活，注意工作方法/","content":"\n要想动员群众，就得关心群众生活，否则只是向人民群众提出要求，不仅没想着解决矛盾，倒还创造矛盾，激化矛盾，这是不可以的。我们的党和政府始终要与群众保持联系，否则提出的新规划不能解决当下的矛盾，群众得不到实际的好处，就会被认为是大话，空话，甚至沦为笑话。\n\n> 在我们的工作人员中，曾经看见这样的情形：他们只讲扩大红军，扩充运输队，收土地税，推销公债，其他事情呢，不讲也不管，甚至一切都不管。\n\n> 就得和群众在一起，就得去发动群众的积极性，就得关心群众的痛痒，就得真心实意地为群众谋利益，解决群众的生产和生活的问题，盐的问题，米的问题，房子的问题，衣的问题，生小孩子的问题，解决群众的一切问题。\n\n理论和实践有很大的差距，提出利于群众的政策，下面有实权的人就要实打实地去做，不要群众没得到实惠，就用假数据假信息蒙骗上级。不要让下级成为过滤网，过滤好的留在自己手里，留些残渣渗下去，层层滤网，还能流出多少实惠给到群众？需要严格把关下级传递上来的信息，保证信息的准确性、完整性、可靠性，若有半点偷奸耍滑者，立即处置。\n\n> 我们的任务是过河，但是没有桥或没有船就不能过。不解决桥或船的问题，过河就是一句空话。不解决方法问题，任务也只是瞎说一顿。不注意扩大红军的领导，不讲究扩大红军的方法，尽管把扩大红军念一千遍，结果还是不能成功。","tags":["毛泽东选集","毛泽东"],"categories":["article"]},{"title":"19.删除链表的倒数第 N 个结点","url":"/2024/08/07/19-删除链表的倒数第-N-个结点/","content":"\n```c++\nclass Solution {  \npublic:  \n    ListNode* removeNthFromEnd(ListNode* head, int n) {  \n        ListNode* getLen = head;  \n  \n        ListNode* virtualHead = new ListNode(-1);  \n        virtualHead->next = head;  \n        ListNode* delNode = virtualHead;  \n  \n        int len = 0;  \n        while(getLen){  // 获取链表长度   \n            getLen = getLen->next;  \n            len++;  \n        }  \n        len = len - n;  \n        for(int i = 0; i < len; i++){   // 找到需要移除节点的前一个节点  \n            delNode = delNode->next;  \n        }  \n  \n        delNode->next = delNode->next->next;    // 删除节点  \n          \n        return virtualHead->next;   // 返回头节点  \n    }  \n}; \n```\n\n只要明白链表的特性，以及删除的特点就很容易想到该怎么处理这道题，不会想复杂。我们要删除链表的倒数第 N 个节点，只需要找到这个节点的前一个节点，因为删除链表节点的准则就是找到待删除节点的前一个节点。由于我们是要找倒数第 N 个节点，就要先获取链表长度（只能遍历一次得到），然后`len = len - n`计算出 len ，用于找到待删除节点的前一个节点。","tags":["链表"],"categories":["leetcode"]},{"title":"2.两数相加","url":"/2024/08/07/2-两数相加/","content":"\n```c++\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        bool note = false;\n        ListNode* head = new ListNode(-1);\n        ListNode* rehead = head;\n        while (l1 != nullptr && l2 != nullptr) {\n            int num = l1->val + l2->val;\n            if (note) {\n                num++;\n                note = false;\n            }\n            if (num >= 10) {\n                num = num % 10;\n                note = true;\n            }\n            ListNode* tmp = new ListNode(num);\n            rehead->next = tmp;\n            rehead = rehead->next;\n            l1 = l1->next;\n            l2 = l2->next;\n        }\n        if (l2) {\n            swap(l1, l2);\n        }\n        while (l1 != nullptr) {\n            int num = l1->val;\n            if (note) {\n                num++;\n                note = false;\n            }\n            if (num >= 10) {\n                num = num % 10;\n                note = true;\n            }\n            ListNode* tmp = new ListNode(num);\n            rehead->next = tmp;\n            rehead = rehead->next;\n            l1 = l1->next;\n        }\n        if (note) {\n            ListNode* tmp = new ListNode(1);\n            rehead->next = tmp;\n        }\n        return head->next;\n    }\n};\n```\n\n还是要看懂题目，实际上就是将两个链表从头到尾取相同位置的节点相加，这可能出现以下情况：\n\n- 两个链表长度相同且最后没有产生进位，返回 head->next 即可\n- 两个链表长度相同且最后有产生进位，创建一个值为 1 的新节点 tmp，然后 rehead->next 指向 tmp节点，最后返回 head->next 即可\n- 两个链表长度不同，那么对于没有处理完的链表中的节点逐一移动到 rehead 节点之后，接着进入上述的两种情况中继续处理\n\n```\n输入：l1 = [5,6,4,9], l2 = [2,4,9]\n输出：[7,0,4,0,1]\n解释：9465 + 942 = 10407\n```\n\n当然，还有就是关于进位的处理，这并不难，只需要用一个标记位 note 来标识是否有进位，还有要记得正确更新 note 的情况。\n\n```c++\nif (note) {\n      num++;\n      note = false;\n }\nif (num >= 10) {\n      num = num % 10;\n      note = true;\n}\n```","tags":["链表"],"categories":["leetcode"]},{"title":"143.重排链表","url":"/2024/08/07/143-重排链表/","content":"\n```c++\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) {\n            return head;\n        }\n        ListNode* left = head;\n        ListNode* right = head->next;\n        while (right) {\n            ListNode* node = right->next;\n            right->next = left;\n            left = right;\n            right = node;\n        }\n        head->next = nullptr;\n        return left;\n    }\n\n    void reorderList(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) {\n            return;\n        }\n        // 找到中间节点进行切割，左半部分链表保持不变，反转右半部分链表\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while (fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        ListNode* left = head;\n        ListNode* right = slow->next;\n        slow->next = nullptr;\n        right = reverseList(right);\n\n        // 准备工作已做好，开始重排\n        ListNode* virtualHead = new ListNode(-1);\n        ListNode* tmp = virtualHead;\n        while (left != nullptr && right != nullptr) {\n            tmp->next = left;\n            left = left->next;\n            tmp->next->next = right;\n            right = right->next;\n            tmp = tmp->next->next;\n        }\n\n        if (left != nullptr) {\n            tmp->next = left;\n        }\n\n        head = virtualHead->next;\n    }\n};\n```\n\n这道题只要能够把题目看明白，即它究竟是如何重排，逻辑上理清楚并不难\n\n1. 先找到中间节点，将当前链表分割成两部分，即左链表和右链表\n2. 左链表的尾节点要指向 nullptr，右链表需要反转\n3. 创建一个虚拟头节点用来链接后续重排的节点，先链接左链表的第一个节点，接着链接右链表的第一个节点，如此循环\n4. 如果左链表当前节点和右链表当前节点有一个不满足不为空就退出循环。由于左链表的长度大于或等于右链表（如果大于，也只会比其多一个节点），退出循环之后，继续判断左链表当前节点是否为空，不为空就代表还有一个节点被遗漏，tmp 指向这个节点即可\n5. 最后，记得更换 head 节点为 virtualHead->next\n\n---\n\n完成本题的过程中，犯下的错误是 tmp 节点的移动，错误的逻辑代码如下：\n\n```c++\nwhile (left != nullptr && right != nullptr) {\n  tmp->next = left;\n  tmp = tmp->next;\t\t// 错误的逻辑代码，后续代码也没价值\n  tmp->next = right;\n  tmp = tmp->next;\t\t\n  left = left->next;\n  right = right->next;\n}\n```\n\n因为我们的 left 和 right 节点后面也跟着很多的节点，如果你 tmp = tmp->next，然后再 tmp->next = right，就失去 left 链表的掌控了（left 链表被污染），从而出现错误。\n\n![重排链表.png](/images/2024/08/07/802b1dd0-549e-11ef-996a-6b29d9dcc7bf.png)\n\n所以，只需要每次让 tmp 指向 left 或 right 的节点之后，及时更新 left 和 right 指针即可，保证不被污染\n\n```c++\nwhile (left != nullptr && right != nullptr) {\n     tmp->next = left;\n     left = left->next;\n     tmp->next->next = right;\n     right = right->next;\n     tmp = tmp->next->next;\n }\n```","tags":["链表"],"categories":["leetcode"]},{"title":"142.环形链表II","url":"/2024/08/07/142-环形链表II/","content":"\n```c++\nclass Solution {  \npublic:  \n    ListNode* detectCycle(ListNode* head) {  \n        if (head == NULL || head->next == NULL) {  \n            return nullptr;  \n        }  \n        // 快慢指针，有环必相遇  \n        ListNode* node = head;  \n        ListNode* slow = head;  \n        ListNode* fast = head;  \n        while (fast != nullptr && fast->next != nullptr) {  \n            slow = slow->next;  \n            fast = fast->next->next;  \n            if (slow == fast) { // 有环  \n                while (true) {  \n                    if (node == slow) {  \n                        return slow;  \n                    }  \n                    node = node->next;  \n                    slow = slow->next;  \n                }  \n            }  \n        }  \n        return nullptr;  \n    }  \n};  \n```\n\n此题建立在你已经完成 《141.环形链表》题目，我们重点就关注判断有环之后如果找到第一次相遇的节点。\n\n![环形链表II.png](/images/2024/08/07/fcf6ef00-5490-11ef-996a-6b29d9dcc7bf.png)\n\n我们可以确定如下信息：\n\n- 慢指针必然不可能环绕圆形一圈，快指针至少环绕环形一圈\n- 快指针和慢指针从同一个起点出发，并且快指针是慢指针的两倍\n\n设定 相应的变量之后，得到如下等式：n >= 1，且 n 为正整数 （因为快指针至少环绕环形一圈）\n\n```tex\n(x + y) * 2 = x + y + n ( y + z ) \n\t\t↓\nx = (n - 1)(x + y) + z\n```\n\n我们假定 n == 1，那么 x = z。这个时候再看图，就发现只要 快慢指针的相遇节点和头节点同时向前移动，它们两个的相遇点就是链表开始入环的第一个节点。\n\n---\n\n在完成《141.环形链表》题目的时候，我的第一份代码如下：\n\n```c++\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(head == NULL || head->next == NULL){\n            return false;\n        }\n        ListNode* slow = head;\n        ListNode* fast = head->next;\n        while(fast != nullptr && fast->next != nullptr){\n            if(slow == fast){\n                return true;\n            }\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return false;\n    }\n};\n```\n\n我企图用这份代码来套用到本题，却发现犯了一个大错误，那就是 slow 和 fast 不是同一个起点开始，导致上面的推导公式失效。所以，我们务必保证最初的快慢指针的起点是一致的，即指向头节点。如果是这样，上面的代码还需要改正的地方是，要先进行指针移动，再判断快慢指针是否指向同一个节点，从而判断是否为环形链表。\n\n```c++\nclass Solution {\npublic:\n    bool hasCycle(ListNode* head) {\n        if (head == NULL || head->next == NULL) {\n            return false;\n        }\n        \n        ListNode* slow = head;\n        ListNode* fast = head;\n        while (fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next->next;\n            if (slow == fast) { // 快慢指针，有环必相遇\n                return true;\n            }\n        }\n        return false;\n    }\n};\n```","tags":["链表"],"categories":["leetcode"]},{"title":"141.环形链表","url":"/2024/08/07/141-环形链表/","content":"\n```c++\nclass Solution {\npublic:\n    bool hasCycle(ListNode* head) {\n        if (head == NULL || head->next == NULL) {\n            return false;\n        }\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while (fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next->next;\n            if (slow == fast) { // 快慢指针，有环必相遇\n                return true;\n            }\n        }\n        return false;\n    }\n};\n```\n\n定义快慢指针：\n\n- 慢指针 slow：指向头节点\n- 快指针 fast：指向头节点的下一个节点（在此之前已经有判断条件，保证当前链表至少有一个节点，不会出现未定义行为）\n\n指针的移动在 while 循环中进行，暂且不管 while 得以进行的条件，先假定作用域中的代码能够正常往下推进。先移动快慢指针，慢执行移动一个节点，快指针移动两个节点。如果两个指针指向同一个节点表明有环，如果不是就继续循环。如果最终退出循环，说明这个链表没有环。\n\n这个时候我们再回头看 while中的条件应该怎么写？\n\nfast 指针比 slow 指针更容易指向 nullptr，我们保证 fast 不为 nullptr 就能保证 slow 不为 nullptr。从 while 循环中的移动情况来看，fast 会移动两个节点，那我们就需要保证 fast != nullptr && fast->next != nullptr 。\n\n为什么快慢指针能判断环形链表呢？\n\n如果这是一条直线，快的车永远不可能遇到慢的车，如果遇到必然就是一个环。","tags":["链表"],"categories":["leetcode"]},{"title":"1. 两数之和","url":"/2024/08/07/1-两数之和/","content":"\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int,int> data;\n        vector<int> result;\n        for(int i = 0; i < nums.size(); i++){\n            int re = target - nums[i];\n            auto it = data.find(re);\n            if(it != data.end()){\t\n                result.push_back(i);\t// 当前元素下标\n                result.push_back(it->second);\t// 配对元素下标\n                break;\n            }\n            data[nums[i]] = i;\n        }\n        return result;\n    }\n};\n```\n\n拿到此题个人的解题思路是采用哈希表\n\nC++中具有哈希表特征的是 set 和 map 容器，题目要求获取下标同时又需要参考`target - nums[i]`的结果。因此采用unordered_map容器最佳，即 key 存储`target - nums[i]`的结果，value 存储下标\n\n个人遇到的问题是记不清 map 容器的 find 的方法究竟寻找的 key 还是 value？答案是 key！！！\n\n`std::unordered_map::find` 用于查找键，并返回一个指向该 键-值对 的迭代器","tags":["数组"],"categories":["leetcode"]},{"title":"常用网站","url":"/2024/08/06/常用网站/","content":"\n## API 查阅网站\n\n[cppreference](https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5)：C 和 CPP 库查询\n\n[cplusplus](https://cplusplus.com/reference/)：C 和 CPP 库查询\n\n","tags":["推荐"],"categories":["various"]},{"title":"百香果","url":"/2024/08/06/百香果/","content":"\n## 介绍\n\n西番莲，又名百香果、热情果、鸡蛋果，产于美洲的热带及亚热带地区。原产于巴西，巴拉圭，1610年间传入欧洲西番莲的果汁**常被用作香料，加在其他果汁中**\n\n黄色百香果：营养价值最高，最优选择\n\n![黄色百香果.png](/images/2024/08/06/5b61dc60-5394-11ef-ba61-71329f1643ea.png)\n\n紫色百香果\n\n![紫色百香果.png](/images/2024/08/06/578628d0-5394-11ef-ba61-71329f1643ea.png)\n\n紫红色百香果\n\n![紫红色百香果.png](/images/2024/08/06/4fd02140-5394-11ef-ba61-71329f1643ea.png)\n\n## 名称的来源\n\n西番莲自西班牙语转译至英语称passion fruit，**意即“受难果”**，“百香果”这个名称实际上是“passion”一字为音译。当时西班牙传教士发现其花的形状极似基督之十字架刑具，柱头上3个分裂，极似3根钉，花瓣红斑、恰似耶稣头部被荆棘刺出血形象，5个花药，恰似钉子或伤痕。西班牙人以Passioflos名之，直译为受难花（Passion Flower）。**但英语中passion一词还有“热情”之意，故也常被误译为“热情果”，与原意无关**\n\n## 营养\n\n| 名称       | 含量 |\n| ---------- | ---- |\n| 水分       | 73%  |\n| 碳水化合物 | 22%  |\n| 蛋白质     | 2%   |\n| 脂肪       | 0.7% |\n\n每100克（3.5盎司）的生西番莲提供97卡路里的热量，是**维生素C（33%每日摄入量）的丰富来源**（指比每日摄入量的20%更多），也是**核黄素与钾的中等来源（10-19%每日摄入量）**。其他微量营养素的含量不显著\n\n## 注意点\n\n 一般3~4个就好，多了容易胃酸\n\n因此，对于部分患有胃肠炎、胃溃疡、十二指肠溃疡的患者应谨慎食用\n\n## 挑选方法\n\n1. 观察百香果果皮的质感：最佳选择是**果皮微皱**的略带深紫色的果子，这样的果子最成熟也最甜。可能你想买干净的卖相好的果子，但实际上这并不重要，因为你只吃里面的果肉。果壳越软，果实越成熟\n2. 摇一摇：如果晃动强，说明果肉与果皮分离，很可能是坏的\n3. 闻一闻：通过闻也可以判断口味。如果闻起来有热带水果的香味，一定很香甜；如果闻不出任何味道，果肉要么很酸要么淡而无味\n\n果皮微皱\n\n![挑选百香果.png](/images/2024/08/06/433b9c20-5394-11ef-ba61-71329f1643ea.png)\n\n颜色深，为深紫色（紫红色百香果）\n\n![看颜色.png](/images/2024/08/06/3dc7bc60-5394-11ef-ba61-71329f1643ea.png)\n\n## 参考链接\n\n[维基百科](https://zh.wikipedia.org/wiki/西番莲)\n\n[百度百科](https://baike.baidu.com/item/%E7%99%BE%E9%A6%99%E6%9E%9C/1484850)\n\n[wikiHow](https://zh.wikihow.com/%E4%BA%AB%E7%94%A8%E7%99%BE%E9%A6%99%E6%9E%9C)","tags":["水果"],"categories":["life"]},{"title":"适当谈心的益处","url":"/2024/08/05/适当谈心的益处/","content":"\n回忆学生时代，大家会有过类似的体验：和朋友闹矛盾和好之后，关系比以往更加亲密了。这是因为通过上次不友好的碰撞事件，彼此发现双方的底线位置，相比之前没有距离感的关系，自然离健康的关系更近些。可是，这样的成本未免过高，毕竟以不好的情绪收场，能不能重归于好也只能画个问号。况且，人脱离教室这种空间限制之后，会因为更多的选择而轻易放弃掉这种因不美好收场而暂时破裂的友情，并作为最终结局。\n\n谈心是可行的，能够低成本知道对方的喜恶，以及很多你需要花费智力和感受能力才得知的信息。袒露自己给对方更多就是相信对方的表现，自然而然会距离眼前这个人更加亲近，亲密感、舒适感和熟悉感呈现递增趋势。但不要谈的过多，要选择自己能够谈的内容去谈，如果谈的内容会让你感到恐惧和被威胁的可能，就不要去谈了，除非这个人永远不会和你产生半点联系。","tags":["零碎之思"],"categories":["article"]},{"title":"模板元编程的意义","url":"/2024/08/05/模板元编程的意义/","content":"\n## 模板、元编程和泛型编程\n\n**模板**是一种能够产生代码的代码，本身不进入程序中\n\n**元编程**意味着你撰写一段程序A（前面提到的模板），程序A会运行后生成另外一个程序B，程序B才是真正实现功能的程序。那么这个时候程序A可以称作程序B的元程序，撰写程序A的过程，就称之为“元编程”\n\n如果元编程中所有的变化的量（或者说元编程的参数）都是类型，那么这样的编程，我们称为**泛型编程**\n\n区分泛型编程和元编程，可参考王建伟老师的区分：\n\n- 泛型编程：重点突出的是“通用”的概念，这个“泛”字就是通用的意思。例如函数模板、类模板代码，这些代码很多都以类型作为模板参数进行传递，程序员不需要关心具体的类型，编译器会进行相关的类模板或函数模板的实例化工作。模板的设计初衷也是用于泛型编程--对数据类型和算法等进行抽象\n- 元编程：重点突出的是一种程序设计技巧，达到用常规的编程手段难以达到的效果。这种程序设计技巧非常注重模板在实例化过程中的一些推导过程，而这些推导过程恰恰是解决问题和体现程序设计技巧的过程\n\n```C++\ntemplate <typename T>\nT const& Max (T const& a, T const& b) \n{ \n    return a < b ? b:a; \n} \n```\n\n如上是函数模板，但它并不算是代码，而是用来生成代码（实例化的时候会生成对应的代码），假定你调用如下方法（`Max(3,5)` 和 `Max(1.2,3.1)`）\n\n那么你的程序中只有两部分代码（函数代码 A 和函数代码 B），函数模板并不在其中\n\n从这点我们就明白，模板会在编译期间帮我们把代码生成，而不是在运行时（说此是为了强调和多态机制的不同）\n\n**模板本身并不是最终可执行代码的一部分，而是用于生成最终可执行代码的“蓝图”。模板定义了一个通用的模式，但真正的代码是在模板实例化时生成的**\n\n```c++\nMax(3,5);\n\n//生成函数代码 A\nint const& Max (int const& a, int const& b) \n{ \n    return a < b ? b:a; \n} \n\nMax(1.2,3.1);\n\n//生成函数代码 B\n\nfloat const& Max (float const& a, float const& b) \n{ \n    return a < b ? b:a; \n} \n```\n\n通过模板，我们可以将形形色色的堆栈代码分为两个部分，一个部分是不变的接口，以及近乎相同的实现；另外一部分是元素的类型，它们是需要变化的。因此同函数类似，需要变化的部分，由模板参数来反应；不变的部分，则是模板内的代码。可以看到，使用模板的代码，要比不使用模板的代码简洁许多\n\n## 模板、宏和重载\n\n宏只是替换，没有类型安全检查，代码永远只有一份\n\n模板用来生成代码，编译期间就确定程序所需的代码并实际产生\n\n宏既然是替换，意味着是在运行期间运作，如果暂时不考虑安全问题，效率问题也是不可忽视（通常宏用于短小代码）。函数重载倒是可以编译期间确定，却也因为不具备模板“变化莫测”的特性，略输一筹。这样看来，模板倒是非常强大了，既是在编译期间确定且能应对变化\n\n> 编译期间确定（编译期决策）通常比运行时确定（运行时决策）效率更高。这主要是因为编译期决策在程序运行之前已经确定好了具体的操作，而运行时决策需要在程序执行时进行额外的计算和判断\n>\n> 比方说 if 判断语句，编译期间就已经判断完成，而运行期间会在运行时才去做这个判断\n\n## 面向过程编程、面向对象编程和模板元编程\n\n以牲口圈舍举例谈三种编程，即有三种动物（马羊猪），要给它们分别搭建一个棚（马棚、羊圈、猪圈）\n\n（1）面向过程\n\n一种动物一个棚，种类越多类越多，代码量增多（关键是得自己一个一个写）\n\n但不得不承认，这种编程符合现实世界，即每种动物放在各自的棚里面\n\n![面向过程.png](/images/2024/08/05/ffded890-5323-11ef-8091-ed2d3d2eaedb.png)\n\n（2）面向对象\n\n把棚抽象为一个类，所有动物都放在一个棚里面，继承者只需要实现抽象基类的虚函数即可\n\n相对于面向过程，尽管方法getHeight依旧需要实现，但是无需每次都创建一个棚了，代码量明显减少\n\n可是这脱离现实了，因为没人会把所有动物放在一个棚里面管理（这个棚也是不存在的，是虚拟的）\n\n![面向对象.png](/images/2024/08/05/f8511980-5323-11ef-8091-ed2d3d2eaedb.png)\n\n（3）模板元编程\n\n面向过程要手写很多代码，因为每个动物的类型不同\n\n面向对象又不符合现实情况，按理改为每种动物在不同的棚中，而不是放在一个棚中管理\n\n模板元编程可以只需要设计一份代码，传入不同的类型并生成实际的代码，完美解决面向过程和面向对象的不足\n\n![模板元编程.png](/images/2024/08/05/f249fa70-5323-11ef-8091-ed2d3d2eaedb.png)\n\n## 模板函数和模板类的语法\n\n（1）函数模板\n\n```c++\ntemplate <typename type> \nret-type func-name(parameter list)\n{\n   // 函数的主体\n}\n\n// 举例\ntemplate <typename T>\ninline T const& Max (T const& a, T const& b) \n{ \n    return a < b ? b:a; \n} \n```\n\n（2）类模板\n\n```c++\ntemplate <class type> \nclass class-name \n{\n\t//成员变量、成员方法\n}\n\n// 举例\ntemplate <class T>\nclass Stack { \n  private: \n    vector<T> elems;     // 元素 \n \n  public: \n    void push(T const&);  \t\t// 入栈\n    void pop();                 // 出栈\n    T top() const;             // 返回栈顶元素\n}; \n```\n\n------\n\n参考链接\n\nhttps://sg-first.gitbooks.io/cpp-template-tutorial/content/TMP_ji_chu_md.html","tags":["CPP","模板元编程"],"categories":["technology"]},{"title":"为什么在你的进程退出时没有内存泄露？","url":"/2024/08/05/为什么在你的进程退出时没有内存泄露？/","content":"\n当你编写一个短时间运行的程序时，可能会使用 malloc()分配一些空间。程序运行并即将完成：是否需要在退出前调用几次 `free() `？虽然不释放似乎不对，但在真正的意义上，没有任何内存会“丢失”。原因很简单：系统中实际存在两级内存管理。\n\n第一级是由操作系统执行的内存管理，操作系统在进程运行时将内存交给进程，并在进程退出（或以其他方式结束）时将其回收。第二级管理在每个进程中，例如在调用 `malloc()` 和  `free()` 时，在堆内管理。即使你没有调用 `free()`（并因此泄露了堆中的内存），操作系统也会在程序结束运行时，收回进程的所有内存（包括用于代码、栈，以及相关堆的内存页）。无论地址空间中堆的状态如何，操作系统都会在进程终止时收回所有这些页面，从而确保即使没有释放内存，也不会丢失内存。\n\n因此，对于短时间运行的程序，泄露内存通常不会导致任何操作问题（尽管它可能被认为是不好的形式）。如果你编写一个长期运行的服务器（例如 Web 服务器或数据库管理系统，它永远不会退出），泄露内存就是很大的问题，最终会导致应用程序在内存不足时崩溃。当然，在某个程序内部泄露内存是一个更大的问题：操作系统本身。这再次向我们展示：编写内核代码的人，工作是辛苦的……\n\n---\n\n内容取自译者王海鹏《操作系统导论》，仅从中取出个人以为需要纪录的内容。不追求内容的完整性，却也不会丢失所记内容的逻辑性。如果需要了解细致，建议读原书","tags":["技术摘录"],"categories":["technology"]},{"title":"多线程中的虚假唤醒","url":"/2024/08/05/多线程中的虚假唤醒/","content":"\n当一个正在等待条件变量的线程由于条件变量被触发而唤醒时，却发现它等待的条件（共享数据）没有满足\n\n避免虚假唤醒，就不应该采用 if 条件判断，而应该采用 while 循环判断\n\n这样，即便生产者唤醒所有消费者，由于消费者这边采用 while 循环判断，确保`wait`方法会在唤醒后重新检查条件，哪怕 g_deque 中已经没有可消费对象，也不会导致这边出现虚假唤醒\n\n如果消费者这边采用 if 条件判断，由于生产者唤醒，消费者接收到信号不重新检查g_deque中是否还有可消费对象（有可能已经被其它消费者消费），导致可能出现虚假唤醒\n\n```c++\n// 虚假唤醒\n\nif (g_deque.empty())\n{\n    g_cond.wait(lck);\n}\n\n// 避免虚假唤醒\n\nwhile (g_deque.empty())\n{\n    g_cond.wait(lck);\n}\n```\n\n还有通过Lambda表达式，同样可以避免虚假唤醒\n\n即在wait方法的第二个参数提供Lambda表达式，如果返回值为true就获取锁往下执行代码\n\n```c++\ng_cond.wait(lock, []{ return !g_deque.empty(); });\n```\n\n如上两种写法的产生，就是C++11提供wait的两种方法的参数列表不同\n\n```c++\nvoid wait (unique_lock<mutex>& lck);\n\ntemplate <class Predicate>  \nvoid wait (unique_lock<mutex>& lck, Predicate pred);\n```\n\n其中 pred 代表一个可调用的对象或函数，它不接受任何参数，并返回一个可以计算为 `bool` 的值。 这将被反复调用，直到它的计算结果为 `true`\n\n\n\n\n\n","tags":["并发编程"],"categories":["technology"]},{"title":"确定剧情和不确定剧情的思考方式","url":"/2024/08/05/确定剧情和不确定剧情的思考方式/","content":"\n时常犯一个错误，就是将对文学作品的思考方式套用到现实剧情中。这种倾向容易导致一个令人困扰的现象：深思熟虑的分析有面临剧情的反转的可能。\n\n对于不确定的剧情，我们不妨避免过度的细致讨论，可以选择用武断且不失道理的话回复，或者采用模糊的措辞来回避真正的问题。不细致之故，还在于涉及到具体到人物上容易造成误会的是像大家聚堆议论他，可能出现不利于个体的情况，这种现实层面的考虑也必不可少。\n\n我不必列举文学作品的价值有哪些，你若在意答案可去别人那里寻，尽管我不知道这样的价值在哪里。从上面的认识可知，至少有一点价值可以肯定，即文学作品的剧情确定无疑由读者把握。\n\n你会注意到，同样的剧情，放到小说中更容易被接受和理解，而在现实中由于信息的不足，人们往往不得不做出最坏的设想来思考角色的所作所为。回顾《仙剑奇侠传三》，我发现龙葵的行为在某种程度上类似于绿茶，至少从晴雪的角度来看是这样。但为什么观众没有这样认为呢？因为观众站在上帝的视角，知道二人前世是兄妹关系，不可能对晴雪和景天的关系构成威胁。龙葵以血献祭来帮助哥哥（即现在的景天）铸剑，使得龙葵的心中永远只有景天，能让她感到难过的也只有景天，因此观众可以理解并同情龙葵在锁妖塔中的遭遇，了解她一路的坎坷经历。\n\n智慧只能在确定性的基础上产生，对于不确定的事情，我们应该保持一定的距离，学会倾听别人的看法，同时保留自己的意见。因为不确定的事情就像眼前的迷雾，想要看得清楚，拨雾的动作只会显得多余。更好的做法是耐心等待迷雾散去的时刻。当然，你若急于弄清真相，就要实事求是地收集资料求证，而不是对自己的言论持不负责任的态度。","tags":["零碎之思"],"categories":["article"]},{"title":"分手以后的两种方案","url":"/2024/08/05/分手以后的两种方案/","content":"\n尽管我们讲一段关系走向破碎并不是瞬时发生的事情，在此之前会有一段双方不断消耗的过程。即便如此，分手之后的后悔与无奈的情绪难免浮现，可这种随时可能复合的情感和之前记忆犹新的失望比起来略输一筹，给周边人讲起经典玻璃破碎即使修复也无法还原的故事，让众人明白没有可能回去了。\n\n如果以理性的角度来看待，尽管这可能看起来有些不近人情，快速的寻找下一任对象会得到最佳的收益。如果你是被动分手的一方，寻找下一任对象，能够回击对方带给你的伤害，而斩断两人之前错觉下的唯一性观点是最关键的一点，不用困在深情的愚蠢道德约束里面。而对于主动分手的一方，自是不用多提。\n\n恋爱初期是充满甜蜜的，因为陌生和神秘感带来的探索和占有欲。在这种感觉还没有被满足之前，恋爱的价值逐渐增加，对于刚刚分手的人来说，忘记悲伤，享受快乐，仿佛恋爱又恢复如此。而选择保持单身的人就需要付出很大的代价，自我愈合伤口，从过去的生活抽离出来，这让虚弱的身体还要去主动调动积极性去对抗的人而言属实不易，却绝非不可。然而，选择下一个伴侣可以将这些任务委托给新的伴侣，从容享受成果。\n\n从长远来看，保持单身并且努力过上健康丰富的生活，价值就比急匆匆选择下一任对象更高，因为后者的行为把自己表现的毫无价值，证明自己价值的方式不是依赖别人的肯定，而是恰如其是的自我肯定。\n\n如果一件事情只有利而无害，傻子才去做选择，而如上的两种选择的利弊关系有种很强的互补性。此外，这两种选择与道德无关，而是反映了当时你的内在状态。我知道，通常情况下，人们很少会在事情进展顺利时质疑自己的选择，问题出现时才会开始寻找原因。在那之前，很少有人会愿意深入思考这个问题。","tags":["亲密关系","零碎之思"],"categories":["article"]},{"title":"虚析构函数的场景","url":"/2024/08/05/虚析构函数的场景/","content":"\n如果这个类不作为任何类的基类，析构函数是否为虚函数并不重要，因为它不必承担回收派生类资源的责任。那什么情况下给析构函数声明为虚函数是必要的？\n\n**通过基类的指针来删除派生类的对象时，基类的析构函数应该是虚函数**。\n\n## 会被继承但不需要虚析构函数\n\n```c++\nclass NonCopyable {\n protected:\n  NonCopyable(const NonCopyable &) = delete; // 阻止拷贝\n  NonCopyable &operator=(const NonCopyable &) = delete;  // 阻止赋值\n  NonCopyable() = default;\n  ~NonCopyable() = default;\n};\n```\n\n任何需要防止被拷贝和赋值都需要删除拷贝构造函数和赋值运算符函数，为了方便，继承 NonCopyable类 即可。既然这个类就是用来给其它类继承，为何却没有把析构函数声明为虚函数呢？因为我们不会通过 NonCopyable类 来创建对象，仅仅只是提供阻止拷贝和阻止赋值的功能给到派生类。\n\n## 会被继承且需要虚析构函数\n\n```c++\nclass Derived : public NonCopyable {\npublic:\n    virtual ~Derived() {  // 添加虚析构函数\n        // Derived 的清理代码\n    }\n    void doSomething() {\n        // 示例方法\n    }\n};\n\nclass MoreDerived : public Derived {\npublic:\n    ~MoreDerived() override {\n        // MoreDerived 的清理代码\n    }\n};\n```\n\nDerived 类是 NonCopyable 的派生类，是 MoreDerived 的基类。我们前面讲过 NonCopyable 类不可能用来创建对象，现在Derived 类作为MoreDerived 的基类，当Derived 类作为MoreDerived 类对象的指针的时候，Derived 类就需要承担回收MoreDerived 类对象资源的责任（调用MoreDerived 类对象的析构函数）。基于上述分析，我们需要把Derived 类的析构函数声明为虚函数。\n\n## 析构函数的调用顺序\n\n当删除一个基类指针指向的派生类对象时，首先调用派生类的析构函数，然后调用基类的析构函数。这是为了确保派生类的资源先被正确释放，然后再释放基类的资源。\n\n```c++\nclass Base {\npublic:\n    virtual void func() {\n        std::cout << \"Base::func\" << std::endl;\n    }\n    virtual ~Base() {\n        std::cout << \"Base destructor\" << std::endl;\n    }\n};\n\nclass Derived : public Base {\npublic:\n    void func() override {\n        std::cout << \"Derived::func\" << std::endl;\n    }\n    ~Derived() override {\n        std::cout << \"Derived destructor\" << std::endl;\n    }\n};\n\nint main() {\n    Base* ptr = new Derived();\n    ptr->func(); // 调用 Derived::func\n    delete ptr;  // 确保调用 Derived 析构函数，然后调用 Base 析构函数\n    return 0;\n}\n```\n\n那我们就要提出一些有趣的问题：\n\n通过基类创建的派生类对象究竟是基类对象还是派生类对象？是派生类对象。\n\n既然是创建的派生类对象为什么需要调用基类的析构函数？虽然基类没有创建对象，但派生类对象不仅包含派生类的成员，还包含基类的成员。基类的成员是派生类对象的一部分，因此在创建派生类对象时，实际上包含了两个部分：基类部分和派生类部分。基类的成员只能由基类清理，不能由派生类清理。派生类的成员也只能由派生类清理，不能由基类清理。但是将基类的析构声明为虚函数会调用派生类的析构函数，否则只会调用自己的析构函数，从而造成派生类对象的内存泄漏。\n\n## 最后的话\n\n只要弄清楚什么情况下把析构函数声明为虚函数，才不会盲目给任何类的析构函数声明为虚函数。因为虚函数会创建虚函数表，这个不必要的开销能避免就要避免。","tags":["CPP"],"categories":["technology"]},{"title":"偶遇表哥","url":"/2024/08/05/偶遇表哥/","content":"\n当语文老师微弱的中指和食指轻夹着那只垂垂欲坠的粉笔，她的笔尖刚好足够在黑板上勉强书写。然而，随着时间推移，字迹不可避免地开始逐渐扭曲，仿佛代表着生命的枯萎。她的大拇指坚定地托着，食指却用力压住粉笔，而她的右手明显地微微颤抖。这一切似乎与学生们的课堂听课与否无关，只有前几排的学生在静静地聆听，而其他地方则是一片喧哗。\n\n刚开始转到这所学校时，我曾是一个成绩相当理想的学生，然而，逐渐深陷恶劣的学习环境后，我渐渐明白，我并非那种具备坚强意志力，能够随环境变化而灵活调整学习方法的人。仅仅不到几个月，我的学习动力就彻底消失了。一开始，我感到奇怪为什么老师不干涉学生的不良行为，她不会觉得自己受到侮辱吗？然而，我渐渐理解到，老师固然年迈，早已看透这个年龄段的学生。而我也逐渐融入了这个班级的氛围，不再关心老师的态度。\n\n那个年纪的我不会感到压力，满脑子就是玩，总计划着如何避开家里人的视线和注意溜出去。家里边不怎么给零花钱，只能到游戏厅看别人玩游戏，要是能遇到哪个熟人或者刚开始到游戏厅不会使用机器的人，主动好心帮助他人是有机会一起玩的。\n\n记得有天放学回家的路上，一如既往要去游戏厅看看，得经过一座平桥，桥上两边大概率会站着几个小混混，专门收小学生的钱，一般会招手叫你过去，拍拍你两边的裤兜，没有就放行。我的应对策略是，给里面剪一个口子，钱就会掉到最底端，或者把钱放在鞋底板下面也是比较安全的。实际上搜索的繁杂性，是对自身权力和力量的宣张，也逐渐提高对被搜索者的侮辱性。常在河边走，哪有不湿脚？但对方的目标是我表哥，可就是这样一个人，身体力量与我平起平坐的人，却在我的懦弱之下肆意妄为。但时隔多年，我却心生一个疑问，他怎么知道钱会有藏在鞋底板的可能？想必也是“天涯沦落人”，这一高一下的世界里，谁又是绝对意义上的强者，谁又是绝对意义上的弱者、可怜者，也许我没有谈及自己，从整体性来讲是不道德的，遮人耳目的。\n\n只要过了这个关卡，后面基本不会遇到麻烦事，但我已经没有心情去游戏厅，在接下来转角就会走进一个小区，对这个地方有点印象。之前刚好是枇杷树开花时期，被白洁的外表惊艳到，和朋友决定势必要上树将其取下，嗅一嗅气味后，失望之余还得骂上几句。继续往前走，小区里边有两座水泥做的石板乒乓球台，旁边就是一小段梯步，梯步后面就是平坦的小路。正打算从那边过去，刚好看到一群人正围着一个学生，我看得出他满眼惊恐，眼神盯着刚刚踹他一脚的人，立即被其呵斥，不敢再看。人群中有熟人，是我的表哥！紧张的身体一下子就放松下来，有种自信，有种理所应当的上前，不会有任何危险的以为，慢慢来到这些人的面前打声招呼，如此自然融入其中？见我在旁边看着，他就像一个足球在众人围的圆中来回折腾，圆的面积会在施加不同力度和身体稳定性变化的情况下忽大忽小，我在旁边看此圆的外表被围成的畸形无比，像个身心轻松的数学家思考此圆的面积的求法。表哥问我要不要给这个人来上一脚，反正他不敢还手，我笑着摇手以示拒绝，随后退在一旁，苦笑中略感难受。这个人被打的原因是没有完成偷手机的任务，怪不得表哥手里面有那么多的手机，当时被翻盖手机闪亮亮的外壳，以及开屏的铃声吸引，还幻想什么时候自己也能有一个。\n\n怒气在暴力的持续输出下渐渐得到安抚，人是铁饭是钢嘛，手机今天是无论如何也拿不到了，可也不能轻易地放过这小子，总得用他的手艺给大家伙办点实事，捞点好处吧？表哥一群人带着他穿过几条马路，路过一家小商铺，当时的小商铺老板眼睛也没有盯着外边。起初我不觉得这是一个破绽，但事实证明只要有胆量和手法，你观念中的不可能只是从来没有得到证明的狭隘认知而已，同时也从他身上知道熟练的小偷光天化日之下实施具体行为是表现得自然而然，而非像个小偷。他先是观察老板的动向，然后故作拉开裤子拉链撒尿的姿态，以速度略微快于普通买家但又不会以他明显能更快的速度拿走面前最近的一瓶绿茶饮料，整个过程就像付了钱一样，理应拿走属于自己的东西。老板在毫无察觉的情况下就像头上自然地脱落一根细发，无足轻重，唯我惊讶不已。小商铺的右侧就是一个小巷口，大家伙收获满满的躲进小巷，饮料你一口我一口，没一会儿就空瓶了，留了一点因来回交接的撞击下产生的气泡沫沫留给他，和小气鬼吃完辣条后给你舔包包上的辣椒油和辣椒籽一个德行。我没有参与分享饮料的过程，我身体本能的拒绝参与开始到现在的一切不正当活动，我想这是后来我与表哥走上不同人生道路的原因。后面表哥一伙还要去同学家，才知道这几个人都是互相认识的同班同学，我也就没跟着去，而是半路就选择离开，毕竟走几步就到家门口，也就告别了他们。后来听说他们也参与了偷盗行为，合伙偷了几包烟，把两个老人玩得团团转。具体情况是先安排几个人去前面故作姿态要买东西，吸引火力过去之后，由于商店的橱柜是半圆形，安排两个人去另外一个地方取出橱柜里面的烟即可，调虎离山之计得以实施。\n\n后面家里边生意发生变故，与表哥家合伙干的五金店铺最后闹掰了，为了公平起见，大家选择抓阄的方式，结果是我家没能得到店铺，最后进行财产的平均分割。我非常清楚父母为了赚钱做出过很多尝试，所以我短短几年就随着父母到处折腾，更换了很多城市和学校，成绩也是因为环境的质量忽高忽低。父母毕竟积累了一些经验，实在是不甘心放弃开五金店铺的想法，到处在周边找店铺，但是价格总不让满意，最后也是不得不选择离开那座城市，回到老家县城那边开店到现在，至此和表哥几乎断了联系。只是后面听说他没有读初中，而是选择打工，这应该是被读书无用论的想法迫害，对于几乎包里边没钱的未成年人来说，年纪轻轻被两三千元的工资诱惑是情有可原的。\n\n再一次偶遇表哥是在我从县城回老家的路上，简单的聊聊天。表哥和很多没选择继续读书的人一样，后悔当初冲动的选择，表达还是该读书的想法，但我知道这类人还是没能够想明白读书是不受太多条件制约的，感叹那番话只是错误的认为读书是安逸的地方。又或者，这只是他试图逃避当前不好处境的极端的想法，真要是把学校的内容摆在面前，恐怕就会回忆起当初的决定是多么符合自己的心意。于我而言，叶公好龙之举而已。但很遗憾，亦如当初，我只是浅笑以示回应，并没有说出这番带有提醒意味的话。也许，我一直觉得年龄比他小一岁的缘故。","tags":["短篇"],"categories":["article"]},{"title":"男女情感历程发展及其意义","url":"/2024/08/05/男女情感历程发展及其意义/","content":"\n如果不能明确表达对一个人的喜欢，那就不要随意说出来。倒不是讲传递喜欢一个人的信息之后，没过多久另喜她人是多么可耻的事情，而是会让你的话语失去可信度，想必你没有忘记“狼来了”的寓言故事。思想观念的转变更可能是进步的表征，特别是年轻的时候，可这种转变的过程应该放在心里，不管你鼓捣多少次都不为过，但如果一说出口就又收回，就难免被人看不起。接下来，我们谈论的“喜欢”是指那种已经确定不会轻易改变的情感。\n\n我发觉有些错误的观念源于对过去真实情况的遮蔽或者人为强行建立的联系。就拿社会上的感情观来讲，大家默许喜欢一个人就应该以谈恋爱为目的，谈恋爱就应该以结婚为目的。这种潜规则可不会让大家都满意，起码不让我满意。那么，为什么会发展成为这样，自然而然地事情居然堕落成非本来面目？\n\n喜欢一个人需要解释吗？可以有，可麻烦的很，你在思考这个原因的过程就是思考你自己，我建议你把这个机会留在分手之后，因为那时悲伤情绪与困惑将激发你的大脑来寻找问题的解决方案。希望这句话没有任何诅咒的隐义。\n\n为了使喜欢的情感变得更加具体，与对方建立友谊是必要的。如果你不能成为她的朋友，还指望这段关系能够长久吗？从成为朋友开始，你能够真正地了解彼此，喜欢不再是虚无缥缈的情感。不久之后，你可能会发现一个问题，她的异性朋友可能不止你一个，那怕排除这种可能，同性朋友也会影响你与她之间关系的发展。在还未成为恋人之前，异性朋友的优先权低于同性朋友，除非她喜欢你。朋友关系和恋人关系之间有明显的不同，更多的本性可能会暴露，因为距离更近了。如果在恋情中，你没有想要离开她或寻找新对象的想法，那接下来就是让两人的关系得到亲友和社会认可\n\n有一句话流传甚广：不以结婚为目的的恋爱就是流氓。但这样的言论是否道德？恋爱还只是一个选择的过程，你怎么能确定对方就是你要找的那个人，又如何确定对方是否愿意与你共度余生？如果没有足够了解对方，那么你的想法可能不太礼貌。\n\n事实上，从喜欢到恋爱，再到婚姻的过程中，两人的关系变得更加紧密，伴随着更多的道德约束。你要明白失与得就像一对双胞胎兄弟，形影不离。","tags":["亲密关系","零碎之思"],"categories":["article"]},{"title":"非此即彼之外找寻第三条路","url":"/2024/08/05/非此即彼之外找寻第三条路/","content":"\n像我这种悲观的人，一部分源于内心非此即彼的错误观念，遇到矛盾的问题就会选择逃避。逃避问题是解决问题的一种不错的选择吗？是这样的，只要你往后无需再面对这个问题，不去解决也是一种解决。可是亲密关系遭遇此类问题如果不去面对，就进入另一个矛盾中，即为放弃这段关系埋下难以根除的种子。\n\n第三条路，这是对抗看似矛盾的情景可行的思考方式，调动智慧看穿背后本质的非矛盾性。用异地恋的故事进行说明，很好体现第三条路的含义，即满足双方需求。男女双方异地，希望彼此周末能够相处一段时间，又都希望是对方来自己的城市见面，各有合理的理由和未道明的内心话，出现看似不可解决的矛盾。第三条路是什么？二人选择自己所在城市的中间城市为目的地，这样彼此能在周末见面，而且往返的路线得到缩短，就不存在你为何不满足我带来的猜疑引发对亲密关系破坏性极强的信任危机。对待同一个问题，永远不要局限于世界抛给你的选项，每多一个选项就拓宽一份认知，也就是说你得主动去认知，不要懈怠。\n\n前面提到满足这个词，我们总有一个情不自禁的假设，叫做：满足，就等于要别人为我让步。比如说，当我需要安静的时候，怎么才能满足？很多人会自动把它理解为：让别人闭嘴。那么它就会和别人的利益造成冲突，别人也不会配合。那有没有第三条路？你可以把门关上，可以出门去图书馆，你可以用降噪耳塞。有很多种方法可以实现你的需求，不是非得要别人为你让步。也就是说，我会坚持我想要实现的目标，即获得安静，但同时也不去强求别人满足我的需求，更不会去评判对方的所作所为，也就是李松蔚老师提到的对自己的每一个需求做到：不强制，不委屈，不评判。","tags":["亲密关系","零碎之思"],"categories":["article"]},{"title":"性格的一致性和互补性","url":"/2024/08/05/性格的一致性和互补性/","content":"\n曾有一个问题一直令我困扰：一本书告诉我，性格一致的人更容易获得幸福，而另一本书则坚称性格互补的人更快乐。矛盾双方给我带来的折磨激励我思考，并破除表面诱骗众人不解的虚设矛盾，实现思想上的统一，我找到了解决我内心困扰的答案。\n\n就人性而言，我们更倾向于接近那些与我们性格一致的人，这可以归因于\"吸引力三大法则\"：人们倾向于喜欢与自己相似的人、身边的人，以及难以获得的人。冲突的一部分来源于性格和观点的不一致，所以性格上背离的二人之间很难一开始建立亲密的关系。也就是说，我们会更乐意和观点上和性格上一致性强的人建立亲密关系。通过观察，我们会发现人们通常不会深入与那些持续给自己带来负面情绪的人交往，与他们保持距离常常是明智之选。因此，我们的讨论前提是：建立亲密关系的对象通常具有观点和性格上的让人感到舒服的一致性。\n\n然而，这个世界上是否存在精神层面完全相同的人？答案是否定的。即使建立在强烈一致性基础上的亲密关系也不会免于偏差，这是不可避免的事实。冲突意味着关系中可能会出现裂痕，而修复这些裂痕的过程常常令人感到难堪，独处的过程中也带来不好的情绪体验，生活中尽可能避免冲突是正常的心理。所以，现在面临的困境就是因为一致性而建立亲密关系的二人体验到不一致性，而且相处越深发现的越多。这种矛盾源于观点的错误，即冲突不好，对方和我意见不同就是不支持。\n\n首先，我们不应将一致性的强度视为最终目标，因为在面临不可避免的不一致性时，这可能会导致挫折。相反，我们应该学会适应不一致性，以实现互补性。一个很好的比喻是，我们每个人都有缺点，就像我们的后背一样，但在亲密关系中，两个人可以互相扶持，只留下积极的一面展现出来。在这种互补关系中，我们可以不断成长，变得更好。不要因为对方存在不一致之处而产生争吵，相反，可以通过适当的方法将这些不一致之处朝着积极的方向调整，以实现自我提升。此外，不一致性也为关系增加了乐趣和活力，可以让你更丰富地体验生活。","tags":["亲密关系","零碎之思"],"categories":["article"]},{"title":"浅谈AI参与写作","url":"/2024/08/05/浅谈AI参与写作/","content":"\n如果说搜索引擎可以帮我们把可能的答案罗列出来，由用户进行挑选，倒也难免没有自己想要的答案。相比之下，ChatGPT可以根据用户的提问进行理解，直接提供答案，节约时间成本显著。\n\nAI会渐渐地走向各个领域，今天就浅谈AI参与写作这件事情。首先，我持反对态度。如果你让AI写作的话，那请问还有你什么事情？你的身份是什么？除非你并不是要成为一个合格的写作者，不然你就和机器进行身份调换了，你不再是被服务者。我改动太宰治的一句话向你发问：生而为人，你很抱歉？\n\n然而，既然AI是为人类服务的，难道它在写作领域真的是罪恶至极吗？我觉得，AI可以在写作中充当润色的角色。整个作品全部要由你完成，完成之后交给AI润色是完全可以的，它的作用就相当于一个导师帮你提升作品的质量，同时你也没有成为奴隶。\n\n文章的末尾再提及AI提示功能，应用在写作上称为续写。这应用在程序员写代码上提升巨大，工作量得到明显降低，实实在在的事倍功半。但不支持用在写作上，程序员的代码重复度高，跳出的代码更接近于程序员的意图。续写功能却并非如此，而且推荐的内容无法兼顾上下文，影响到写作者的创造思路，借此反驳以此为由说续写功能能够给予作者灵感的乐观看法。\n\n无论是写作还是编写代码，初学者都不应过早依赖AI。我的建议是，像这种需要时间积累的技能，不要轻易让别人代劳。","tags":["零碎之思"],"categories":["article"]},{"title":"大学毕业","url":"/2024/06/21/大学毕业/","content":"\n大学毕业是和学生时代彻底告别\n\n![091138AF9551798EF736F25216376B06.jpg](/images/2024/08/05/86691200-52f6-11ef-a753-f7b4ec4e347a.jpg)","tags":["杂文"],"categories":["various"]}]